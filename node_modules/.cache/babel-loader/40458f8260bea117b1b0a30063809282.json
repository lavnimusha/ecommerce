{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar tslib = require('tslib');\n\nvar React = require('react');\n\nvar heyListen = require('hey-listen');\n\nvar styleValueTypes = require('style-value-types');\n\nvar popmotion = require('popmotion');\n\nvar sync = require('framesync');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\n\nvar sync__default = /*#__PURE__*/_interopDefaultLegacy(sync);\n\nvar createDefinition = function (propNames) {\n  return {\n    isEnabled: function (props) {\n      return propNames.some(function (name) {\n        return !!props[name];\n      });\n    }\n  };\n};\n\nvar featureDefinitions = {\n  measureLayout: createDefinition([\"layout\", \"layoutId\", \"drag\", \"_layoutResetTransform\"]),\n  animation: createDefinition([\"animate\", \"exit\", \"variants\", \"whileHover\", \"whileTap\", \"whileFocus\", \"whileDrag\"]),\n  exit: createDefinition([\"exit\"]),\n  drag: createDefinition([\"drag\", \"dragControls\"]),\n  focus: createDefinition([\"whileFocus\"]),\n  hover: createDefinition([\"whileHover\", \"onHoverStart\", \"onHoverEnd\"]),\n  tap: createDefinition([\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"]),\n  pan: createDefinition([\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"]),\n  layoutAnimation: createDefinition([\"layout\", \"layoutId\"])\n};\n\nfunction loadFeatures(features) {\n  for (var key in features) {\n    var Component = features[key];\n    if (Component !== null) featureDefinitions[key].Component = Component;\n  }\n}\n\nvar LazyContext = React.createContext({\n  strict: false\n});\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\n/**\n * Load features via renderless components based on the provided MotionProps.\n */\n\nfunction useFeatures(props, visualElement, preloadedFeatures) {\n  var features = [];\n  var lazyContext = React.useContext(LazyContext);\n  if (!visualElement) return null;\n  /**\n   * If we're in development mode, check to make sure we're not rendering a motion component\n   * as a child of LazyMotion, as this will break the file-size benefits of using it.\n   */\n\n  if (process.env.NODE_ENV !== \"production\" && preloadedFeatures && lazyContext.strict) {\n    heyListen.invariant(false, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n  }\n\n  for (var i = 0; i < numFeatures; i++) {\n    var name_1 = featureNames[i];\n    var _a = featureDefinitions[name_1],\n        isEnabled = _a.isEnabled,\n        Component = _a.Component;\n    /**\n     * It might be possible in the future to use this moment to\n     * dynamically request functionality. In initial tests this\n     * was producing a lot of duplication amongst bundles.\n     */\n\n    if (isEnabled(props) && Component) {\n      features.push(React__namespace.createElement(Component, tslib.__assign({\n        key: name_1\n      }, props, {\n        visualElement: visualElement\n      })));\n    }\n  }\n\n  return features;\n}\n/**\n * @public\n */\n\n\nvar MotionConfigContext = React.createContext({\n  transformPagePoint: function (p) {\n    return p;\n  },\n  isStatic: false\n});\nvar MotionContext = React.createContext({});\n\nfunction useVisualElementContext() {\n  return React.useContext(MotionContext).visualElement;\n}\n/**\n * @public\n */\n\n\nvar PresenceContext = React.createContext(null);\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\n\nfunction useConstant(init) {\n  var ref = React.useRef(null);\n\n  if (ref.current === null) {\n    ref.current = init();\n  }\n\n  return ref.current;\n}\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\n\n\nfunction usePresence() {\n  var context = React.useContext(PresenceContext);\n  if (context === null) return [true, null];\n  var isPresent = context.isPresent,\n      onExitComplete = context.onExitComplete,\n      register = context.register; // It's safe to call the following hooks conditionally (after an early return) because the context will always\n  // either be null or non-null for the lifespan of the component.\n  // Replace with useOpaqueId when released in React\n\n  var id = useUniqueId();\n  React.useEffect(function () {\n    return register(id);\n  }, []);\n\n  var safeToRemove = function () {\n    return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id);\n  };\n\n  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useIsPresent() {\n  return isPresent(React.useContext(PresenceContext));\n}\n\nfunction isPresent(context) {\n  return context === null ? true : context.isPresent;\n}\n\nvar counter = 0;\n\nvar incrementId = function () {\n  return counter++;\n};\n\nvar useUniqueId = function () {\n  return useConstant(incrementId);\n};\n/**\n * @internal\n */\n\n\nvar LayoutGroupContext = React.createContext(null);\nvar isBrowser = typeof window !== \"undefined\";\nvar useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;\n\nfunction useLayoutId(_a) {\n  var layoutId = _a.layoutId;\n  var layoutGroupId = React.useContext(LayoutGroupContext);\n  return layoutGroupId && layoutId !== undefined ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\n\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\n  var config = React.useContext(MotionConfigContext);\n  var lazyContext = React.useContext(LazyContext);\n  var parent = useVisualElementContext();\n  var presenceContext = React.useContext(PresenceContext);\n  var layoutId = useLayoutId(props);\n  var visualElementRef = React.useRef(undefined);\n  /**\n   * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n   */\n\n  if (!createVisualElement) createVisualElement = lazyContext.renderer;\n\n  if (!visualElementRef.current && createVisualElement) {\n    visualElementRef.current = createVisualElement(Component, {\n      visualState: visualState,\n      parent: parent,\n      props: tslib.__assign(tslib.__assign({}, props), {\n        layoutId: layoutId\n      }),\n      presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,\n      blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false\n    });\n  }\n\n  var visualElement = visualElementRef.current;\n  useIsomorphicLayoutEffect(function () {\n    if (!visualElement) return;\n    visualElement.setProps(tslib.__assign(tslib.__assign(tslib.__assign({}, config), props), {\n      layoutId: layoutId\n    }));\n    visualElement.isPresent = isPresent(presenceContext);\n    visualElement.isPresenceRoot = !parent || parent.presenceId !== (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id);\n    /**\n     * Fire a render to ensure the latest state is reflected on-screen.\n     */\n\n    visualElement.syncRender();\n  });\n  React.useEffect(function () {\n    var _a;\n\n    if (!visualElement) return;\n    /**\n     * In a future refactor we can replace the features-as-components and\n     * have this loop through them all firing \"effect\" listeners\n     */\n\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();\n  });\n  useIsomorphicLayoutEffect(function () {\n    return function () {\n      return visualElement === null || visualElement === void 0 ? void 0 : visualElement.notifyUnmount();\n    };\n  }, []);\n  return visualElement;\n}\n\nfunction isRefObject(ref) {\n  return typeof ref === \"object\" && Object.prototype.hasOwnProperty.call(ref, \"current\");\n}\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\n\n\nfunction useMotionRef(visualState, visualElement, externalRef) {\n  return React.useCallback(function (instance) {\n    var _a;\n\n    instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));\n\n    if (visualElement) {\n      instance ? visualElement.mount(instance) : visualElement.unmount();\n    }\n\n    if (externalRef) {\n      if (typeof externalRef === \"function\") {\n        externalRef(instance);\n      } else if (isRefObject(externalRef)) {\n        externalRef.current = instance;\n      }\n    }\n  },\n  /**\n   * Only pass a new ref callback to React if we've received a visual element\n   * factory. Otherwise we'll be mounting/remounting every time externalRef\n   * or other dependencies change.\n   */\n  [visualElement]);\n}\n/**\n * Decides if the supplied variable is an array of variant labels\n */\n\n\nfunction isVariantLabels(v) {\n  return Array.isArray(v);\n}\n/**\n * Decides if the supplied variable is variant label\n */\n\n\nfunction isVariantLabel(v) {\n  return typeof v === \"string\" || isVariantLabels(v);\n}\n/**\n * Creates an object containing the latest state of every MotionValue on a VisualElement\n */\n\n\nfunction getCurrent(visualElement) {\n  var current = {};\n  visualElement.forEachValue(function (value, key) {\n    return current[key] = value.get();\n  });\n  return current;\n}\n/**\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\n */\n\n\nfunction getVelocity$1(visualElement) {\n  var velocity = {};\n  visualElement.forEachValue(function (value, key) {\n    return velocity[key] = value.getVelocity();\n  });\n  return velocity;\n}\n\nfunction resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {\n  var _a;\n\n  if (currentValues === void 0) {\n    currentValues = {};\n  }\n\n  if (currentVelocity === void 0) {\n    currentVelocity = {};\n  }\n\n  if (typeof definition === \"string\") {\n    definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];\n  }\n\n  return typeof definition === \"function\" ? definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity) : definition;\n}\n\nfunction resolveVariant(visualElement, definition, custom) {\n  var props = visualElement.getProps();\n  return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));\n}\n\nfunction checkIfControllingVariants(props) {\n  var _a;\n\n  return typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === \"function\" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);\n}\n\nfunction checkIfVariantNode(props) {\n  return Boolean(checkIfControllingVariants(props) || props.variants);\n}\n\nfunction getCurrentTreeVariants(props, context) {\n  if (checkIfControllingVariants(props)) {\n    var initial = props.initial,\n        animate = props.animate;\n    return {\n      initial: initial === false || isVariantLabel(initial) ? initial : undefined,\n      animate: isVariantLabel(animate) ? animate : undefined\n    };\n  }\n\n  return props.inherit !== false ? context : {};\n}\n\nfunction useCreateMotionContext(props, isStatic) {\n  var _a = getCurrentTreeVariants(props, React.useContext(MotionContext)),\n      initial = _a.initial,\n      animate = _a.animate;\n\n  return React.useMemo(function () {\n    return {\n      initial: initial,\n      animate: animate\n    };\n  },\n  /**\n   * Only break memoisation in static mode\n   */\n  isStatic ? [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)] : []);\n}\n\nfunction variantLabelsAsDependency(prop) {\n  return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\n\n\nfunction createMotionComponent(_a) {\n  var preloadedFeatures = _a.preloadedFeatures,\n      createVisualElement = _a.createVisualElement,\n      useRender = _a.useRender,\n      useVisualState = _a.useVisualState,\n      Component = _a.Component;\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n\n  function MotionComponent(props, externalRef) {\n    /**\n     * If we're rendering in a static environment, we only visually update the component\n     * as a result of a React-rerender rather than interactions or animations. This\n     * means we don't need to load additional memory structures like VisualElement,\n     * or any gesture/animation features.\n     */\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\n    var features = null;\n    /**\n     * Create the tree context. This is memoized and will only trigger renders\n     * when the current tree variant changes in static mode.\n     */\n\n    var context = useCreateMotionContext(props, isStatic);\n    /**\n     *\n     */\n\n    var visualState = useVisualState(props, isStatic);\n\n    if (!isStatic && isBrowser) {\n      /**\n       * Create a VisualElement for this component. A VisualElement provides a common\n       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n       * providing a way of rendering to these APIs outside of the React render loop\n       * for more performant animations and interactions\n       */\n      context.visualElement = useVisualElement(Component, visualState, props, createVisualElement);\n      /**\n       * Load Motion gesture and animation features. These are rendered as renderless\n       * components so each feature can optionally make use of React lifecycle methods.\n       *\n       * TODO: The intention is to move these away from a React-centric to a\n       * VisualElement-centric lifecycle scheme.\n       */\n\n      features = useFeatures(props, context.visualElement, preloadedFeatures);\n    }\n    /**\n     * The mount order and hierarchy is specific to ensure our element ref\n     * is hydrated by the time features fire their effects.\n     */\n\n\n    return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(MotionContext.Provider, {\n      value: context\n    }, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)), features);\n  }\n\n  return React.forwardRef(MotionComponent);\n}\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion(Component)\n * ```\n *\n * @public\n */\n\n\nfunction createMotionProxy(createConfig) {\n  function custom(Component, customMotionComponentConfig) {\n    if (customMotionComponentConfig === void 0) {\n      customMotionComponentConfig = {};\n    }\n\n    return createMotionComponent(createConfig(Component, customMotionComponentConfig));\n  }\n  /**\n   * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n   * Rather than generating them anew every render.\n   */\n\n\n  var componentCache = new Map();\n  return new Proxy(custom, {\n    /**\n     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n     * The prop name is passed through as `key` and we can use that to generate a `motion`\n     * DOM component with that name.\n     */\n    get: function (_target, key) {\n      /**\n       * If this element doesn't exist in the component cache, create it and cache.\n       */\n      if (!componentCache.has(key)) {\n        componentCache.set(key, custom(key));\n      }\n\n      return componentCache.get(key);\n    }\n  });\n}\n/**\n * We keep these listed seperately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\n\n\nvar lowercaseSVGElements = [\"animate\", \"circle\", \"defs\", \"desc\", \"ellipse\", \"g\", \"image\", \"line\", \"filter\", \"marker\", \"mask\", \"metadata\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"rect\", \"stop\", \"svg\", \"switch\", \"symbol\", \"text\", \"tspan\", \"use\", \"view\"];\n\nfunction isSVGComponent(Component) {\n  if (\n  /**\n   * If it's not a string, it's a custom React component. Currently we only support\n   * HTML custom React components.\n   */\n  typeof Component !== \"string\" ||\n  /**\n   * If it contains a dash, the element is a custom HTML webcomponent.\n   */\n  Component.includes(\"-\")) {\n    return false;\n  } else if (\n  /**\n   * If it's in our list of lowercase SVG tags, it's an SVG component\n   */\n  lowercaseSVGElements.indexOf(Component) > -1 ||\n  /**\n   * If it contains a capital letter, it's an SVG component\n   */\n  /[A-Z]/.test(Component)) {\n    return true;\n  }\n\n  return false;\n}\n\nvar valueScaleCorrection = {};\n/**\n * @internal\n */\n\nfunction addScaleCorrection(correctors) {\n  for (var key in correctors) {\n    valueScaleCorrection[key] = correctors[key];\n  }\n}\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\n\n\nvar transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\n\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\n/**\n * Generate a list of every possible transform key.\n */\n\nvar transformProps = [\"transformPerspective\", \"x\", \"y\", \"z\"];\norder.forEach(function (operationKey) {\n  return transformAxes.forEach(function (axesKey) {\n    return transformProps.push(operationKey + axesKey);\n  });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\n\nfunction sortTransformProps(a, b) {\n  return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */\n\n\nvar transformPropSet = new Set(transformProps);\n\nfunction isTransformProp(key) {\n  return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */\n\n\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\n\nfunction isTransformOriginProp(key) {\n  return transformOriginProps.has(key);\n}\n\nfunction isForcedMotionValue(key, _a) {\n  var layout = _a.layout,\n      layoutId = _a.layoutId;\n  return isTransformProp(key) || isTransformOriginProp(key) || (layout || layoutId !== undefined) && (!!valueScaleCorrection[key] || key === \"opacity\");\n}\n\nvar isMotionValue = function (value) {\n  return value !== null && typeof value === \"object\" && value.getVelocity;\n};\n\nvar translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\",\n  transformPerspective: \"perspective\"\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\n\nfunction buildTransform(_a, _b, transformIsDefault, transformTemplate) {\n  var transform = _a.transform,\n      transformKeys = _a.transformKeys;\n  var _c = _b.enableHardwareAcceleration,\n      enableHardwareAcceleration = _c === void 0 ? true : _c,\n      _d = _b.allowTransformNone,\n      allowTransformNone = _d === void 0 ? true : _d; // The transform string we're going to build into.\n\n  var transformString = \"\"; // Transform keys into their default order - this will determine the output order.\n\n  transformKeys.sort(sortTransformProps); // Track whether the defined transform has a defined z so we don't add a\n  // second to enable hardware acceleration\n\n  var transformHasZ = false; // Loop over each transform and build them into transformString\n\n  var numTransformKeys = transformKeys.length;\n\n  for (var i = 0; i < numTransformKeys; i++) {\n    var key = transformKeys[i];\n    transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n    if (key === \"z\") transformHasZ = true;\n  }\n\n  if (!transformHasZ && enableHardwareAcceleration) {\n    transformString += \"translateZ(0)\";\n  } else {\n    transformString = transformString.trim();\n  } // If we have a custom `transform` template, pass our transform values and\n  // generated transformString to that before returning\n\n\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n\n  return transformString;\n}\n/**\n * Build a transformOrigin style. Uses the same defaults as the browser for\n * undefined origins.\n */\n\n\nfunction buildTransformOrigin(_a) {\n  var _b = _a.originX,\n      originX = _b === void 0 ? \"50%\" : _b,\n      _c = _a.originY,\n      originY = _c === void 0 ? \"50%\" : _c,\n      _d = _a.originZ,\n      originZ = _d === void 0 ? 0 : _d;\n  return originX + \" \" + originY + \" \" + originZ;\n}\n/**\n * Returns true if the provided key is a CSS variable\n */\n\n\nfunction isCSSVariable$1(key) {\n  return key.startsWith(\"--\");\n}\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\n\n\nvar getValueAsType = function (value, type) {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\n\nvar int = tslib.__assign(tslib.__assign({}, styleValueTypes.number), {\n  transform: Math.round\n});\n\nvar numberValueTypes = {\n  // Border props\n  borderWidth: styleValueTypes.px,\n  borderTopWidth: styleValueTypes.px,\n  borderRightWidth: styleValueTypes.px,\n  borderBottomWidth: styleValueTypes.px,\n  borderLeftWidth: styleValueTypes.px,\n  borderRadius: styleValueTypes.px,\n  radius: styleValueTypes.px,\n  borderTopLeftRadius: styleValueTypes.px,\n  borderTopRightRadius: styleValueTypes.px,\n  borderBottomRightRadius: styleValueTypes.px,\n  borderBottomLeftRadius: styleValueTypes.px,\n  // Positioning props\n  width: styleValueTypes.px,\n  maxWidth: styleValueTypes.px,\n  height: styleValueTypes.px,\n  maxHeight: styleValueTypes.px,\n  size: styleValueTypes.px,\n  top: styleValueTypes.px,\n  right: styleValueTypes.px,\n  bottom: styleValueTypes.px,\n  left: styleValueTypes.px,\n  // Spacing props\n  padding: styleValueTypes.px,\n  paddingTop: styleValueTypes.px,\n  paddingRight: styleValueTypes.px,\n  paddingBottom: styleValueTypes.px,\n  paddingLeft: styleValueTypes.px,\n  margin: styleValueTypes.px,\n  marginTop: styleValueTypes.px,\n  marginRight: styleValueTypes.px,\n  marginBottom: styleValueTypes.px,\n  marginLeft: styleValueTypes.px,\n  // Transform props\n  rotate: styleValueTypes.degrees,\n  rotateX: styleValueTypes.degrees,\n  rotateY: styleValueTypes.degrees,\n  rotateZ: styleValueTypes.degrees,\n  scale: styleValueTypes.scale,\n  scaleX: styleValueTypes.scale,\n  scaleY: styleValueTypes.scale,\n  scaleZ: styleValueTypes.scale,\n  skew: styleValueTypes.degrees,\n  skewX: styleValueTypes.degrees,\n  skewY: styleValueTypes.degrees,\n  distance: styleValueTypes.px,\n  translateX: styleValueTypes.px,\n  translateY: styleValueTypes.px,\n  translateZ: styleValueTypes.px,\n  x: styleValueTypes.px,\n  y: styleValueTypes.px,\n  z: styleValueTypes.px,\n  perspective: styleValueTypes.px,\n  transformPerspective: styleValueTypes.px,\n  opacity: styleValueTypes.alpha,\n  originX: styleValueTypes.progressPercentage,\n  originY: styleValueTypes.progressPercentage,\n  originZ: styleValueTypes.px,\n  // Misc\n  zIndex: int,\n  // SVG\n  fillOpacity: styleValueTypes.alpha,\n  strokeOpacity: styleValueTypes.alpha,\n  numOctaves: int\n};\n\nfunction buildHTMLStyles(state, latestValues, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\n  var _a;\n\n  var style = state.style,\n      vars = state.vars,\n      transform = state.transform,\n      transformKeys = state.transformKeys,\n      transformOrigin = state.transformOrigin; // Empty the transformKeys array. As we're throwing out refs to its items\n  // this might not be as cheap as suspected. Maybe using the array as a buffer\n  // with a manual incrementation would be better.\n\n  transformKeys.length = 0; // Track whether we encounter any transform or transformOrigin values.\n\n  var hasTransform = false;\n  var hasTransformOrigin = false; // Does the calculated transform essentially equal \"none\"?\n\n  var transformIsNone = true;\n  /**\n   * Loop over all our latest animated values and decide whether to handle them\n   * as a style or CSS variable.\n   *\n   * Transforms and transform origins are kept seperately for further processing.\n   */\n\n  for (var key in latestValues) {\n    var value = latestValues[key];\n    /**\n     * If this is a CSS variable we don't do any further processing.\n     */\n\n    if (isCSSVariable$1(key)) {\n      vars[key] = value;\n      continue;\n    } // Convert the value to its default value type, ie 0 -> \"0px\"\n\n\n    var valueType = numberValueTypes[key];\n    var valueAsType = getValueAsType(value, valueType);\n\n    if (isTransformProp(key)) {\n      // If this is a transform, flag to enable further transform processing\n      hasTransform = true;\n      transform[key] = valueAsType;\n      transformKeys.push(key); // If we already know we have a non-default transform, early return\n\n      if (!transformIsNone) continue; // Otherwise check to see if this is a default transform\n\n      if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0)) transformIsNone = false;\n    } else if (isTransformOriginProp(key)) {\n      transformOrigin[key] = valueAsType; // If this is a transform origin, flag and enable further transform-origin processing\n\n      hasTransformOrigin = true;\n    } else {\n      /**\n       * If layout projection is on, and we need to perform scale correction for this\n       * value type, perform it.\n       */\n      if ((projection === null || projection === void 0 ? void 0 : projection.isHydrated) && (layoutState === null || layoutState === void 0 ? void 0 : layoutState.isHydrated) && valueScaleCorrection[key]) {\n        var correctedValue = valueScaleCorrection[key].process(value, layoutState, projection);\n        /**\n         * Scale-correctable values can define a number of other values to break\n         * down into. For instance borderRadius needs applying to borderBottomLeftRadius etc\n         */\n\n        var applyTo = valueScaleCorrection[key].applyTo;\n\n        if (applyTo) {\n          var num = applyTo.length;\n\n          for (var i = 0; i < num; i++) {\n            style[applyTo[i]] = correctedValue;\n          }\n        } else {\n          style[key] = correctedValue;\n        }\n      } else {\n        style[key] = valueAsType;\n      }\n    }\n  }\n\n  if (layoutState && projection && buildProjectionTransform && buildProjectionTransformOrigin) {\n    style.transform = buildProjectionTransform(layoutState.deltaFinal, layoutState.treeScale, hasTransform ? transform : undefined);\n\n    if (transformTemplate) {\n      style.transform = transformTemplate(transform, style.transform);\n    }\n\n    style.transformOrigin = buildProjectionTransformOrigin(layoutState);\n  } else {\n    if (hasTransform) {\n      style.transform = buildTransform(state, options, transformIsNone, transformTemplate);\n    }\n\n    if (hasTransformOrigin) {\n      style.transformOrigin = buildTransformOrigin(transformOrigin);\n    }\n  }\n}\n\nvar createHtmlRenderState = function () {\n  return {\n    style: {},\n    transform: {},\n    transformKeys: [],\n    transformOrigin: {},\n    vars: {}\n  };\n};\n\nfunction copyRawValuesOnly(target, source, props) {\n  for (var key in source) {\n    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction useInitialMotionValues(_a, visualState, isStatic) {\n  var transformTemplate = _a.transformTemplate;\n  return React.useMemo(function () {\n    var state = createHtmlRenderState();\n    buildHTMLStyles(state, visualState, undefined, undefined, {\n      enableHardwareAcceleration: !isStatic\n    }, transformTemplate);\n    var vars = state.vars,\n        style = state.style;\n    return tslib.__assign(tslib.__assign({}, vars), style);\n  }, [visualState]);\n}\n\nfunction useStyle(props, visualState, isStatic) {\n  var styleProp = props.style || {};\n  var style = {};\n  /**\n   * Copy non-Motion Values straight into style\n   */\n\n  copyRawValuesOnly(style, styleProp, props);\n  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n\n  if (props.transformValues) {\n    style = props.transformValues(style);\n  }\n\n  return style;\n}\n\nfunction useHTMLProps(props, visualState, isStatic) {\n  // The `any` isn't ideal but it is the type of createElement props argument\n  var htmlProps = {};\n  var style = useStyle(props, visualState, isStatic);\n\n  if (Boolean(props.drag)) {\n    // Disable the ghost element when a user drags\n    htmlProps.draggable = false; // Disable text selection\n\n    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = \"none\"; // Disable scrolling on the draggable direction\n\n    style.touchAction = props.drag === true ? \"none\" : \"pan-\" + (props.drag === \"x\" ? \"y\" : \"x\");\n  }\n\n  htmlProps.style = style;\n  return htmlProps;\n}\n/**\n * A list of all valid MotionProps.\n *\n * @internalremarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\n\n\nvar validMotionProps = new Set([\"initial\", \"animate\", \"exit\", \"style\", \"variants\", \"transition\", \"transformTemplate\", \"transformValues\", \"custom\", \"inherit\", \"layout\", \"layoutId\", \"_layoutResetTransform\", \"onLayoutAnimationComplete\", \"onViewportBoxUpdate\", \"onLayoutMeasure\", \"onBeforeLayoutMeasure\", \"onAnimationStart\", \"onAnimationComplete\", \"onUpdate\", \"onDragStart\", \"onDrag\", \"onDragEnd\", \"onMeasureDragConstraints\", \"onDirectionLock\", \"onDragTransitionEnd\", \"drag\", \"dragControls\", \"dragListener\", \"dragConstraints\", \"dragDirectionLock\", \"_dragX\", \"_dragY\", \"dragElastic\", \"dragMomentum\", \"dragPropagation\", \"dragTransition\", \"whileDrag\", \"onPan\", \"onPanStart\", \"onPanEnd\", \"onPanSessionStart\", \"onTap\", \"onTapStart\", \"onTapCancel\", \"onHoverStart\", \"onHoverEnd\", \"whileFocus\", \"whileTap\", \"whileHover\"]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\n\nfunction isValidMotionProp(key) {\n  return validMotionProps.has(key);\n}\n\nvar shouldForward = function (key) {\n  return !isValidMotionProp(key);\n};\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\n\n\ntry {\n  var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\").default;\n\n  shouldForward = function (key) {\n    // Handle events explicitly as Emotion validates them all as true\n    if (key.startsWith(\"on\")) {\n      return !isValidMotionProp(key);\n    } else {\n      return emotionIsPropValid_1(key);\n    }\n  };\n} catch (_a) {// We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\n\nfunction filterProps(props, isDom, forwardMotionProps) {\n  var filteredProps = {};\n\n  for (var key in props) {\n    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key)) {\n      filteredProps[key] = props[key];\n    }\n  }\n\n  return filteredProps;\n}\n\nfunction calcOrigin$1(origin, offset, size) {\n  return typeof origin === \"string\" ? origin : styleValueTypes.px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\n\n\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\n  var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\n  return pxOriginX + \" \" + pxOriginY;\n} // Convert a progress 0-1 to a pixels value based on the provided length\n\n\nvar progressToPixels = function (progress, length) {\n  return styleValueTypes.px.transform(progress * length);\n};\n\nvar dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\n\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\n  if (spacing === void 0) {\n    spacing = 1;\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  if (useDashCase === void 0) {\n    useDashCase = true;\n  } // We use dash case when setting attributes directly to the DOM node and camel case\n  // when defining props on a React component.\n\n\n  var keys = useDashCase ? dashKeys : camelKeys; // Build the dash offset\n\n  attrs[keys.offset] = progressToPixels(-offset, totalLength); // Build the dash array\n\n  var pathLength = progressToPixels(length, totalLength);\n  var pathSpacing = progressToPixels(spacing, totalLength);\n  attrs[keys.array] = pathLength + \" \" + pathSpacing;\n}\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\n\n\nfunction buildSVGAttrs(state, _a, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\n  var attrX = _a.attrX,\n      attrY = _a.attrY,\n      originX = _a.originX,\n      originY = _a.originY,\n      pathLength = _a.pathLength,\n      _b = _a.pathSpacing,\n      pathSpacing = _b === void 0 ? 1 : _b,\n      _c = _a.pathOffset,\n      pathOffset = _c === void 0 ? 0 : _c,\n      // This is object creation, which we try to avoid per-frame.\n  latest = tslib.__rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n\n  buildHTMLStyles(state, latest, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin);\n  state.attrs = state.style;\n  state.style = {};\n  var attrs = state.attrs,\n      style = state.style,\n      dimensions = state.dimensions,\n      totalPathLength = state.totalPathLength;\n  /**\n   * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n   * and copy it into style.\n   */\n\n  if (attrs.transform) {\n    if (dimensions) style.transform = attrs.transform;\n    delete attrs.transform;\n  } // Parse transformOrigin\n\n\n  if (dimensions && (originX !== undefined || originY !== undefined || style.transform)) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n  } // Treat x/y not as shortcuts but as actual attributes\n\n\n  if (attrX !== undefined) attrs.x = attrX;\n  if (attrY !== undefined) attrs.y = attrY; // Build SVG path if one has been measured\n\n  if (totalPathLength !== undefined && pathLength !== undefined) {\n    buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\n  }\n}\n\nvar createSvgRenderState = function () {\n  return tslib.__assign(tslib.__assign({}, createHtmlRenderState()), {\n    attrs: {}\n  });\n};\n\nfunction useSVGProps(props, visualState) {\n  var visualProps = React.useMemo(function () {\n    var state = createSvgRenderState();\n    buildSVGAttrs(state, visualState, undefined, undefined, {\n      enableHardwareAcceleration: false\n    }, props.transformTemplate);\n    return tslib.__assign(tslib.__assign({}, state.attrs), {\n      style: tslib.__assign({}, state.style)\n    });\n  }, [visualState]);\n\n  if (props.style) {\n    var rawStyles = {};\n    copyRawValuesOnly(rawStyles, props.style, props);\n    visualProps.style = tslib.__assign(tslib.__assign({}, rawStyles), visualProps.style);\n  }\n\n  return visualProps;\n}\n\nfunction createUseRender(forwardMotionProps) {\n  if (forwardMotionProps === void 0) {\n    forwardMotionProps = false;\n  }\n\n  var useRender = function (Component, props, ref, _a, isStatic) {\n    var latestValues = _a.latestValues;\n    var useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;\n    var visualProps = useVisualProps(props, latestValues, isStatic);\n    var filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n\n    var elementProps = tslib.__assign(tslib.__assign(tslib.__assign({}, filteredProps), visualProps), {\n      ref: ref\n    });\n\n    return React.createElement(Component, elementProps);\n  };\n\n  return useRender;\n}\n\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\n * Convert camelCase to dash-case properties.\n */\n\nvar camelToDash = function (str) {\n  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n\nfunction renderHTML(element, _a) {\n  var style = _a.style,\n      vars = _a.vars; // Directly assign style into the Element's style prop. In tests Object.assign is the\n  // fastest way to assign styles.\n\n  Object.assign(element.style, style); // Loop over any CSS variables and assign those.\n\n  for (var key in vars) {\n    element.style.setProperty(key, vars[key]);\n  }\n}\n/**\n * A set of attribute names that are always read/written as camel case.\n */\n\n\nvar camelCaseAttributes = new Set([\"baseFrequency\", \"diffuseConstant\", \"kernelMatrix\", \"kernelUnitLength\", \"keySplines\", \"keyTimes\", \"limitingConeAngle\", \"markerHeight\", \"markerWidth\", \"numOctaves\", \"targetX\", \"targetY\", \"surfaceScale\", \"specularConstant\", \"specularExponent\", \"stdDeviation\", \"tableValues\", \"viewBox\", \"gradientTransform\"]);\n\nfunction renderSVG(element, renderState) {\n  renderHTML(element, renderState);\n\n  for (var key in renderState.attrs) {\n    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n  }\n}\n\nfunction scrapeMotionValuesFromProps$1(props) {\n  var style = props.style;\n  var newValues = {};\n\n  for (var key in style) {\n    if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n      newValues[key] = style[key];\n    }\n  }\n\n  return newValues;\n}\n\nfunction scrapeMotionValuesFromProps(props) {\n  var newValues = scrapeMotionValuesFromProps$1(props);\n\n  for (var key in props) {\n    if (isMotionValue(props[key])) {\n      var targetKey = key === \"x\" || key === \"y\" ? \"attr\" + key.toUpperCase() : key;\n      newValues[targetKey] = props[key];\n    }\n  }\n\n  return newValues;\n}\n\nfunction isAnimationControls(v) {\n  return typeof v === \"object\" && typeof v.start === \"function\";\n}\n\nvar isKeyframesTarget = function (v) {\n  return Array.isArray(v);\n};\n\nvar isCustomValue = function (v) {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\n\nvar resolveFinalValueInKeyframes = function (v) {\n  // TODO maybe throw if v.length - 1 is placeholder token?\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n *\n * @internal\n */\n\n\nfunction resolveMotionValue(value) {\n  var unwrappedValue = isMotionValue(value) ? value.get() : value;\n  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\n\nfunction makeState(_a, props, context, presenceContext) {\n  var scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps,\n      createRenderState = _a.createRenderState,\n      onMount = _a.onMount;\n  var state = {\n    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n    renderState: createRenderState()\n  };\n\n  if (onMount) {\n    state.mount = function (instance) {\n      return onMount(props, instance, state);\n    };\n  }\n\n  return state;\n}\n\nvar makeUseVisualState = function (config) {\n  return function (props, isStatic) {\n    var context = React.useContext(MotionContext);\n    var presenceContext = React.useContext(PresenceContext);\n    return isStatic ? makeState(config, props, context, presenceContext) : useConstant(function () {\n      return makeState(config, props, context, presenceContext);\n    });\n  };\n};\n\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n  var values = {};\n  var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;\n  var motionValues = scrapeMotionValues(props);\n\n  for (var key in motionValues) {\n    values[key] = resolveMotionValue(motionValues[key]);\n  }\n\n  var initial = props.initial,\n      animate = props.animate;\n  var isControllingVariants = checkIfControllingVariants(props);\n  var isVariantNode = checkIfVariantNode(props);\n\n  if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {\n    initial !== null && initial !== void 0 ? initial : initial = context.initial;\n    animate !== null && animate !== void 0 ? animate : animate = context.animate;\n  }\n\n  var variantToSet = blockInitialAnimation || initial === false ? animate : initial;\n\n  if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n    var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n    list.forEach(function (definition) {\n      var resolved = resolveVariantFromProps(props, definition);\n      if (!resolved) return;\n      var transitionEnd = resolved.transitionEnd;\n      resolved.transition;\n\n      var target = tslib.__rest(resolved, [\"transitionEnd\", \"transition\"]);\n\n      for (var key in target) values[key] = target[key];\n\n      for (var key in transitionEnd) values[key] = transitionEnd[key];\n    });\n  }\n\n  return values;\n}\n\nvar svgMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n    createRenderState: createSvgRenderState,\n    onMount: function (props, instance, _a) {\n      var renderState = _a.renderState,\n          latestValues = _a.latestValues;\n\n      try {\n        renderState.dimensions = typeof instance.getBBox === \"function\" ? instance.getBBox() : instance.getBoundingClientRect();\n      } catch (e) {\n        // Most likely trying to measure an unrendered element under Firefox\n        renderState.dimensions = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n\n      if (isPath(instance)) {\n        renderState.totalPathLength = instance.getTotalLength();\n      }\n\n      buildSVGAttrs(renderState, latestValues, undefined, undefined, {\n        enableHardwareAcceleration: false\n      }, props.transformTemplate); // TODO: Replace with direct assignment\n\n      renderSVG(instance, renderState);\n    }\n  })\n};\n\nfunction isPath(element) {\n  return element.tagName === \"path\";\n}\n\nvar htmlMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n    createRenderState: createHtmlRenderState\n  })\n};\n\nfunction createDomMotionConfig(Component, _a, preloadedFeatures, createVisualElement) {\n  var _b = _a.forwardMotionProps,\n      forwardMotionProps = _b === void 0 ? false : _b;\n  var baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;\n  return tslib.__assign(tslib.__assign({}, baseConfig), {\n    preloadedFeatures: preloadedFeatures,\n    useRender: createUseRender(forwardMotionProps),\n    createVisualElement: createVisualElement,\n    Component: Component\n  });\n}\n\nvar AnimationType;\n\n(function (AnimationType) {\n  AnimationType[\"Animate\"] = \"animate\";\n  AnimationType[\"Hover\"] = \"whileHover\";\n  AnimationType[\"Tap\"] = \"whileTap\";\n  AnimationType[\"Drag\"] = \"whileDrag\";\n  AnimationType[\"Focus\"] = \"whileFocus\";\n  AnimationType[\"Exit\"] = \"exit\";\n})(AnimationType || (AnimationType = {}));\n\nfunction addDomEvent(target, eventName, handler, options) {\n  target.addEventListener(eventName, handler, options);\n  return function () {\n    return target.removeEventListener(eventName, handler, options);\n  };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\n\n\nfunction useDomEvent(ref, eventName, handler, options) {\n  React.useEffect(function () {\n    var element = ref.current;\n\n    if (handler && element) {\n      return addDomEvent(element, eventName, handler, options);\n    }\n  }, [ref, eventName, handler, options]);\n}\n/**\n *\n * @param props\n * @param ref\n * @internal\n */\n\n\nfunction useFocusGesture(_a) {\n  var whileFocus = _a.whileFocus,\n      visualElement = _a.visualElement;\n\n  var onFocus = function () {\n    var _a;\n\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, true);\n  };\n\n  var onBlur = function () {\n    var _a;\n\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, false);\n  };\n\n  useDomEvent(visualElement, \"focus\", whileFocus ? onFocus : undefined);\n  useDomEvent(visualElement, \"blur\", whileFocus ? onBlur : undefined);\n}\n\nfunction isMouseEvent(event) {\n  // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n  if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n    return !!(event.pointerType === \"mouse\");\n  }\n\n  return event instanceof MouseEvent;\n}\n\nfunction isTouchEvent(event) {\n  var hasTouches = !!event.touches;\n  return hasTouches;\n}\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\n\n\nfunction filterPrimaryPointer(eventHandler) {\n  return function (event) {\n    var isMouseEvent = event instanceof MouseEvent;\n    var isPrimaryPointer = !isMouseEvent || isMouseEvent && event.button === 0;\n\n    if (isPrimaryPointer) {\n      eventHandler(event);\n    }\n  };\n}\n\nvar defaultPagePoint = {\n  pageX: 0,\n  pageY: 0\n};\n\nfunction pointFromTouch(e, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  var primaryTouch = e.touches[0] || e.changedTouches[0];\n  var point = primaryTouch || defaultPagePoint;\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\n\nfunction pointFromMouse(point, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\n\nfunction extractEventInfo(event, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n\n  return {\n    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)\n  };\n}\n\nfunction getViewportPointFromEvent(event) {\n  return extractEventInfo(event, \"client\");\n}\n\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\n  if (shouldFilterPrimaryPointer === void 0) {\n    shouldFilterPrimaryPointer = false;\n  }\n\n  var listener = function (event) {\n    return handler(event, extractEventInfo(event));\n  };\n\n  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;\n}; // We check for event support via functions in case they've been mocked by a testing suite.\n\n\nvar supportsPointerEvents = function () {\n  return isBrowser && window.onpointerdown === null;\n};\n\nvar supportsTouchEvents = function () {\n  return isBrowser && window.ontouchstart === null;\n};\n\nvar supportsMouseEvents = function () {\n  return isBrowser && window.onmousedown === null;\n};\n\nvar mouseEventNames = {\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointercancel: \"mousecancel\",\n  pointerover: \"mouseover\",\n  pointerout: \"mouseout\",\n  pointerenter: \"mouseenter\",\n  pointerleave: \"mouseleave\"\n};\nvar touchEventNames = {\n  pointerdown: \"touchstart\",\n  pointermove: \"touchmove\",\n  pointerup: \"touchend\",\n  pointercancel: \"touchcancel\"\n};\n\nfunction getPointerEventName(name) {\n  if (supportsPointerEvents()) {\n    return name;\n  } else if (supportsTouchEvents()) {\n    return touchEventNames[name];\n  } else if (supportsMouseEvents()) {\n    return mouseEventNames[name];\n  }\n\n  return name;\n}\n\nfunction addPointerEvent(target, eventName, handler, options) {\n  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\nfunction usePointerEvent(ref, eventName, handler, options) {\n  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\nfunction createLock(name) {\n  var lock = null;\n  return function () {\n    var openLock = function () {\n      lock = null;\n    };\n\n    if (lock === null) {\n      lock = name;\n      return openLock;\n    }\n\n    return false;\n  };\n}\n\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\n\nfunction getGlobalLock(drag) {\n  var lock = false;\n\n  if (drag === \"y\") {\n    lock = globalVerticalLock();\n  } else if (drag === \"x\") {\n    lock = globalHorizontalLock();\n  } else {\n    var openHorizontal_1 = globalHorizontalLock();\n    var openVertical_1 = globalVerticalLock();\n\n    if (openHorizontal_1 && openVertical_1) {\n      lock = function () {\n        openHorizontal_1();\n        openVertical_1();\n      };\n    } else {\n      // Release the locks because we don't use them\n      if (openHorizontal_1) openHorizontal_1();\n      if (openVertical_1) openVertical_1();\n    }\n  }\n\n  return lock;\n}\n\nfunction isDragActive() {\n  // Check the gesture lock - if we get it, it means no drag gesture is active\n  // and we can safely fire the tap gesture.\n  var openGestureLock = getGlobalLock(true);\n  if (!openGestureLock) return true;\n  openGestureLock();\n  return false;\n}\n\nfunction createHoverEvent(visualElement, isActive, callback) {\n  return function (event, info) {\n    var _a;\n\n    if (!isMouseEvent(event) || isDragActive()) return;\n    callback === null || callback === void 0 ? void 0 : callback(event, info);\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Hover, isActive);\n  };\n}\n\nfunction useHoverGesture(_a) {\n  var onHoverStart = _a.onHoverStart,\n      onHoverEnd = _a.onHoverEnd,\n      whileHover = _a.whileHover,\n      visualElement = _a.visualElement;\n  usePointerEvent(visualElement, \"pointerenter\", onHoverStart || whileHover ? createHoverEvent(visualElement, true, onHoverStart) : undefined);\n  usePointerEvent(visualElement, \"pointerleave\", onHoverEnd || whileHover ? createHoverEvent(visualElement, false, onHoverEnd) : undefined);\n}\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\n\n\nvar isNodeOrChild = function (parent, child) {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\n\nfunction useUnmountEffect(callback) {\n  return React.useEffect(function () {\n    return function () {\n      return callback();\n    };\n  }, []);\n}\n/**\n * @param handlers -\n * @internal\n */\n\n\nfunction useTapGesture(_a) {\n  var onTap = _a.onTap,\n      onTapStart = _a.onTapStart,\n      onTapCancel = _a.onTapCancel,\n      whileTap = _a.whileTap,\n      visualElement = _a.visualElement;\n  var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n  var isPressing = React.useRef(false);\n  var cancelPointerEndListeners = React.useRef(null);\n\n  function removePointerEndListener() {\n    var _a;\n\n    (_a = cancelPointerEndListeners.current) === null || _a === void 0 ? void 0 : _a.call(cancelPointerEndListeners);\n    cancelPointerEndListeners.current = null;\n  }\n\n  function checkPointerEnd() {\n    var _a;\n\n    removePointerEndListener();\n    isPressing.current = false;\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, false);\n    return !isDragActive();\n  }\n\n  function onPointerUp(event, info) {\n    if (!checkPointerEnd()) return;\n    /**\n     * We only count this as a tap gesture if the event.target is the same\n     * as, or a child of, this component's element\n     */\n\n    !isNodeOrChild(visualElement.getInstance(), event.target) ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info) : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);\n  }\n\n  function onPointerCancel(event, info) {\n    if (!checkPointerEnd()) return;\n    onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);\n  }\n\n  function onPointerDown(event, info) {\n    var _a;\n\n    removePointerEndListener();\n    if (isPressing.current) return;\n    isPressing.current = true;\n    cancelPointerEndListeners.current = popmotion.pipe(addPointerEvent(window, \"pointerup\", onPointerUp), addPointerEvent(window, \"pointercancel\", onPointerCancel));\n    onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, true);\n  }\n\n  usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : undefined);\n  useUnmountEffect(removePointerEndListener);\n}\n\nvar makeRenderlessComponent = function (hook) {\n  return function (props) {\n    hook(props);\n    return null;\n  };\n};\n\nvar gestureAnimations = {\n  tap: makeRenderlessComponent(useTapGesture),\n  focus: makeRenderlessComponent(useFocusGesture),\n  hover: makeRenderlessComponent(useHoverGesture)\n};\n\nfunction shallowCompare(next, prev) {\n  if (!Array.isArray(prev)) return false;\n  var prevLength = prev.length;\n  if (prevLength !== next.length) return false;\n\n  for (var i = 0; i < prevLength; i++) {\n    if (prev[i] !== next[i]) return false;\n  }\n\n  return true;\n}\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n\n\nvar secondsToMilliseconds = function (seconds) {\n  return seconds * 1000;\n};\n\nvar easingLookup = {\n  linear: popmotion.linear,\n  easeIn: popmotion.easeIn,\n  easeInOut: popmotion.easeInOut,\n  easeOut: popmotion.easeOut,\n  circIn: popmotion.circIn,\n  circInOut: popmotion.circInOut,\n  circOut: popmotion.circOut,\n  backIn: popmotion.backIn,\n  backInOut: popmotion.backInOut,\n  backOut: popmotion.backOut,\n  anticipate: popmotion.anticipate,\n  bounceIn: popmotion.bounceIn,\n  bounceInOut: popmotion.bounceInOut,\n  bounceOut: popmotion.bounceOut\n};\n\nvar easingDefinitionToFunction = function (definition) {\n  if (Array.isArray(definition)) {\n    // If cubic bezier definition, create bezier curve\n    heyListen.invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n\n    var _a = tslib.__read(definition, 4),\n        x1 = _a[0],\n        y1 = _a[1],\n        x2 = _a[2],\n        y2 = _a[3];\n\n    return popmotion.cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    // Else lookup from table\n    heyListen.invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\n    return easingLookup[definition];\n  }\n\n  return definition;\n};\n\nvar isEasingArray = function (ease) {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n/**\n * Check if a value is animatable. Examples:\n *\n * : 100, \"100px\", \"#fff\"\n * : \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\n\n\nvar isAnimatable = function (key, value) {\n  // If the list of keys tat might be non-animatable grows, replace with Set\n  if (key === \"zIndex\") return false; // If it's a number or a keyframes array, we can animate it. We might at some point\n  // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n  // but for now lets leave it like this for performance reasons\n\n  if (typeof value === \"number\" || Array.isArray(value)) return true;\n\n  if (typeof value === \"string\" && // It's animatable if we have a string\n  styleValueTypes.complex.test(value) && // And it contains numbers and/or colors\n  !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nvar underDampedSpring = function () {\n  return {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10\n  };\n};\n\nvar criticallyDampedSpring = function (to) {\n  return {\n    type: \"spring\",\n    stiffness: 550,\n    damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n    restDelta: 0.01,\n    restSpeed: 10\n  };\n};\n\nvar linearTween = function () {\n  return {\n    type: \"keyframes\",\n    ease: \"linear\",\n    duration: 0.3\n  };\n};\n\nvar keyframes = function (values) {\n  return {\n    type: \"keyframes\",\n    duration: 0.8,\n    values: values\n  };\n};\n\nvar defaultTransitions = {\n  x: underDampedSpring,\n  y: underDampedSpring,\n  z: underDampedSpring,\n  rotate: underDampedSpring,\n  rotateX: underDampedSpring,\n  rotateY: underDampedSpring,\n  rotateZ: underDampedSpring,\n  scaleX: criticallyDampedSpring,\n  scaleY: criticallyDampedSpring,\n  scale: criticallyDampedSpring,\n  opacity: linearTween,\n  backgroundColor: linearTween,\n  color: linearTween,\n  default: criticallyDampedSpring\n};\n\nvar getDefaultTransition = function (valueKey, to) {\n  var transitionFactory;\n\n  if (isKeyframesTarget(to)) {\n    transitionFactory = keyframes;\n  } else {\n    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;\n  }\n\n  return tslib.__assign({\n    to: to\n  }, transitionFactory(to));\n};\n/**\n * A map of default value types for common values\n */\n\n\nvar defaultValueTypes = tslib.__assign(tslib.__assign({}, numberValueTypes), {\n  // Color props\n  color: styleValueTypes.color,\n  backgroundColor: styleValueTypes.color,\n  outlineColor: styleValueTypes.color,\n  fill: styleValueTypes.color,\n  stroke: styleValueTypes.color,\n  // Border props\n  borderColor: styleValueTypes.color,\n  borderTopColor: styleValueTypes.color,\n  borderRightColor: styleValueTypes.color,\n  borderBottomColor: styleValueTypes.color,\n  borderLeftColor: styleValueTypes.color,\n  filter: styleValueTypes.filter,\n  WebkitFilter: styleValueTypes.filter\n});\n/**\n * Gets the default ValueType for the provided value key\n */\n\n\nvar getDefaultValueType = function (key) {\n  return defaultValueTypes[key];\n};\n\nfunction getAnimatableNone(key, value) {\n  var _a;\n\n  var defaultValueType = getDefaultValueType(key);\n  if (defaultValueType !== styleValueTypes.filter) defaultValueType = styleValueTypes.complex; // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n\n  return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\n\n\nfunction isTransitionDefined(_a) {\n  _a.when;\n  _a.delay;\n  _a.delayChildren;\n  _a.staggerChildren;\n  _a.staggerDirection;\n  _a.repeat;\n  _a.repeatType;\n  _a.repeatDelay;\n  _a.from;\n\n  var transition = tslib.__rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"]);\n\n  return !!Object.keys(transition).length;\n}\n\nvar legacyRepeatWarning = false;\n/**\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\n */\n\nfunction convertTransitionToAnimationOptions(_a) {\n  var ease = _a.ease,\n      times = _a.times,\n      yoyo = _a.yoyo,\n      flip = _a.flip,\n      loop = _a.loop,\n      transition = tslib.__rest(_a, [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"]);\n\n  var options = tslib.__assign({}, transition);\n\n  if (times) options[\"offset\"] = times;\n  /**\n   * Convert any existing durations from seconds to milliseconds\n   */\n\n  if (transition.duration) options[\"duration\"] = secondsToMilliseconds(transition.duration);\n  if (transition.repeatDelay) options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n  /**\n   * Map easing names to Popmotion's easing functions\n   */\n\n  if (ease) {\n    options[\"ease\"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n  }\n  /**\n   * Support legacy transition API\n   */\n\n\n  if (transition.type === \"tween\") options.type = \"keyframes\";\n  /**\n   * TODO: These options are officially removed from the API.\n   */\n\n  if (yoyo || loop || flip) {\n    heyListen.warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n    legacyRepeatWarning = true;\n\n    if (yoyo) {\n      options.repeatType = \"reverse\";\n    } else if (loop) {\n      options.repeatType = \"loop\";\n    } else if (flip) {\n      options.repeatType = \"mirror\";\n    }\n\n    options.repeat = loop || yoyo || flip || transition.repeat;\n  }\n  /**\n   * TODO: Popmotion 9 has the ability to automatically detect whether to use\n   * a keyframes or spring animation, but does so by detecting velocity and other spring options.\n   * It'd be good to introduce a similar thing here.\n   */\n\n\n  if (transition.type !== \"spring\") options.type = \"keyframes\";\n  return options;\n}\n/**\n * Get the delay for a value by checking Transition with decreasing specificity.\n */\n\n\nfunction getDelayFromTransition(transition, key) {\n  var _a;\n\n  var valueTransition = getValueTransition(transition, key) || {};\n  return (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : 0;\n}\n\nfunction hydrateKeyframes(options) {\n  if (Array.isArray(options.to) && options.to[0] === null) {\n    options.to = tslib.__spreadArray([], tslib.__read(options.to));\n    options.to[0] = options.from;\n  }\n\n  return options;\n}\n\nfunction getPopmotionAnimationOptions(transition, options, key) {\n  var _a;\n\n  if (Array.isArray(options.to)) {\n    (_a = transition.duration) !== null && _a !== void 0 ? _a : transition.duration = 0.8;\n  }\n\n  hydrateKeyframes(options);\n  /**\n   * Get a default transition if none is determined to be defined.\n   */\n\n  if (!isTransitionDefined(transition)) {\n    transition = tslib.__assign(tslib.__assign({}, transition), getDefaultTransition(key, options.to));\n  }\n\n  return tslib.__assign(tslib.__assign({}, options), convertTransitionToAnimationOptions(transition));\n}\n/**\n *\n */\n\n\nfunction getAnimation(key, value, target, transition, onComplete) {\n  var _a;\n\n  var valueTransition = getValueTransition(transition, key);\n  var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();\n  var isTargetAnimatable = isAnimatable(key, target);\n\n  if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n    /**\n     * If we're trying to animate from \"none\", try and get an animatable version\n     * of the target. This could be improved to work both ways.\n     */\n    origin = getAnimatableNone(key, target);\n  } else if (isZero(origin) && typeof target === \"string\") {\n    origin = getZeroUnit(target);\n  } else if (!Array.isArray(target) && isZero(target) && typeof origin === \"string\") {\n    target = getZeroUnit(origin);\n  }\n\n  var isOriginAnimatable = isAnimatable(key, origin);\n  heyListen.warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\");\n\n  function start() {\n    var options = {\n      from: origin,\n      to: target,\n      velocity: value.getVelocity(),\n      onComplete: onComplete,\n      onUpdate: function (v) {\n        return value.set(v);\n      }\n    };\n    return valueTransition.type === \"inertia\" || valueTransition.type === \"decay\" ? popmotion.inertia(tslib.__assign(tslib.__assign({}, options), valueTransition)) : popmotion.animate(tslib.__assign(tslib.__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), {\n      onUpdate: function (v) {\n        var _a;\n\n        options.onUpdate(v);\n        (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);\n      },\n      onComplete: function () {\n        var _a;\n\n        options.onComplete();\n        (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n      }\n    }));\n  }\n\n  function set() {\n    var _a;\n\n    value.set(target);\n    onComplete();\n    (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n    return {\n      stop: function () {}\n    };\n  }\n\n  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;\n}\n\nfunction isZero(value) {\n  return value === 0 || typeof value === \"string\" && parseFloat(value) === 0 && value.indexOf(\" \") === -1;\n}\n\nfunction getZeroUnit(potentialUnitType) {\n  return typeof potentialUnitType === \"number\" ? 0 : getAnimatableNone(\"\", potentialUnitType);\n}\n\nfunction getValueTransition(transition, key) {\n  return transition[key] || transition[\"default\"] || transition;\n}\n/**\n * Start animation on a MotionValue. This function is an interface between\n * Framer Motion and Popmotion\n *\n * @internal\n */\n\n\nfunction startAnimation(key, value, target, transition) {\n  if (transition === void 0) {\n    transition = {};\n  }\n\n  return value.start(function (onComplete) {\n    var delayTimer;\n    var controls;\n    var animation = getAnimation(key, value, target, transition, onComplete);\n    var delay = getDelayFromTransition(transition, key);\n\n    var start = function () {\n      return controls = animation();\n    };\n\n    if (delay) {\n      delayTimer = setTimeout(start, secondsToMilliseconds(delay));\n    } else {\n      start();\n    }\n\n    return function () {\n      clearTimeout(delayTimer);\n      controls === null || controls === void 0 ? void 0 : controls.stop();\n    };\n  });\n}\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\n\n\nvar isNumericalString = function (v) {\n  return /^\\-?\\d*\\.?\\d+$/.test(v);\n};\n\nfunction addUniqueItem(arr, item) {\n  arr.indexOf(item) === -1 && arr.push(item);\n}\n\nfunction removeItem(arr, item) {\n  var index = arr.indexOf(item);\n  index > -1 && arr.splice(index, 1);\n}\n\nvar SubscriptionManager =\n/** @class */\nfunction () {\n  function SubscriptionManager() {\n    this.subscriptions = [];\n  }\n\n  SubscriptionManager.prototype.add = function (handler) {\n    var _this = this;\n\n    addUniqueItem(this.subscriptions, handler);\n    return function () {\n      return removeItem(_this.subscriptions, handler);\n    };\n  };\n\n  SubscriptionManager.prototype.notify = function (a, b, c) {\n    var numSubscriptions = this.subscriptions.length;\n    if (!numSubscriptions) return;\n\n    if (numSubscriptions === 1) {\n      /**\n       * If there's only a single handler we can just call it without invoking a loop.\n       */\n      this.subscriptions[0](a, b, c);\n    } else {\n      for (var i = 0; i < numSubscriptions; i++) {\n        /**\n         * Check whether the handler exists before firing as it's possible\n         * the subscriptions were modified during this loop running.\n         */\n        var handler = this.subscriptions[i];\n        handler && handler(a, b, c);\n      }\n    }\n  };\n\n  SubscriptionManager.prototype.getSize = function () {\n    return this.subscriptions.length;\n  };\n\n  SubscriptionManager.prototype.clear = function () {\n    this.subscriptions.length = 0;\n  };\n\n  return SubscriptionManager;\n}();\n\nvar isFloat = function (value) {\n  return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\n\n\nvar MotionValue =\n/** @class */\nfunction () {\n  /**\n   * @param init - The initiating value\n   * @param config - Optional configuration options\n   *\n   * -  `transformer`: A function to transform incoming values with.\n   *\n   * @internal\n   */\n  function MotionValue(init) {\n    var _this = this;\n    /**\n     * Duration, in milliseconds, since last updating frame.\n     *\n     * @internal\n     */\n\n\n    this.timeDelta = 0;\n    /**\n     * Timestamp of the last time this `MotionValue` was updated.\n     *\n     * @internal\n     */\n\n    this.lastUpdated = 0;\n    /**\n     * Functions to notify when the `MotionValue` updates.\n     *\n     * @internal\n     */\n\n    this.updateSubscribers = new SubscriptionManager();\n    /**\n     * Functions to notify when the velocity updates.\n     *\n     * @internal\n     */\n\n    this.velocityUpdateSubscribers = new SubscriptionManager();\n    /**\n     * Functions to notify when the `MotionValue` updates and `render` is set to `true`.\n     *\n     * @internal\n     */\n\n    this.renderSubscribers = new SubscriptionManager();\n    /**\n     * Tracks whether this value can output a velocity. Currently this is only true\n     * if the value is numerical, but we might be able to widen the scope here and support\n     * other value types.\n     *\n     * @internal\n     */\n\n    this.canTrackVelocity = false;\n\n    this.updateAndNotify = function (v, render) {\n      if (render === void 0) {\n        render = true;\n      }\n\n      _this.prev = _this.current;\n      _this.current = v; // Update timestamp\n\n      var _a = sync.getFrameData(),\n          delta = _a.delta,\n          timestamp = _a.timestamp;\n\n      if (_this.lastUpdated !== timestamp) {\n        _this.timeDelta = delta;\n        _this.lastUpdated = timestamp;\n        sync__default['default'].postRender(_this.scheduleVelocityCheck);\n      } // Update update subscribers\n\n\n      if (_this.prev !== _this.current) {\n        _this.updateSubscribers.notify(_this.current);\n      } // Update velocity subscribers\n\n\n      if (_this.velocityUpdateSubscribers.getSize()) {\n        _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n      } // Update render subscribers\n\n\n      if (render) {\n        _this.renderSubscribers.notify(_this.current);\n      }\n    };\n    /**\n     * Schedule a velocity check for the next frame.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n\n\n    this.scheduleVelocityCheck = function () {\n      return sync__default['default'].postRender(_this.velocityCheck);\n    };\n    /**\n     * Updates `prev` with `current` if the value hasn't been updated this frame.\n     * This ensures velocity calculations return `0`.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n\n\n    this.velocityCheck = function (_a) {\n      var timestamp = _a.timestamp;\n\n      if (timestamp !== _this.lastUpdated) {\n        _this.prev = _this.current;\n\n        _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n      }\n    };\n\n    this.hasAnimated = false;\n    this.prev = this.current = init;\n    this.canTrackVelocity = isFloat(this.current);\n  }\n  /**\n   * Adds a function that will be notified when the `MotionValue` is updated.\n   *\n   * It returns a function that, when called, will cancel the subscription.\n   *\n   * When calling `onChange` inside a React component, it should be wrapped with the\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\n   *\n   * @library\n   *\n   * ```jsx\n   * function MyComponent() {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.onChange(updateOpacity)\n   *     const unsubscribeY = y.onChange(updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <Frame x={x} />\n   * }\n   * ```\n   *\n   * @motion\n   *\n   * ```jsx\n   * export const MyComponent = () => {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.onChange(updateOpacity)\n   *     const unsubscribeY = y.onChange(updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <motion.div style={{ x }} />\n   * }\n   * ```\n   *\n   * @internalremarks\n   *\n   * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n   *\n   * ```jsx\n   * useOnChange(x, () => {})\n   * ```\n   *\n   * @param subscriber - A function that receives the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.onChange = function (subscription) {\n    return this.updateSubscribers.add(subscription);\n  };\n\n  MotionValue.prototype.clearListeners = function () {\n    this.updateSubscribers.clear();\n  };\n  /**\n   * Adds a function that will be notified when the `MotionValue` requests a render.\n   *\n   * @param subscriber - A function that's provided the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.onRenderRequest = function (subscription) {\n    // Render immediately\n    subscription(this.get());\n    return this.renderSubscribers.add(subscription);\n  };\n  /**\n   * Attaches a passive effect to the `MotionValue`.\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.attach = function (passiveEffect) {\n    this.passiveEffect = passiveEffect;\n  };\n  /**\n   * Sets the state of the `MotionValue`.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * const x = useMotionValue(0)\n   * x.set(10)\n   * ```\n   *\n   * @param latest - Latest value to set.\n   * @param render - Whether to notify render subscribers. Defaults to `true`\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.set = function (v, render) {\n    if (render === void 0) {\n      render = true;\n    }\n\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  };\n  /**\n   * Returns the latest state of `MotionValue`\n   *\n   * @returns - The latest state of `MotionValue`\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.get = function () {\n    return this.current;\n  };\n  /**\n   * @public\n   */\n\n\n  MotionValue.prototype.getPrevious = function () {\n    return this.prev;\n  };\n  /**\n   * Returns the latest velocity of `MotionValue`\n   *\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.getVelocity = function () {\n    // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n    return this.canTrackVelocity ? // These casts could be avoided if parseFloat would be typed better\n    popmotion.velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n  };\n  /**\n   * Registers a new animation to control this `MotionValue`. Only one\n   * animation can drive a `MotionValue` at one time.\n   *\n   * ```jsx\n   * value.start()\n   * ```\n   *\n   * @param animation - A function that starts the provided animation\n   *\n   * @internal\n   */\n\n\n  MotionValue.prototype.start = function (animation) {\n    var _this = this;\n\n    this.stop();\n    return new Promise(function (resolve) {\n      _this.hasAnimated = true;\n      _this.stopAnimation = animation(resolve);\n    }).then(function () {\n      return _this.clearAnimation();\n    });\n  };\n  /**\n   * Stop the currently active animation.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.stop = function () {\n    if (this.stopAnimation) this.stopAnimation();\n    this.clearAnimation();\n  };\n  /**\n   * Returns `true` if this value is currently animating.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.isAnimating = function () {\n    return !!this.stopAnimation;\n  };\n\n  MotionValue.prototype.clearAnimation = function () {\n    this.stopAnimation = null;\n  };\n  /**\n   * Destroy and clean up subscribers to this `MotionValue`.\n   *\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n   * created a `MotionValue` via the `motionValue` function.\n   *\n   * @public\n   */\n\n\n  MotionValue.prototype.destroy = function () {\n    this.updateSubscribers.clear();\n    this.renderSubscribers.clear();\n    this.stop();\n  };\n\n  return MotionValue;\n}();\n/**\n * @internal\n */\n\n\nfunction motionValue(init) {\n  return new MotionValue(init);\n}\n/**\n * Tests a provided value against a ValueType\n */\n\n\nvar testValueType = function (v) {\n  return function (type) {\n    return type.test(v);\n  };\n};\n/**\n * ValueType for \"auto\"\n */\n\n\nvar auto = {\n  test: function (v) {\n    return v === \"auto\";\n  },\n  parse: function (v) {\n    return v;\n  }\n};\n/**\n * A list of value types commonly used for dimensions\n */\n\nvar dimensionValueTypes = [styleValueTypes.number, styleValueTypes.px, styleValueTypes.percent, styleValueTypes.degrees, styleValueTypes.vw, styleValueTypes.vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\n\nvar findDimensionValueType = function (v) {\n  return dimensionValueTypes.find(testValueType(v));\n};\n/**\n * A list of all ValueTypes\n */\n\n\nvar valueTypes = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(dimensionValueTypes)), [styleValueTypes.color, styleValueTypes.complex]);\n/**\n * Tests a value against the list of ValueTypes\n */\n\n\nvar findValueType = function (v) {\n  return valueTypes.find(testValueType(v));\n};\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\n\n\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, motionValue(value));\n  }\n}\n\nfunction setTarget(visualElement, definition) {\n  var resolved = resolveVariant(visualElement, definition);\n\n  var _a = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {},\n      _b = _a.transitionEnd,\n      transitionEnd = _b === void 0 ? {} : _b;\n\n  _a.transition;\n\n  var target = tslib.__rest(_a, [\"transitionEnd\", \"transition\"]);\n\n  target = tslib.__assign(tslib.__assign({}, target), transitionEnd);\n\n  for (var key in target) {\n    var value = resolveFinalValueInKeyframes(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\n\nfunction setVariants(visualElement, variantLabels) {\n  var reversedLabels = tslib.__spreadArray([], tslib.__read(variantLabels)).reverse();\n\n  reversedLabels.forEach(function (key) {\n    var _a;\n\n    var variant = visualElement.getVariant(key);\n    variant && setTarget(visualElement, variant);\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      setVariants(child, variantLabels);\n    });\n  });\n}\n\nfunction setValues(visualElement, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement, [definition]);\n  } else {\n    setTarget(visualElement, definition);\n  }\n}\n\nfunction checkTargetForNewValues(visualElement, target, origin) {\n  var _a, _b, _c;\n\n  var _d;\n\n  var newValueKeys = Object.keys(target).filter(function (key) {\n    return !visualElement.hasValue(key);\n  });\n  var numNewValues = newValueKeys.length;\n  if (!numNewValues) return;\n\n  for (var i = 0; i < numNewValues; i++) {\n    var key = newValueKeys[i];\n    var targetValue = target[key];\n    var value = null;\n    /**\n     * If the target is a series of keyframes, we can use the first value\n     * in the array. If this first value is null, we'll still need to read from the DOM.\n     */\n\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    /**\n     * If the target isn't keyframes, or the first keyframe was null, we need to\n     * first check if an origin value was explicitly defined in the transition as \"from\",\n     * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n     */\n\n\n    if (value === null) {\n      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n    }\n    /**\n     * If value is still undefined or null, ignore it. Preferably this would throw,\n     * but this was causing issues in Framer.\n     */\n\n\n    if (value === undefined || value === null) continue;\n\n    if (typeof value === \"string\" && isNumericalString(value)) {\n      // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n      value = parseFloat(value);\n    } else if (!findValueType(value) && styleValueTypes.complex.test(targetValue)) {\n      value = getAnimatableNone(key, targetValue);\n    }\n\n    visualElement.addValue(key, motionValue(value));\n    (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : _d[key] = value;\n    visualElement.setBaseTarget(key, value);\n  }\n}\n\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  var valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\n\nfunction getOrigin(target, transition, visualElement) {\n  var _a, _b;\n\n  var origin = {};\n\n  for (var key in target) {\n    origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n  }\n\n  return origin;\n}\n/**\n * @internal\n */\n\n\nfunction animateVisualElement(visualElement, definition, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  visualElement.notifyAnimationStart();\n  var animation;\n\n  if (Array.isArray(definition)) {\n    var animations = definition.map(function (variant) {\n      return animateVariant(visualElement, variant, options);\n    });\n    animation = Promise.all(animations);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    var resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = animateTarget(visualElement, resolvedDefinition, options);\n  }\n\n  return animation.then(function () {\n    return visualElement.notifyAnimationComplete(definition);\n  });\n}\n\nfunction animateVariant(visualElement, variant, options) {\n  var _a;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var resolved = resolveVariant(visualElement, variant, options.custom);\n  var _b = (resolved || {}).transition,\n      transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;\n\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\n   * If we have a variant, create a callback that runs it as an animation.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n\n\n  var getAnimation = resolved ? function () {\n    return animateTarget(visualElement, resolved, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If we have children, create a callback that runs all their animations.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n\n  var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function (forwardDelay) {\n    if (forwardDelay === void 0) {\n      forwardDelay = 0;\n    }\n\n    var _a = transition.delayChildren,\n        delayChildren = _a === void 0 ? 0 : _a,\n        staggerChildren = transition.staggerChildren,\n        staggerDirection = transition.staggerDirection;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\n   * this animation or all children animations before playing the other.\n   */\n\n  var when = transition.when;\n\n  if (when) {\n    var _c = tslib.__read(when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation], 2),\n        first = _c[0],\n        last = _c[1];\n\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\n/**\n * @internal\n */\n\n\nfunction animateTarget(visualElement, definition, _a) {\n  var _b;\n\n  var _c = _a === void 0 ? {} : _a,\n      _d = _c.delay,\n      delay = _d === void 0 ? 0 : _d,\n      transitionOverride = _c.transitionOverride,\n      type = _c.type;\n\n  var _e = visualElement.makeTargetAnimatable(definition),\n      _f = _e.transition,\n      transition = _f === void 0 ? visualElement.getDefaultTransition() : _f,\n      transitionEnd = _e.transitionEnd,\n      target = tslib.__rest(_e, [\"transition\", \"transitionEnd\"]);\n\n  if (transitionOverride) transition = transitionOverride;\n  var animations = [];\n  var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\n\n  for (var key in target) {\n    var value = visualElement.getValue(key);\n    var valueTarget = target[key];\n\n    if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      continue;\n    }\n\n    var animation = startAnimation(key, value, valueTarget, tslib.__assign({\n      delay: delay\n    }, transition));\n    animations.push(animation);\n  }\n\n  return Promise.all(animations).then(function () {\n    transitionEnd && setTarget(visualElement, transitionEnd);\n  });\n}\n\nfunction animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {\n  if (delayChildren === void 0) {\n    delayChildren = 0;\n  }\n\n  if (staggerChildren === void 0) {\n    staggerChildren = 0;\n  }\n\n  if (staggerDirection === void 0) {\n    staggerDirection = 1;\n  }\n\n  var animations = [];\n  var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  var generateStaggerDuration = staggerDirection === 1 ? function (i) {\n    if (i === void 0) {\n      i = 0;\n    }\n\n    return i * staggerChildren;\n  } : function (i) {\n    if (i === void 0) {\n      i = 0;\n    }\n\n    return maxStaggerDuration - i * staggerChildren;\n  };\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(function (child, i) {\n    animations.push(animateVariant(child, variant, tslib.__assign(tslib.__assign({}, options), {\n      delay: delayChildren + generateStaggerDuration(i)\n    })).then(function () {\n      return child.notifyAnimationComplete(variant);\n    }));\n  });\n  return Promise.all(animations);\n}\n\nfunction stopAnimation(visualElement) {\n  visualElement.forEachValue(function (value) {\n    return value.stop();\n  });\n}\n\nfunction sortByTreeOrder(a, b) {\n  return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\n\n\nfunction shouldBlockAnimation(_a, key) {\n  var protectedKeys = _a.protectedKeys,\n      needsAnimating = _a.needsAnimating;\n  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\n\nvar variantPriorityOrder = [AnimationType.Animate, AnimationType.Hover, AnimationType.Tap, AnimationType.Drag, AnimationType.Focus, AnimationType.Exit];\n\nvar reversePriorityOrder = tslib.__spreadArray([], tslib.__read(variantPriorityOrder)).reverse();\n\nvar numAnimationTypes = variantPriorityOrder.length;\n\nfunction animateList(visualElement) {\n  return function (animations) {\n    return Promise.all(animations.map(function (_a) {\n      var animation = _a.animation,\n          options = _a.options;\n      return animateVisualElement(visualElement, animation, options);\n    }));\n  };\n}\n\nfunction createAnimationState(visualElement) {\n  var animate = animateList(visualElement);\n  var state = createState();\n  var allAnimatedKeys = {};\n  var isInitialRender = true;\n  /**\n   * This function will be used to reduce the animation definitions for\n   * each active animation type into an object of resolved values for it.\n   */\n\n  var buildResolvedTypeValues = function (acc, definition) {\n    var resolved = resolveVariant(visualElement, definition);\n\n    if (resolved) {\n      resolved.transition;\n\n      var transitionEnd = resolved.transitionEnd,\n          target = tslib.__rest(resolved, [\"transition\", \"transitionEnd\"]);\n\n      acc = tslib.__assign(tslib.__assign(tslib.__assign({}, acc), target), transitionEnd);\n    }\n\n    return acc;\n  };\n\n  function isAnimated(key) {\n    return allAnimatedKeys[key] !== undefined;\n  }\n  /**\n   * This just allows us to inject mocked animation functions\n   * @internal\n   */\n\n\n  function setAnimateFunction(makeAnimator) {\n    animate = makeAnimator(visualElement);\n  }\n  /**\n   * When we receive new props, we need to:\n   * 1. Create a list of protected keys for each type. This is a directory of\n   *    value keys that are currently being \"handled\" by types of a higher priority\n   *    so that whenever an animation is played of a given type, these values are\n   *    protected from being animated.\n   * 2. Determine if an animation type needs animating.\n   * 3. Determine if any values have been removed from a type and figure out\n   *    what to animate those to.\n   */\n\n\n  function animateChanges(options, changedActiveType) {\n    var _a;\n\n    var props = visualElement.getProps();\n    var context = visualElement.getVariantContext(true) || {};\n    /**\n     * A list of animations that we'll build into as we iterate through the animation\n     * types. This will get executed at the end of the function.\n     */\n\n    var animations = [];\n    /**\n     * Keep track of which values have been removed. Then, as we hit lower priority\n     * animation types, we can check if they contain removed values and animate to that.\n     */\n\n    var removedKeys = new Set();\n    /**\n     * A dictionary of all encountered keys. This is an object to let us build into and\n     * copy it without iteration. Each time we hit an animation type we set its protected\n     * keys - the keys its not allowed to animate - to the latest version of this object.\n     */\n\n    var encounteredKeys = {};\n    /**\n     * If a variant has been removed at a given index, and this component is controlling\n     * variant animations, we want to ensure lower-priority variants are forced to animate.\n     */\n\n    var removedVariantIndex = Infinity;\n\n    var _loop_1 = function (i) {\n      var type = reversePriorityOrder[i];\n      var typeState = state[type];\n      var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n      var propIsVariant = isVariantLabel(prop);\n      /**\n       * If this type has *just* changed isActive status, set activeDelta\n       * to that status. Otherwise set to null.\n       */\n\n      var activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false) removedVariantIndex = i;\n      /**\n       * If this prop is an inherited variant, rather than been set directly on the\n       * component itself, we want to make sure we allow the parent to trigger animations.\n       *\n       * TODO: Can probably change this to a !isControllingVariants check\n       */\n\n      var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      /**\n       *\n       */\n\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      /**\n       * Set all encountered keys so far as the protected keys for this type. This will\n       * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n       */\n\n\n      typeState.protectedKeys = tslib.__assign({}, encounteredKeys); // Check if we can skip analysing this prop early\n\n      if ( // If it isn't active and hasn't *just* been set as inactive\n      !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type\n      !prop && !typeState.prevProp || // Or if the prop doesn't define an animation\n      isAnimationControls(prop) || typeof prop === \"boolean\") {\n        return \"continue\";\n      }\n      /**\n       * As we go look through the values defined on this type, if we detect\n       * a changed value or a value that was removed in a higher priority, we set\n       * this to true and add this prop to the animation list.\n       */\n\n\n      var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) || // If we're making this variant active, we want to always make it active\n      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)\n      i > removedVariantIndex && propIsVariant;\n      /**\n       * As animations can be set as variant lists, variants or target objects, we\n       * coerce everything to an array if it isn't one already\n       */\n\n      var definitionList = Array.isArray(prop) ? prop : [prop];\n      /**\n       * Build an object of all the resolved values. We'll use this in the subsequent\n       * animateChanges calls to determine whether a value has changed.\n       */\n\n      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n      if (activeDelta === false) resolvedValues = {};\n      /**\n       * Now we need to loop through all the keys in the prev prop and this prop,\n       * and decide:\n       * 1. If the value has changed, and needs animating\n       * 2. If it has been removed, and needs adding to the removedKeys set\n       * 3. If it has been removed in a higher priority type and needs animating\n       * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n       *    needs adding to the type's protectedKeys list.\n       */\n\n      var _b = typeState.prevResolvedValues,\n          prevResolvedValues = _b === void 0 ? {} : _b;\n\n      var allKeys = tslib.__assign(tslib.__assign({}, prevResolvedValues), resolvedValues);\n\n      var markToAnimate = function (key) {\n        shouldAnimateType = true;\n        removedKeys.delete(key);\n        typeState.needsAnimating[key] = true;\n      };\n\n      for (var key in allKeys) {\n        var next = resolvedValues[key];\n        var prev = prevResolvedValues[key]; // If we've already handled this we can just skip ahead\n\n        if (encounteredKeys.hasOwnProperty(key)) continue;\n        /**\n         * If the value has changed, we probably want to animate it.\n         */\n\n        if (next !== prev) {\n          /**\n           * If both values are keyframes, we need to shallow compare them to\n           * detect whether any value has changed. If it has, we animate it.\n           */\n          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n            if (!shallowCompare(next, prev)) {\n              markToAnimate(key);\n            } else {\n              /**\n               * If it hasn't changed, we want to ensure it doesn't animate by\n               * adding it to the list of protected keys.\n               */\n              typeState.protectedKeys[key] = true;\n            }\n          } else if (next !== undefined) {\n            // If next is defined and doesn't equal prev, it needs animating\n            markToAnimate(key);\n          } else {\n            // If it's undefined, it's been removed.\n            removedKeys.add(key);\n          }\n        } else if (next !== undefined && removedKeys.has(key)) {\n          /**\n           * If next hasn't changed and it isn't undefined, we want to check if it's\n           * been removed by a higher priority\n           */\n          markToAnimate(key);\n        } else {\n          /**\n           * If it hasn't changed, we add it to the list of protected values\n           * to ensure it doesn't get animated.\n           */\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      /**\n       * Update the typeState so next time animateChanges is called we can compare the\n       * latest prop and resolvedValues to these.\n       */\n\n\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      /**\n       *\n       */\n\n      if (typeState.isActive) {\n        encounteredKeys = tslib.__assign(tslib.__assign({}, encounteredKeys), resolvedValues);\n      }\n\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      /**\n       * If this is an inherited prop we want to hard-block animations\n       * TODO: Test as this should probably still handle animations triggered\n       * by removed values?\n       */\n\n\n      if (shouldAnimateType && !isInherited) {\n        animations.push.apply(animations, tslib.__spreadArray([], tslib.__read(definitionList.map(function (animation) {\n          return {\n            animation: animation,\n            options: tslib.__assign({\n              type: type\n            }, options)\n          };\n        }))));\n      }\n    };\n    /**\n     * Iterate through all animation types in reverse priority order. For each, we want to\n     * detect which values it's handling and whether or not they've changed (and therefore\n     * need to be animated). If any values have been removed, we want to detect those in\n     * lower priority props and flag for animation.\n     */\n\n\n    for (var i = 0; i < numAnimationTypes; i++) {\n      _loop_1(i);\n    }\n\n    allAnimatedKeys = tslib.__assign({}, encounteredKeys);\n    /**\n     * If there are some removed value that haven't been dealt with,\n     * we need to create a new animation that falls back either to the value\n     * defined in the style prop, or the last read value.\n     */\n\n    if (removedKeys.size) {\n      var fallbackAnimation_1 = {};\n      removedKeys.forEach(function (key) {\n        var fallbackTarget = visualElement.getBaseTarget(key);\n\n        if (fallbackTarget !== undefined) {\n          fallbackAnimation_1[key] = fallbackTarget;\n        }\n      });\n      animations.push({\n        animation: fallbackAnimation_1\n      });\n    }\n\n    var shouldAnimate = Boolean(animations.length);\n\n    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n\n    isInitialRender = false;\n    return shouldAnimate ? animate(animations) : Promise.resolve();\n  }\n  /**\n   * Change whether a certain animation type is active.\n   */\n\n\n  function setActive(type, isActive, options) {\n    var _a; // If the active state hasn't changed, we can safely do nothing here\n\n\n    if (state[type].isActive === isActive) return Promise.resolve(); // Propagate active change to children\n\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      var _a;\n\n      return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    return animateChanges(options, type);\n  }\n\n  return {\n    isAnimated: isAnimated,\n    animateChanges: animateChanges,\n    setActive: setActive,\n    setAnimateFunction: setAnimateFunction,\n    getState: function () {\n      return state;\n    }\n  };\n}\n\nfunction variantsHaveChanged(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (isVariantLabels(next)) {\n    return !shallowCompare(next, prev);\n  }\n\n  return false;\n}\n\nfunction createTypeState(isActive) {\n  if (isActive === void 0) {\n    isActive = false;\n  }\n\n  return {\n    isActive: isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\n\nfunction createState() {\n  var _a;\n\n  return _a = {}, _a[AnimationType.Animate] = createTypeState(true), _a[AnimationType.Hover] = createTypeState(), _a[AnimationType.Tap] = createTypeState(), _a[AnimationType.Drag] = createTypeState(), _a[AnimationType.Focus] = createTypeState(), _a[AnimationType.Exit] = createTypeState(), _a;\n}\n\nvar animations = {\n  animation: makeRenderlessComponent(function (_a) {\n    var visualElement = _a.visualElement,\n        animate = _a.animate;\n    /**\n     * We dynamically generate the AnimationState manager as it contains a reference\n     * to the underlying animation library. We only want to load that if we load this,\n     * so people can optionally code split it out using the `m` component.\n     */\n\n    visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n    /**\n     * Subscribe any provided AnimationControls to the component's VisualElement\n     */\n\n    if (isAnimationControls(animate)) {\n      React.useEffect(function () {\n        return animate.subscribe(visualElement);\n      }, [animate]);\n    }\n  }),\n  exit: makeRenderlessComponent(function (props) {\n    var custom = props.custom,\n        visualElement = props.visualElement;\n\n    var _a = tslib.__read(usePresence(), 2),\n        isPresent = _a[0],\n        onExitComplete = _a[1];\n\n    var presenceContext = React.useContext(PresenceContext);\n    React.useEffect(function () {\n      var _a, _b;\n\n      var animation = (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Exit, !isPresent, {\n        custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom\n      });\n      !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(onExitComplete));\n    }, [isPresent]);\n  })\n};\n/**\n * @internal\n */\n\nvar PanSession =\n/** @class */\nfunction () {\n  function PanSession(event, handlers, _a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        transformPagePoint = _b.transformPagePoint;\n    /**\n     * @internal\n     */\n\n\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n\n    this.handlers = {};\n\n    this.updatePoint = function () {\n      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;\n      var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null; // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursoe.\n\n      var isDistancePastThreshold = popmotion.distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      var point = info.point;\n      var timestamp = sync.getFrameData().timestamp;\n\n      _this.history.push(tslib.__assign(tslib.__assign({}, point), {\n        timestamp: timestamp\n      }));\n\n      var _a = _this.handlers,\n          onStart = _a.onStart,\n          onMove = _a.onMove;\n\n      if (!isPanStarted) {\n        onStart && onStart(_this.lastMoveEvent, info);\n        _this.startEvent = _this.lastMoveEvent;\n      }\n\n      onMove && onMove(_this.lastMoveEvent, info);\n    };\n\n    this.handlePointerMove = function (event, info) {\n      _this.lastMoveEvent = event;\n      _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint); // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n\n      if (isMouseEvent(event) && event.buttons === 0) {\n        _this.handlePointerUp(event, info);\n\n        return;\n      } // Throttle mouse move event to once per frame\n\n\n      sync__default['default'].update(_this.updatePoint, true);\n    };\n\n    this.handlePointerUp = function (event, info) {\n      _this.end();\n\n      var _a = _this.handlers,\n          onEnd = _a.onEnd,\n          onSessionEnd = _a.onSessionEnd;\n      var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n\n      if (_this.startEvent && onEnd) {\n        onEnd(event, panInfo);\n      }\n\n      onSessionEnd && onSessionEnd(event, panInfo);\n    }; // If we have more than one touch, don't start detecting this gesture\n\n\n    if (isTouchEvent(event) && event.touches.length > 1) return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    var info = extractEventInfo(event);\n    var initialInfo = transformPoint(info, this.transformPagePoint);\n    var point = initialInfo.point;\n    var timestamp = sync.getFrameData().timestamp;\n    this.history = [tslib.__assign(tslib.__assign({}, point), {\n      timestamp: timestamp\n    })];\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = popmotion.pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n  }\n\n  PanSession.prototype.updateHandlers = function (handlers) {\n    this.handlers = handlers;\n  };\n\n  PanSession.prototype.end = function () {\n    this.removeListeners && this.removeListeners();\n    sync.cancelSync.update(this.updatePoint);\n  };\n\n  return PanSession;\n}();\n\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\n\nfunction subtractPoint(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\n\nfunction getPanInfo(_a, history) {\n  var point = _a.point;\n  return {\n    point: point,\n    delta: subtractPoint(point, lastDevicePoint(history)),\n    offset: subtractPoint(point, startDevicePoint(history)),\n    velocity: getVelocity(history, 0.1)\n  };\n}\n\nfunction startDevicePoint(history) {\n  return history[0];\n}\n\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\n\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = lastDevicePoint(history);\n\n  while (i >= 0) {\n    timestampedPoint = history[i];\n\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n\n    i--;\n  }\n\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n\n  return currentVelocity;\n}\n\nfunction noop(any) {\n  return any;\n}\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\n\n\nfunction convertBoundingBoxToAxisBox(_a) {\n  var top = _a.top,\n      left = _a.left,\n      right = _a.right,\n      bottom = _a.bottom;\n  return {\n    x: {\n      min: left,\n      max: right\n    },\n    y: {\n      min: top,\n      max: bottom\n    }\n  };\n}\n\nfunction convertAxisBoxToBoundingBox(_a) {\n  var x = _a.x,\n      y = _a.y;\n  return {\n    top: y.min,\n    bottom: y.max,\n    left: x.min,\n    right: x.max\n  };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\n\n\nfunction transformBoundingBox(_a, transformPoint) {\n  var top = _a.top,\n      left = _a.left,\n      bottom = _a.bottom,\n      right = _a.right;\n\n  if (transformPoint === void 0) {\n    transformPoint = noop;\n  }\n\n  var topLeft = transformPoint({\n    x: left,\n    y: top\n  });\n  var bottomRight = transformPoint({\n    x: right,\n    y: bottom\n  });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\n/**\n * Create an empty axis box of zero size\n */\n\n\nfunction axisBox() {\n  return {\n    x: {\n      min: 0,\n      max: 1\n    },\n    y: {\n      min: 0,\n      max: 1\n    }\n  };\n}\n\nfunction copyAxisBox(box) {\n  return {\n    x: tslib.__assign({}, box.x),\n    y: tslib.__assign({}, box.y)\n  };\n}\n/**\n * Create an empty box delta\n */\n\n\nvar zeroDelta = {\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n};\n\nfunction delta() {\n  return {\n    x: tslib.__assign({}, zeroDelta),\n    y: tslib.__assign({}, zeroDelta)\n  };\n} // Call a handler once for each axis\n\n\nfunction eachAxis(handler) {\n  return [handler(\"x\"), handler(\"y\")];\n}\n\nvar clampProgress = function (v) {\n  return popmotion.clamp(0, 1, v);\n};\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\n\n\nfunction isNear(value, target, maxDistance) {\n  if (target === void 0) {\n    target = 0;\n  }\n\n  if (maxDistance === void 0) {\n    maxDistance = 0.01;\n  }\n\n  return popmotion.distance(value, target) < maxDistance;\n}\n\nfunction calcLength(axis) {\n  return axis.max - axis.min;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\n\n\nfunction calcOrigin(source, target) {\n  var origin = 0.5;\n  var sourceLength = calcLength(source);\n  var targetLength = calcLength(target);\n\n  if (targetLength > sourceLength) {\n    origin = popmotion.progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = popmotion.progress(source.min, source.max - targetLength, target.min);\n  }\n\n  return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\n\n\nfunction updateAxisDelta(delta, source, target, origin) {\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n\n  delta.origin = origin;\n  delta.originPoint = popmotion.mix(source.min, source.max, delta.origin);\n  delta.scale = calcLength(target) / calcLength(source);\n  if (isNear(delta.scale, 1, 0.0001)) delta.scale = 1;\n  delta.translate = popmotion.mix(target.min, target.max, delta.origin) - delta.originPoint;\n  if (isNear(delta.translate)) delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\n\n\nfunction updateBoxDelta(delta, source, target, origin) {\n  updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\n  updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\n}\n/**\n * Currently this only accepts numerical origins, measured as 0-1, but could\n * accept pixel values by comparing to the target axis.\n */\n\n\nfunction defaultOrigin(origin) {\n  return typeof origin === \"number\" ? origin : 0.5;\n}\n\nfunction calcRelativeAxis(target, relative, parent) {\n  target.min = parent.min + relative.min;\n  target.max = target.min + calcLength(relative);\n}\n\nfunction calcRelativeBox(projection, parentProjection) {\n  calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\n  calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\n}\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\n\n\nfunction applyConstraints(point, _a, elastic) {\n  var min = _a.min,\n      max = _a.max;\n\n  if (min !== undefined && point < min) {\n    // If we have a min point defined, and this is outside of that, constrain\n    point = elastic ? popmotion.mix(min, point, elastic.min) : Math.max(point, min);\n  } else if (max !== undefined && point > max) {\n    // If we have a max point defined, and this is outside of that, constrain\n    point = elastic ? popmotion.mix(max, point, elastic.max) : Math.min(point, max);\n  }\n\n  return point;\n}\n/**\n * Calculates a min projection point based on a pointer, pointer progress\n * within the drag target, and constraints.\n *\n * For instance if an element was 100px width, we were dragging from 0.25\n * along this axis, the pointer is at 200px, and there were no constraints,\n * we would calculate a min projection point of 175px.\n */\n\n\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\n  // Calculate a min point for this axis and apply it to the current pointer\n  var min = point - length * progress;\n  return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\n\n\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  return {\n    min: min !== undefined ? axis.min + min : undefined,\n    max: max !== undefined ? axis.max + max - (axis.max - axis.min) : undefined\n  };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\n\n\nfunction calcRelativeConstraints(layoutBox, _a) {\n  var top = _a.top,\n      left = _a.left,\n      bottom = _a.bottom,\n      right = _a.right;\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\n\n\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  var _a;\n\n  var min = constraintsAxis.min - layoutAxis.min;\n  var max = constraintsAxis.max - layoutAxis.max; // If the constraints axis is actually smaller than the layout axis then we can\n  // flip the constraints\n\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    _a = tslib.__read([max, min], 2), min = _a[0], max = _a[1];\n  }\n\n  return {\n    min: layoutAxis.min + min,\n    max: layoutAxis.min + max\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\n\n\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\n/**\n * Calculate the an axis position based on two axes and a progress value.\n */\n\n\nfunction calcPositionFromProgress(axis, constraints, progress) {\n  var axisLength = axis.max - axis.min;\n  var min = popmotion.mix(constraints.min, constraints.max - axisLength, progress);\n  return {\n    min: min,\n    max: min + axisLength\n  };\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\n\n\nfunction rebaseAxisConstraints(layout, constraints) {\n  var relativeConstraints = {};\n\n  if (constraints.min !== undefined) {\n    relativeConstraints.min = constraints.min - layout.min;\n  }\n\n  if (constraints.max !== undefined) {\n    relativeConstraints.max = constraints.max - layout.min;\n  }\n\n  return relativeConstraints;\n}\n\nvar defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\n\nfunction resolveDragElastic(dragElastic) {\n  if (dragElastic === false) {\n    dragElastic = 0;\n  } else if (dragElastic === true) {\n    dragElastic = defaultElastic;\n  }\n\n  return {\n    x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n    y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n  };\n}\n\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n  return {\n    min: resolvePointElastic(dragElastic, minLabel),\n    max: resolvePointElastic(dragElastic, maxLabel)\n  };\n}\n\nfunction resolvePointElastic(dragElastic, label) {\n  var _a;\n\n  return typeof dragElastic === \"number\" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n/**\n * Measure and return the element bounding box.\n *\n * We convert the box into an AxisBox2D to make it easier to work with each axis\n * individually and programmatically.\n *\n * This function optionally accepts a transformPagePoint function which allows us to compensate\n * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.\n */\n\n\nfunction getBoundingBox(element, transformPagePoint) {\n  var box = element.getBoundingClientRect();\n  return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\n}\n\nvar compareByDepth = function (a, b) {\n  return a.depth - b.depth;\n};\n\nfunction isProjecting(visualElement) {\n  var isEnabled = visualElement.projection.isEnabled;\n  return isEnabled || visualElement.shouldResetTransform();\n}\n\nfunction collectProjectingAncestors(visualElement, ancestors) {\n  if (ancestors === void 0) {\n    ancestors = [];\n  }\n\n  var parent = visualElement.parent;\n  if (parent) collectProjectingAncestors(parent, ancestors);\n  if (isProjecting(visualElement)) ancestors.push(visualElement);\n  return ancestors;\n}\n\nfunction collectProjectingChildren(visualElement) {\n  var children = [];\n\n  var addChild = function (child) {\n    if (isProjecting(child)) children.push(child);\n    child.children.forEach(addChild);\n  };\n\n  visualElement.children.forEach(addChild);\n  return children.sort(compareByDepth);\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\n\n\nfunction updateLayoutMeasurement(visualElement) {\n  if (visualElement.shouldResetTransform()) return;\n  var layoutState = visualElement.getLayoutState();\n  visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n  layoutState.isHydrated = true;\n  layoutState.layout = visualElement.measureViewportBox();\n  layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n  visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n  sync__default['default'].update(function () {\n    return visualElement.rebaseProjectionTarget();\n  });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\n\n\nfunction snapshotViewportBox(visualElement) {\n  if (visualElement.shouldResetTransform()) return;\n  visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n  /**\n   * Update targetBox to match the prevViewportBox. This is just to ensure\n   * that targetBox is affected by scroll in the same way as the measured box\n   */\n\n  visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\n\nfunction tweenAxis(target, prev, next, p) {\n  target.min = popmotion.mix(prev.min, next.min, p);\n  target.max = popmotion.mix(prev.max, next.max, p);\n}\n\nfunction calcRelativeOffsetAxis(parent, child) {\n  return {\n    min: child.min - parent.min,\n    max: child.max - parent.min\n  };\n}\n\nfunction calcRelativeOffset(parent, child) {\n  return {\n    x: calcRelativeOffsetAxis(parent.x, child.x),\n    y: calcRelativeOffsetAxis(parent.y, child.y)\n  };\n}\n\nfunction checkIfParentHasChanged(prev, next) {\n  var prevId = prev.getLayoutId();\n  var nextId = next.getLayoutId();\n  return prevId !== nextId || nextId === undefined && prev !== next;\n}\n\nfunction isDraggable(visualElement) {\n  var _a = visualElement.getProps(),\n      drag = _a.drag,\n      _dragX = _a._dragX;\n\n  return drag && !_dragX;\n}\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\n\n\nfunction resetAxis(axis, originAxis) {\n  axis.min = originAxis.min;\n  axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\n\n\nfunction resetBox(box, originBox) {\n  resetAxis(box.x, originBox.x);\n  resetAxis(box.y, originBox.y);\n}\n/**\n * Scales a point based on a factor and an originPoint\n */\n\n\nfunction scalePoint(point, scale, originPoint) {\n  var distanceFromOrigin = point - originPoint;\n  var scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\n\n\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\n\n\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n\n  if (scale === void 0) {\n    scale = 1;\n  }\n\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\n\n\nfunction applyBoxDelta(box, _a) {\n  var x = _a.x,\n      y = _a.y;\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\n\n\nfunction applyAxisTransforms(final, axis, transforms, _a) {\n  var _b = tslib.__read(_a, 3),\n      key = _b[0],\n      scaleKey = _b[1],\n      originKey = _b[2]; // Copy the current axis to the final axis before mutation\n\n\n  final.min = axis.min;\n  final.max = axis.max;\n  var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n  var originPoint = popmotion.mix(axis.min, axis.max, axisOrigin); // Apply the axis delta to the final axis\n\n  applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\n\n\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\n\nfunction applyBoxTransforms(finalBox, box, transforms) {\n  applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\n  applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\n}\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\n\n\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n  point -= translate;\n  point = scalePoint(point, 1 / scale, originPoint);\n\n  if (boxScale !== undefined) {\n    point = scalePoint(point, 1 / boxScale, originPoint);\n  }\n\n  return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\n\n\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n\n  if (scale === void 0) {\n    scale = 1;\n  }\n\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n\n  var originPoint = popmotion.mix(axis.min, axis.max, origin) - translate;\n  axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\n\n\nfunction removeAxisTransforms(axis, transforms, _a) {\n  var _b = tslib.__read(_a, 3),\n      key = _b[0],\n      scaleKey = _b[1],\n      originKey = _b[2];\n\n  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\n}\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\n\n\nfunction removeBoxTransforms(box, transforms) {\n  removeAxisTransforms(box.x, transforms, xKeys);\n  removeAxisTransforms(box.y, transforms, yKeys);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\n\n\nfunction applyTreeDeltas(box, treeScale, treePath) {\n  var treeLength = treePath.length;\n  if (!treeLength) return; // Reset the treeScale\n\n  treeScale.x = treeScale.y = 1;\n  var node;\n  var delta;\n\n  for (var i = 0; i < treeLength; i++) {\n    node = treePath[i];\n    delta = node.getLayoutState().delta; // Incoporate each ancestor's scale into a culmulative treeScale for this component\n\n    treeScale.x *= delta.x.scale;\n    treeScale.y *= delta.y.scale; // Apply each ancestor's calculated delta into this component's recorded layout box\n\n    applyBoxDelta(box, delta); // If this is a draggable ancestor, also incorporate the node's transform to the layout box\n\n    if (isDraggable(node)) {\n      applyBoxTransforms(box, box, node.getLatestValues());\n    }\n  }\n}\n/**\n * Returns a boolean stating whether or not we converted the projection\n * to relative projection.\n */\n\n\nfunction convertToRelativeProjection(visualElement, isLayoutDrag) {\n  if (isLayoutDrag === void 0) {\n    isLayoutDrag = true;\n  }\n\n  var projectionParent = visualElement.getProjectionParent();\n  if (!projectionParent) return false;\n  var offset;\n\n  if (isLayoutDrag) {\n    offset = calcRelativeOffset(projectionParent.projection.target, visualElement.projection.target);\n    removeBoxTransforms(offset, projectionParent.getLatestValues());\n  } else {\n    offset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\n  }\n\n  eachAxis(function (axis) {\n    return visualElement.setProjectionTargetAxis(axis, offset[axis].min, offset[axis].max, true);\n  });\n  return true;\n}\n\nvar unresolvedJobs = new Set();\n\nfunction pushJob(stack, job, pointer) {\n  if (!stack[pointer]) stack[pointer] = [];\n  stack[pointer].push(job);\n}\n\nfunction batchLayout(callback) {\n  unresolvedJobs.add(callback);\n  return function () {\n    return unresolvedJobs.delete(callback);\n  };\n}\n\nfunction flushLayout() {\n  if (!unresolvedJobs.size) return;\n  var pointer = 0;\n  var reads = [[]];\n  var writes = [];\n\n  var setRead = function (job) {\n    return pushJob(reads, job, pointer);\n  };\n\n  var setWrite = function (job) {\n    pushJob(writes, job, pointer);\n    pointer++;\n  };\n  /**\n   * Resolve jobs into their array stacks\n   */\n\n\n  unresolvedJobs.forEach(function (callback) {\n    callback(setRead, setWrite);\n    pointer = 0;\n  });\n  unresolvedJobs.clear();\n  /**\n   * Execute jobs\n   */\n\n  var numStacks = writes.length;\n\n  for (var i = 0; i <= numStacks; i++) {\n    reads[i] && reads[i].forEach(executeJob);\n    writes[i] && writes[i].forEach(executeJob);\n  }\n}\n\nvar executeJob = function (job) {\n  return job();\n};\n\nvar elementDragControls = new WeakMap();\n/**\n *\n */\n\nvar lastPointerEvent;\n\nvar VisualElementDragControls =\n/** @class */\nfunction () {\n  function VisualElementDragControls(_a) {\n    var visualElement = _a.visualElement;\n    /**\n     * Track whether we're currently dragging.\n     *\n     * @internal\n     */\n\n    this.isDragging = false;\n    /**\n     * The current direction of drag, or `null` if both.\n     *\n     * @internal\n     */\n\n    this.currentDirection = null;\n    /**\n     * The permitted boundaries of travel, in pixels.\n     *\n     * @internal\n     */\n\n    this.constraints = false;\n    /**\n     * The per-axis resolved elastic values.\n     *\n     * @internal\n     */\n\n    this.elastic = axisBox();\n    /**\n     * A reference to the host component's latest props.\n     *\n     * @internal\n     */\n\n    this.props = {};\n    /**\n     * @internal\n     */\n\n    this.hasMutatedConstraints = false;\n    /**\n     * Track the initial position of the cursor relative to the dragging element\n     * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\n     * an ideal bounding box for the VisualElement renderer to project into every frame.\n     *\n     * @internal\n     */\n\n    this.cursorProgress = {\n      x: 0.5,\n      y: 0.5\n    }; // When updating _dragX, or _dragY instead of the VisualElement,\n    // persist their values between drag gestures.\n\n    this.originPoint = {}; // This is a reference to the global drag gesture lock, ensuring only one component\n    // can \"capture\" the drag of one or both axes.\n    // TODO: Look into moving this into pansession?\n\n    this.openGlobalLock = null;\n    /**\n     * @internal\n     */\n\n    this.panSession = null;\n    this.visualElement = visualElement;\n    this.visualElement.enableLayoutProjection();\n    elementDragControls.set(visualElement, this);\n  }\n  /**\n   * Instantiate a PanSession for the drag gesture\n   *\n   * @public\n   */\n\n\n  VisualElementDragControls.prototype.start = function (originEvent, _a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.snapToCursor,\n        snapToCursor = _c === void 0 ? false : _c,\n        cursorProgress = _b.cursorProgress;\n\n    var onSessionStart = function (event) {\n      var _a; // Stop any animations on both axis values immediately. This allows the user to throw and catch\n      // the component.\n\n\n      _this.stopMotion();\n      /**\n       * Save the initial point. We'll use this to calculate the pointer's position rather\n       * than the one we receive when the gesture actually starts. By then, the pointer will\n       * have already moved, and the perception will be of the pointer \"slipping\" across the element\n       */\n\n\n      var initialPoint = getViewportPointFromEvent(event).point;\n      (_a = _this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(_this);\n      _this.cancelLayout = batchLayout(function (read, write) {\n        var ancestors = collectProjectingAncestors(_this.visualElement);\n        var children = collectProjectingChildren(_this.visualElement);\n\n        var tree = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(children));\n\n        var hasManuallySetCursorOrigin = false;\n        /**\n         * Apply a simple lock to the projection target. This ensures no animations\n         * can run on the projection box while this lock is active.\n         */\n\n        _this.isLayoutDrag() && _this.visualElement.lockProjectionTarget();\n        write(function () {\n          tree.forEach(function (element) {\n            return element.resetTransform();\n          });\n        });\n        read(function () {\n          updateLayoutMeasurement(_this.visualElement);\n          children.forEach(updateLayoutMeasurement);\n        });\n        write(function () {\n          tree.forEach(function (element) {\n            return element.restoreTransform();\n          });\n\n          if (snapToCursor) {\n            hasManuallySetCursorOrigin = _this.snapToCursor(initialPoint);\n          }\n        });\n        read(function () {\n          var isRelativeDrag = Boolean(_this.getAxisMotionValue(\"x\") && !_this.isExternalDrag());\n\n          if (!isRelativeDrag) {\n            _this.visualElement.rebaseProjectionTarget(true, _this.visualElement.measureViewportBox(false));\n          }\n\n          _this.visualElement.scheduleUpdateLayoutProjection();\n          /**\n           * When dragging starts, we want to find where the cursor is relative to the bounding box\n           * of the element. Every frame, we calculate a new bounding box using this relative position\n           * and let the visualElement renderer figure out how to reproject the element into this bounding\n           * box.\n           *\n           * By doing it this way, rather than applying an x/y transform directly to the element,\n           * we can ensure the component always visually sticks to the cursor as we'd expect, even\n           * if the DOM element itself changes layout as a result of React updates the user might\n           * make based on the drag position.\n           */\n\n\n          var projection = _this.visualElement.projection;\n          eachAxis(function (axis) {\n            if (!hasManuallySetCursorOrigin) {\n              var _a = projection.target[axis],\n                  min = _a.min,\n                  max = _a.max;\n              _this.cursorProgress[axis] = cursorProgress ? cursorProgress[axis] : popmotion.progress(min, max, initialPoint[axis]);\n            }\n            /**\n             * If we have external drag MotionValues, record their origin point. On pointermove\n             * we'll apply the pan gesture offset directly to this value.\n             */\n\n\n            var axisValue = _this.getAxisMotionValue(axis);\n\n            if (axisValue) {\n              _this.originPoint[axis] = axisValue.get();\n            }\n          });\n        });\n        write(function () {\n          sync.flushSync.update();\n          sync.flushSync.preRender();\n          sync.flushSync.render();\n          sync.flushSync.postRender();\n        });\n        read(function () {\n          return _this.resolveDragConstraints();\n        });\n      });\n    };\n\n    var onStart = function (event, info) {\n      var _a, _b, _c; // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n\n\n      var _d = _this.props,\n          drag = _d.drag,\n          dragPropagation = _d.dragPropagation;\n\n      if (drag && !dragPropagation) {\n        if (_this.openGlobalLock) _this.openGlobalLock();\n        _this.openGlobalLock = getGlobalLock(drag); // If we don 't have the lock, don't start dragging\n\n        if (!_this.openGlobalLock) return;\n      }\n\n      flushLayout(); // Set current drag status\n\n      _this.isDragging = true;\n      _this.currentDirection = null; // Fire onDragStart event\n\n      (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n      (_c = _this.visualElement.animationState) === null || _c === void 0 ? void 0 : _c.setActive(AnimationType.Drag, true);\n    };\n\n    var onMove = function (event, info) {\n      var _a, _b, _c, _d;\n\n      var _e = _this.props,\n          dragPropagation = _e.dragPropagation,\n          dragDirectionLock = _e.dragDirectionLock; // If we didn't successfully receive the gesture lock, early return.\n\n      if (!dragPropagation && !_this.openGlobalLock) return;\n      var offset = info.offset; // Attempt to detect drag direction if directionLock is true\n\n      if (dragDirectionLock && _this.currentDirection === null) {\n        _this.currentDirection = getCurrentDirection(offset); // If we've successfully set a direction, notify listener\n\n        if (_this.currentDirection !== null) {\n          (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\n        }\n\n        return;\n      } // Update each point with the latest position\n\n\n      _this.updateAxis(\"x\", info.point, offset);\n\n      _this.updateAxis(\"y\", info.point, offset); // Fire onDrag event\n\n\n      (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info); // Update the last pointer event\n\n      lastPointerEvent = event;\n    };\n\n    var onSessionEnd = function (event, info) {\n      return _this.stop(event, info);\n    };\n\n    var transformPagePoint = this.props.transformPagePoint;\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart: onSessionStart,\n      onStart: onStart,\n      onMove: onMove,\n      onSessionEnd: onSessionEnd\n    }, {\n      transformPagePoint: transformPagePoint\n    });\n  };\n\n  VisualElementDragControls.prototype.resolveDragConstraints = function () {\n    var _this = this;\n\n    var _a = this.props,\n        dragConstraints = _a.dragConstraints,\n        dragElastic = _a.dragElastic;\n    var layout = this.visualElement.getLayoutState().layoutCorrected;\n\n    if (dragConstraints) {\n      this.constraints = isRefObject(dragConstraints) ? this.resolveRefConstraints(layout, dragConstraints) : calcRelativeConstraints(layout, dragConstraints);\n    } else {\n      this.constraints = false;\n    }\n\n    this.elastic = resolveDragElastic(dragElastic);\n    /**\n     * If we're outputting to external MotionValues, we want to rebase the measured constraints\n     * from viewport-relative to component-relative.\n     */\n\n    if (this.constraints && !this.hasMutatedConstraints) {\n      eachAxis(function (axis) {\n        if (_this.getAxisMotionValue(axis)) {\n          _this.constraints[axis] = rebaseAxisConstraints(layout[axis], _this.constraints[axis]);\n        }\n      });\n    }\n  };\n\n  VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\n    var _a = this.props,\n        onMeasureDragConstraints = _a.onMeasureDragConstraints,\n        transformPagePoint = _a.transformPagePoint;\n    var constraintsElement = constraints.current;\n    heyListen.invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n    this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\n    var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\n    /**\n     * If there's an onMeasureDragConstraints listener we call it and\n     * if different constraints are returned, set constraints to that\n     */\n\n    if (onMeasureDragConstraints) {\n      var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\n      this.hasMutatedConstraints = !!userConstraints;\n\n      if (userConstraints) {\n        measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\n      }\n    }\n\n    return measuredConstraints;\n  };\n\n  VisualElementDragControls.prototype.cancelDrag = function () {\n    var _a, _b;\n\n    this.visualElement.unlockProjectionTarget();\n    (_a = this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(this);\n    this.isDragging = false;\n    this.panSession && this.panSession.end();\n    this.panSession = null;\n\n    if (!this.props.dragPropagation && this.openGlobalLock) {\n      this.openGlobalLock();\n      this.openGlobalLock = null;\n    }\n\n    (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);\n  };\n\n  VisualElementDragControls.prototype.stop = function (event, info) {\n    var _a, _b, _c;\n\n    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n    this.panSession = null;\n    var isDragging = this.isDragging;\n    this.cancelDrag();\n    if (!isDragging) return;\n    var velocity = info.velocity;\n    this.animateDragEnd(velocity);\n    (_c = (_b = this.props).onDragEnd) === null || _c === void 0 ? void 0 : _c.call(_b, event, info);\n  };\n\n  VisualElementDragControls.prototype.snapToCursor = function (point) {\n    var _this = this;\n\n    return eachAxis(function (axis) {\n      var drag = _this.props.drag; // If we're not dragging this axis, do an early return.\n\n      if (!shouldDrag(axis, drag, _this.currentDirection)) return;\n\n      var axisValue = _this.getAxisMotionValue(axis);\n\n      if (axisValue) {\n        var box = _this.visualElement.getLayoutState().layout;\n\n        var length_1 = box[axis].max - box[axis].min;\n        var center = box[axis].min + length_1 / 2;\n        var offset = point[axis] - center;\n        _this.originPoint[axis] = point[axis];\n        axisValue.set(offset);\n      } else {\n        _this.cursorProgress[axis] = 0.5;\n        return true;\n      }\n    }).includes(true);\n  };\n  /**\n   * Update the specified axis with the latest pointer information.\n   */\n\n\n  VisualElementDragControls.prototype.updateAxis = function (axis, point, offset) {\n    var drag = this.props.drag; // If we're not dragging this axis, do an early return.\n\n    if (!shouldDrag(axis, drag, this.currentDirection)) return;\n    return this.getAxisMotionValue(axis) ? this.updateAxisMotionValue(axis, offset) : this.updateVisualElementAxis(axis, point);\n  };\n\n  VisualElementDragControls.prototype.updateAxisMotionValue = function (axis, offset) {\n    var axisValue = this.getAxisMotionValue(axis);\n    if (!offset || !axisValue) return;\n    var nextValue = this.originPoint[axis] + offset[axis];\n    var update = this.constraints ? applyConstraints(nextValue, this.constraints[axis], this.elastic[axis]) : nextValue;\n    axisValue.set(update);\n  };\n\n  VisualElementDragControls.prototype.updateVisualElementAxis = function (axis, point) {\n    var _a; // Get the actual layout bounding box of the element\n\n\n    var axisLayout = this.visualElement.getLayoutState().layout[axis]; // Calculate its current length. In the future we might want to lerp this to animate\n    // between lengths if the layout changes as we change the DOM\n\n    var axisLength = axisLayout.max - axisLayout.min; // Get the initial progress that the pointer sat on this axis on gesture start.\n\n    var axisProgress = this.cursorProgress[axis]; // Calculate a new min point based on the latest pointer position, constraints and elastic\n\n    var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], this.elastic[axis]); // Update the axis viewport target with this new min and the length\n\n    this.visualElement.setProjectionTargetAxis(axis, min, min + axisLength);\n  };\n\n  VisualElementDragControls.prototype.setProps = function (_a) {\n    var _b = _a.drag,\n        drag = _b === void 0 ? false : _b,\n        _c = _a.dragDirectionLock,\n        dragDirectionLock = _c === void 0 ? false : _c,\n        _d = _a.dragPropagation,\n        dragPropagation = _d === void 0 ? false : _d,\n        _e = _a.dragConstraints,\n        dragConstraints = _e === void 0 ? false : _e,\n        _f = _a.dragElastic,\n        dragElastic = _f === void 0 ? defaultElastic : _f,\n        _g = _a.dragMomentum,\n        dragMomentum = _g === void 0 ? true : _g,\n        remainingProps = tslib.__rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n\n    this.props = tslib.__assign({\n      drag: drag,\n      dragDirectionLock: dragDirectionLock,\n      dragPropagation: dragPropagation,\n      dragConstraints: dragConstraints,\n      dragElastic: dragElastic,\n      dragMomentum: dragMomentum\n    }, remainingProps);\n  };\n  /**\n   * Drag works differently depending on which props are provided.\n   *\n   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n   * - If the component will perform layout animations, we output the gesture to the component's\n   *      visual bounding box\n   * - Otherwise, we apply the delta to the x/y motion values.\n   */\n\n\n  VisualElementDragControls.prototype.getAxisMotionValue = function (axis) {\n    var _a = this.props,\n        layout = _a.layout,\n        layoutId = _a.layoutId;\n    var dragKey = \"_drag\" + axis.toUpperCase();\n\n    if (this.props[dragKey]) {\n      return this.props[dragKey];\n    } else if (!layout && layoutId === undefined) {\n      return this.visualElement.getValue(axis, 0);\n    }\n  };\n\n  VisualElementDragControls.prototype.isLayoutDrag = function () {\n    return !this.getAxisMotionValue(\"x\");\n  };\n\n  VisualElementDragControls.prototype.isExternalDrag = function () {\n    var _a = this.props,\n        _dragX = _a._dragX,\n        _dragY = _a._dragY;\n    return _dragX || _dragY;\n  };\n\n  VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n    var _this = this;\n\n    var _a = this.props,\n        drag = _a.drag,\n        dragMomentum = _a.dragMomentum,\n        dragElastic = _a.dragElastic,\n        dragTransition = _a.dragTransition;\n    /**\n     * Everything beyond the drag gesture should be performed with\n     * relative projection so children stay in sync with their parent element.\n     */\n\n    var isRelative = convertToRelativeProjection(this.visualElement, this.isLayoutDrag() && !this.isExternalDrag());\n    /**\n     * If we had previously resolved constraints relative to the viewport,\n     * we need to also convert those to a relative coordinate space for the animation\n     */\n\n    var constraints = this.constraints || {};\n\n    if (isRelative && Object.keys(constraints).length && this.isLayoutDrag()) {\n      var projectionParent = this.visualElement.getProjectionParent();\n\n      if (projectionParent) {\n        var relativeConstraints_1 = calcRelativeOffset(projectionParent.projection.targetFinal, constraints);\n        eachAxis(function (axis) {\n          var _a = relativeConstraints_1[axis],\n              min = _a.min,\n              max = _a.max;\n          constraints[axis] = {\n            min: isNaN(min) ? undefined : min,\n            max: isNaN(max) ? undefined : max\n          };\n        });\n      }\n    }\n\n    var momentumAnimations = eachAxis(function (axis) {\n      var _a;\n\n      if (!shouldDrag(axis, drag, _this.currentDirection)) {\n        return;\n      }\n\n      var transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n      /**\n       * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n       * of spring animations so we should look into adding a disable spring option to `inertia`.\n       * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n       * using the value of `dragElastic`.\n       */\n\n      var bounceStiffness = dragElastic ? 200 : 1000000;\n      var bounceDamping = dragElastic ? 40 : 10000000;\n\n      var inertia = tslib.__assign(tslib.__assign({\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness: bounceStiffness,\n        bounceDamping: bounceDamping,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10\n      }, dragTransition), transition); // If we're not animating on an externally-provided `MotionValue` we can use the\n      // component's animation controls which will handle interactions with whileHover (etc),\n      // otherwise we just have to animate the `MotionValue` itself.\n\n\n      return _this.getAxisMotionValue(axis) ? _this.startAxisValueAnimation(axis, inertia) : _this.visualElement.startLayoutAnimation(axis, inertia, isRelative);\n    }); // Run all animations and then resolve the new drag constraints.\n\n    return Promise.all(momentumAnimations).then(function () {\n      var _a, _b;\n\n      (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n\n  VisualElementDragControls.prototype.stopMotion = function () {\n    var _this = this;\n\n    eachAxis(function (axis) {\n      var axisValue = _this.getAxisMotionValue(axis);\n\n      axisValue ? axisValue.stop() : _this.visualElement.stopLayoutAnimation();\n    });\n  };\n\n  VisualElementDragControls.prototype.startAxisValueAnimation = function (axis, transition) {\n    var axisValue = this.getAxisMotionValue(axis);\n    if (!axisValue) return;\n    var currentValue = axisValue.get();\n    axisValue.set(currentValue);\n    axisValue.set(currentValue); // Set twice to hard-reset velocity\n\n    return startAnimation(axis, axisValue, 0, transition);\n  };\n\n  VisualElementDragControls.prototype.scalePoint = function () {\n    var _this = this;\n\n    var _a = this.props,\n        drag = _a.drag,\n        dragConstraints = _a.dragConstraints;\n    if (!isRefObject(dragConstraints) || !this.constraintsBox) return; // Stop any current animations as there can be some visual glitching if we resize mid animation\n\n    this.stopMotion(); // Record the relative progress of the targetBox relative to the constraintsBox\n\n    var boxProgress = {\n      x: 0,\n      y: 0\n    };\n    eachAxis(function (axis) {\n      boxProgress[axis] = calcOrigin(_this.visualElement.projection.target[axis], _this.constraintsBox[axis]);\n    });\n    /**\n     * For each axis, calculate the current progress of the layout axis within the constraints.\n     * Then, using the latest layout and constraints measurements, reposition the new layout axis\n     * proportionally within the constraints.\n     */\n\n    this.updateConstraints(function () {\n      eachAxis(function (axis) {\n        if (!shouldDrag(axis, drag, null)) return; // Calculate the position of the targetBox relative to the constraintsBox using the\n        // previously calculated progress\n\n        var _a = calcPositionFromProgress(_this.visualElement.projection.target[axis], _this.constraintsBox[axis], boxProgress[axis]),\n            min = _a.min,\n            max = _a.max;\n\n        _this.visualElement.setProjectionTargetAxis(axis, min, max);\n      });\n    });\n    /**\n     * If any other draggable components are queuing the same tasks synchronously\n     * this will wait until they've all been scheduled before flushing.\n     */\n\n    setTimeout(flushLayout, 1);\n  };\n\n  VisualElementDragControls.prototype.updateConstraints = function (onReady) {\n    var _this = this;\n\n    this.cancelLayout = batchLayout(function (read, write) {\n      var ancestors = collectProjectingAncestors(_this.visualElement);\n      write(function () {\n        return ancestors.forEach(function (element) {\n          return element.resetTransform();\n        });\n      });\n      read(function () {\n        return updateLayoutMeasurement(_this.visualElement);\n      });\n      write(function () {\n        return ancestors.forEach(function (element) {\n          return element.restoreTransform();\n        });\n      });\n      read(function () {\n        _this.resolveDragConstraints();\n      });\n      if (onReady) write(onReady);\n    });\n  };\n\n  VisualElementDragControls.prototype.mount = function (visualElement) {\n    var _this = this;\n\n    var element = visualElement.getInstance();\n    /**\n     * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n     */\n\n    var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n      var _a = _this.props,\n          drag = _a.drag,\n          _b = _a.dragListener,\n          dragListener = _b === void 0 ? true : _b;\n      drag && dragListener && _this.start(event);\n    });\n    /**\n     * Attach a window resize listener to scale the draggable target within its defined\n     * constraints as the window resizes.\n     */\n\n    var stopResizeListener = addDomEvent(window, \"resize\", function () {\n      _this.scalePoint();\n    });\n    /**\n     * Ensure drag constraints are resolved correctly relative to the dragging element\n     * whenever its layout changes.\n     */\n\n    var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\n      if (_this.isDragging) {\n        _this.resolveDragConstraints();\n      }\n    });\n    /**\n     * If the previous component with this same layoutId was dragging at the time\n     * it was unmounted, we want to continue the same gesture on this component.\n     */\n\n    var prevDragCursor = visualElement.prevDragCursor;\n\n    if (prevDragCursor) {\n      this.start(lastPointerEvent, {\n        cursorProgress: prevDragCursor\n      });\n    }\n    /**\n     * Return a function that will teardown the drag gesture\n     */\n\n\n    return function () {\n      stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\n      stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\n      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n\n      _this.cancelDrag();\n    };\n  };\n\n  return VisualElementDragControls;\n}();\n\nfunction shouldDrag(direction, drag, currentDirection) {\n  return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\n\n\nfunction getCurrentDirection(offset, lockThreshold) {\n  if (lockThreshold === void 0) {\n    lockThreshold = 10;\n  }\n\n  var direction = null;\n\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n\n  return direction;\n}\n/**\n * A hook that allows an element to be dragged.\n *\n * @internal\n */\n\n\nfunction useDrag(props) {\n  var groupDragControls = props.dragControls,\n      visualElement = props.visualElement;\n  var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n  var dragControls = useConstant(function () {\n    return new VisualElementDragControls({\n      visualElement: visualElement\n    });\n  });\n  dragControls.setProps(tslib.__assign(tslib.__assign({}, props), {\n    transformPagePoint: transformPagePoint\n  })); // If we've been provided a DragControls for manual control over the drag gesture,\n  // subscribe this component to it on mount.\n\n  React.useEffect(function () {\n    return groupDragControls && groupDragControls.subscribe(dragControls);\n  }, [dragControls]); // Mount the drag controls with the visualElement\n\n  React.useEffect(function () {\n    return dragControls.mount(visualElement);\n  }, []);\n}\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @internalremarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */\n\n\nfunction usePanGesture(_a) {\n  var onPan = _a.onPan,\n      onPanStart = _a.onPanStart,\n      onPanEnd = _a.onPanEnd,\n      onPanSessionStart = _a.onPanSessionStart,\n      visualElement = _a.visualElement;\n  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n  var panSession = React.useRef(null);\n  var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n  var handlers = {\n    onSessionStart: onPanSessionStart,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd: function (event, info) {\n      panSession.current = null;\n      onPanEnd && onPanEnd(event, info);\n    }\n  };\n  React.useEffect(function () {\n    if (panSession.current !== null) {\n      panSession.current.updateHandlers(handlers);\n    }\n  });\n\n  function onPointerDown(event) {\n    panSession.current = new PanSession(event, handlers, {\n      transformPagePoint: transformPagePoint\n    });\n  }\n\n  usePointerEvent(visualElement, \"pointerdown\", hasPanEvents && onPointerDown);\n  useUnmountEffect(function () {\n    return panSession.current && panSession.current.end();\n  });\n}\n\nvar drag = {\n  pan: makeRenderlessComponent(usePanGesture),\n  drag: makeRenderlessComponent(useDrag)\n};\n/**\n * @public\n */\n\nvar Presence;\n\n(function (Presence) {\n  Presence[Presence[\"Entering\"] = 0] = \"Entering\";\n  Presence[Presence[\"Present\"] = 1] = \"Present\";\n  Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\n/**\n * @public\n */\n\n\nexports.VisibilityAction = void 0;\n\n(function (VisibilityAction) {\n  VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\n  VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\n})(exports.VisibilityAction || (exports.VisibilityAction = {}));\n\nfunction isCSSVariable(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\n\n\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\n\nfunction parseCSSVariable(current) {\n  var match = cssVariableRegex.exec(current);\n  if (!match) return [,];\n\n  var _a = tslib.__read(match, 3),\n      token = _a[1],\n      fallback = _a[2];\n\n  return [token, fallback];\n}\n\nvar maxDepth = 4;\n\nfunction getVariableValue(current, element, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  }\n\n  heyListen.invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n\n  var _a = tslib.__read(parseCSSVariable(current), 2),\n      token = _a[0],\n      fallback = _a[1]; // No CSS variable detected\n\n\n  if (!token) return; // Attempt to read this CSS variable off the element\n\n  var resolved = window.getComputedStyle(element).getPropertyValue(token);\n\n  if (resolved) {\n    return resolved.trim();\n  } else if (isCSSVariable(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\n\n\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n  var _b;\n\n  var target = tslib.__rest(_a, []);\n\n  var element = visualElement.getInstance();\n  if (!(element instanceof HTMLElement)) return {\n    target: target,\n    transitionEnd: transitionEnd\n  }; // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n\n  if (transitionEnd) {\n    transitionEnd = tslib.__assign({}, transitionEnd);\n  } // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n\n\n  visualElement.forEachValue(function (value) {\n    var current = value.get();\n    if (!isCSSVariable(current)) return;\n    var resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  }); // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n\n  for (var key in target) {\n    var current = target[key];\n    if (!isCSSVariable(current)) continue;\n    var resolved = getVariableValue(current, element);\n    if (!resolved) continue; // Clone target if it hasn't already been\n\n    target[key] = resolved; // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n\n    if (transitionEnd) (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : transitionEnd[key] = current;\n  }\n\n  return {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n\nfunction pixelsToPercent(pixels, axis) {\n  return pixels / (axis.max - axis.min) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\n\n\nfunction correctBorderRadius(latest, _layoutState, _a) {\n  var target = _a.target;\n  /**\n   * If latest is a string, if it's a percentage we can return immediately as it's\n   * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n   */\n\n  if (typeof latest === \"string\") {\n    if (styleValueTypes.px.test(latest)) {\n      latest = parseFloat(latest);\n    } else {\n      return latest;\n    }\n  }\n  /**\n   * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n   * pixel value as a percentage of each axis\n   */\n\n\n  var x = pixelsToPercent(latest, target.x);\n  var y = pixelsToPercent(latest, target.y);\n  return x + \"% \" + y + \"%\";\n}\n\nvar varToken = \"_$css\";\n\nfunction correctBoxShadow(latest, _a) {\n  var delta = _a.delta,\n      treeScale = _a.treeScale;\n  var original = latest;\n  /**\n   * We need to first strip and store CSS variables from the string.\n   */\n\n  var containsCSSVariables = latest.includes(\"var(\");\n  var cssVariables = [];\n\n  if (containsCSSVariables) {\n    latest = latest.replace(cssVariableRegex, function (match) {\n      cssVariables.push(match);\n      return varToken;\n    });\n  }\n\n  var shadow = styleValueTypes.complex.parse(latest); // TODO: Doesn't support multiple shadows\n\n  if (shadow.length > 5) return original;\n  var template = styleValueTypes.complex.createTransformer(latest);\n  var offset = typeof shadow[0] !== \"number\" ? 1 : 0; // Calculate the overall context scale\n\n  var xScale = delta.x.scale * treeScale.x;\n  var yScale = delta.y.scale * treeScale.y;\n  shadow[0 + offset] /= xScale;\n  shadow[1 + offset] /= yScale;\n  /**\n   * Ideally we'd correct x and y scales individually, but because blur and\n   * spread apply to both we have to take a scale average and apply that instead.\n   * We could potentially improve the outcome of this by incorporating the ratio between\n   * the two scales.\n   */\n\n  var averageScale = popmotion.mix(xScale, yScale, 0.5); // Blur\n\n  if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale; // Spread\n\n  if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n  var output = template(shadow);\n\n  if (containsCSSVariables) {\n    var i_1 = 0;\n    output = output.replace(varToken, function () {\n      var cssVariable = cssVariables[i_1];\n      i_1++;\n      return cssVariable;\n    });\n  }\n\n  return output;\n}\n\nvar borderCorrectionDefinition = {\n  process: correctBorderRadius\n};\nvar defaultScaleCorrectors = {\n  borderRadius: tslib.__assign(tslib.__assign({}, borderCorrectionDefinition), {\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  }),\n  borderTopLeftRadius: borderCorrectionDefinition,\n  borderTopRightRadius: borderCorrectionDefinition,\n  borderBottomLeftRadius: borderCorrectionDefinition,\n  borderBottomRightRadius: borderCorrectionDefinition,\n  boxShadow: {\n    process: correctBoxShadow\n  }\n};\nvar progressTarget = 1000;\n\nvar Animate =\n/** @class */\nfunction (_super) {\n  tslib.__extends(Animate, _super);\n\n  function Animate() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A mutable object that tracks the target viewport box\n     * for the current animation frame.\n     */\n\n\n    _this.frameTarget = axisBox();\n    /**\n     * The current animation target, we use this to check whether to start\n     * a new animation or continue the existing one.\n     */\n\n    _this.currentAnimationTarget = axisBox();\n    /**\n     * Track whether we're animating this axis.\n     */\n\n    _this.isAnimating = {\n      x: false,\n      y: false\n    };\n    _this.stopAxisAnimation = {\n      x: undefined,\n      y: undefined\n    };\n    _this.isAnimatingTree = false;\n\n    _this.animate = function (target, origin, _a) {\n      if (_a === void 0) {\n        _a = {};\n      }\n\n      var originBox = _a.originBox,\n          targetBox = _a.targetBox,\n          visibilityAction = _a.visibilityAction,\n          shouldStackAnimate = _a.shouldStackAnimate,\n          onComplete = _a.onComplete,\n          prevParent = _a.prevParent,\n          config = tslib.__rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\", \"shouldStackAnimate\", \"onComplete\", \"prevParent\"]);\n\n      var _b = _this.props,\n          visualElement = _b.visualElement,\n          layout = _b.layout;\n      /**\n       * Early return if we've been instructed not to animate this render.\n       */\n\n      if (shouldStackAnimate === false) {\n        _this.isAnimatingTree = false;\n        return _this.safeToRemove();\n      }\n      /**\n       * Prioritise tree animations\n       */\n\n\n      if (_this.isAnimatingTree && shouldStackAnimate !== true) {\n        return;\n      } else if (shouldStackAnimate) {\n        _this.isAnimatingTree = true;\n      }\n      /**\n       * Allow the measured origin (prev bounding box) and target (actual layout) to be\n       * overridden by the provided config.\n       */\n\n\n      origin = originBox || origin;\n      target = targetBox || target;\n      /**\n       * If this element has a projecting parent, there's an opportunity to animate\n       * it relatively to that parent rather than relatively to the viewport. This\n       * allows us to add orchestrated animations.\n       */\n\n      var isRelative = false;\n      var projectionParent = visualElement.getProjectionParent();\n\n      if (projectionParent) {\n        var prevParentViewportBox = projectionParent.prevViewportBox;\n        var parentLayout = projectionParent.getLayoutState().layout;\n        /**\n         * If we're being provided a previous parent VisualElement by AnimateSharedLayout\n         */\n\n        if (prevParent) {\n          /**\n           * If we've been provided an explicit target box it means we're animating back\n           * to this previous parent. So we can make a relative box by comparing to the previous\n           * parent's layout\n           */\n          if (targetBox) {\n            parentLayout = prevParent.getLayoutState().layout;\n          }\n          /**\n           * Likewise if we've been provided an explicit origin box it means we're\n           * animating out from a different element. So we should figure out where that was\n           * on screen relative to the new parent element.\n           */\n\n\n          if (originBox && !checkIfParentHasChanged(prevParent, projectionParent) && prevParent.prevViewportBox) {\n            prevParentViewportBox = prevParent.prevViewportBox;\n          }\n        }\n\n        if (prevParentViewportBox && isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox)) {\n          isRelative = true;\n          origin = calcRelativeOffset(prevParentViewportBox, origin);\n          target = calcRelativeOffset(parentLayout, target);\n        }\n      }\n\n      var boxHasMoved = hasMoved(origin, target);\n      var animations = eachAxis(function (axis) {\n        var _a, _b;\n        /**\n         * If layout is set to \"position\", we can resize the origin box based on the target\n         * box and only animate its position.\n         */\n\n\n        if (layout === \"position\") {\n          var targetLength = target[axis].max - target[axis].min;\n          origin[axis].max = origin[axis].min + targetLength;\n        }\n\n        if (visualElement.projection.isTargetLocked) {\n          return;\n        } else if (visibilityAction !== undefined) {\n          visualElement.setVisibility(visibilityAction === exports.VisibilityAction.Show);\n        } else if (boxHasMoved) {\n          // If the box has moved, animate between it's current visual state and its\n          // final state\n          return _this.animateAxis(axis, target[axis], origin[axis], tslib.__assign(tslib.__assign({}, config), {\n            isRelative: isRelative\n          }));\n        } else {\n          (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a); // If the box has remained in the same place, immediately set the axis target\n          // to the final desired state\n\n          return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max, isRelative);\n        }\n      }); // Force a render to ensure there's no flash of uncorrected bounding box.\n\n      visualElement.syncRender();\n      /**\n       * If this visualElement isn't present (ie it's been removed from the tree by the user but\n       * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n       * have successfully finished.\n       */\n\n      return Promise.all(animations).then(function () {\n        _this.isAnimatingTree = false;\n        onComplete && onComplete();\n        visualElement.notifyLayoutAnimationComplete();\n      });\n    };\n\n    return _this;\n  }\n\n  Animate.prototype.componentDidMount = function () {\n    var _this = this;\n\n    var visualElement = this.props.visualElement;\n    visualElement.animateMotionValue = startAnimation;\n    visualElement.enableLayoutProjection();\n    this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n\n    visualElement.layoutSafeToRemove = function () {\n      return _this.safeToRemove();\n    };\n\n    addScaleCorrection(defaultScaleCorrectors);\n  };\n\n  Animate.prototype.componentWillUnmount = function () {\n    var _this = this;\n\n    this.unsubLayoutReady();\n    eachAxis(function (axis) {\n      var _a, _b;\n\n      return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n  /**\n   * TODO: This manually performs animations on the visualElement's layout progress\n   * values. It'd be preferable to amend the startLayoutAxisAnimation\n   * API to accept more custom animations like this.\n   */\n\n\n  Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n    var _this = this;\n\n    var _b, _c;\n\n    var _d = _a === void 0 ? {} : _a,\n        transition = _d.transition,\n        isRelative = _d.isRelative;\n    /**\n     * If we're not animating to a new target, don't run this animation\n     */\n\n\n    if (this.isAnimating[axis] && axisIsEqual(target, this.currentAnimationTarget[axis])) {\n      return;\n    }\n\n    (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n    this.isAnimating[axis] = true;\n    var visualElement = this.props.visualElement;\n    var frameTarget = this.frameTarget[axis];\n    var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];\n    /**\n     * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n     * be re-incoporated into a subsequent spring animation.\n     */\n\n    layoutProgress.clearListeners();\n    layoutProgress.set(0);\n    layoutProgress.set(0);\n    /**\n     * Create an animation function to run once per frame. This will tween the visual bounding box from\n     * origin to target using the latest progress value.\n     */\n\n    var frame = function () {\n      // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n      var p = layoutProgress.get() / progressTarget; // Tween the axis and update the visualElement with the latest values\n\n      tweenAxis(frameTarget, origin, target, p);\n      visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max, isRelative);\n    }; // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n\n\n    frame(); // Create a function to stop animation on this specific axis\n\n    var unsubscribeProgress = layoutProgress.onChange(frame);\n\n    this.stopAxisAnimation[axis] = function () {\n      _this.isAnimating[axis] = false;\n      layoutProgress.stop();\n      unsubscribeProgress();\n    };\n\n    this.currentAnimationTarget[axis] = target;\n    var layoutTransition = transition || visualElement.getDefaultTransition() || defaultLayoutTransition; // Start the animation on this axis\n\n    var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, \"layout\")).then(this.stopAxisAnimation[axis]);\n    return animation;\n  };\n\n  Animate.prototype.safeToRemove = function () {\n    var _a, _b;\n\n    (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n  };\n\n  Animate.prototype.render = function () {\n    return null;\n  };\n\n  return Animate;\n}(React__namespace.Component);\n\nfunction AnimateLayoutContextProvider(props) {\n  var _a = tslib.__read(usePresence(), 2),\n      safeToRemove = _a[1];\n\n  return React__namespace.createElement(Animate, tslib.__assign({}, props, {\n    safeToRemove: safeToRemove\n  }));\n}\n\nfunction hasMoved(a, b) {\n  return !isZeroBox(a) && !isZeroBox(b) && (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y));\n}\n\nvar zeroAxis = {\n  min: 0,\n  max: 0\n};\n\nfunction isZeroBox(a) {\n  return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);\n}\n\nfunction axisIsEqual(a, b) {\n  return a.min === b.min && a.max === b.max;\n}\n\nvar defaultLayoutTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\n\nfunction isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox) {\n  return prevParent || !prevParent && !(originBox || targetBox);\n}\n/**\n * Default handlers for batching VisualElements\n */\n\n\nvar defaultHandler = {\n  layoutReady: function (child) {\n    return child.notifyLayoutReady();\n  }\n};\n/**\n * Create a batcher to process VisualElements\n */\n\nfunction createBatcher() {\n  var queue = new Set();\n  return {\n    add: function (child) {\n      return queue.add(child);\n    },\n    flush: function (_a) {\n      var _b = _a === void 0 ? defaultHandler : _a,\n          layoutReady = _b.layoutReady,\n          parent = _b.parent;\n\n      batchLayout(function (read, write) {\n        var order = Array.from(queue).sort(compareByDepth);\n        var ancestors = parent ? collectProjectingAncestors(parent) : [];\n        write(function () {\n          var allElements = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(order));\n\n          allElements.forEach(function (element) {\n            return element.resetTransform();\n          });\n        });\n        read(function () {\n          order.forEach(updateLayoutMeasurement);\n        });\n        write(function () {\n          ancestors.forEach(function (element) {\n            return element.restoreTransform();\n          });\n          order.forEach(layoutReady);\n        });\n        read(function () {\n          /**\n           * After all children have started animating, ensure any Entering components are set to Present.\n           * If we add deferred animations (set up all animations and then start them in two loops) this\n           * could be moved to the start loop. But it needs to happen after all the animations configs\n           * are generated in AnimateSharedLayout as this relies on presence data\n           */\n          order.forEach(function (child) {\n            if (child.isPresent) child.presence = Presence.Present;\n          });\n        });\n        write(function () {\n          /**\n           * Starting these animations will have queued jobs on the frame loop. In some situations,\n           * like when removing an element, these will be processed too late after the DOM is manipulated,\n           * leaving a flash of incorrectly-projected content. By manually flushing these jobs\n           * we ensure there's no flash.\n           */\n          sync.flushSync.preRender();\n          sync.flushSync.render();\n        });\n        read(function () {\n          /**\n           * Schedule a callback at the end of the following frame to assign the latest projection\n           * box to the prevViewportBox snapshot. Once global batching is in place this could be run\n           * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\n           * child attempts to calculate its previous relative position against a prevViewportBox\n           * it will be against its latest projection box instead, as the snapshot is useless beyond this\n           * render.\n           */\n          sync__default['default'].postRender(function () {\n            return order.forEach(assignProjectionToSnapshot);\n          });\n          queue.clear();\n        });\n      }); // TODO: Need to find a layout-synchronous way of flushing this\n\n      flushLayout();\n    }\n  };\n}\n\nfunction assignProjectionToSnapshot(child) {\n  child.prevViewportBox = child.projection.target;\n}\n\nvar SharedLayoutContext = React.createContext(createBatcher());\n/**\n * @internal\n */\n\nvar FramerTreeLayoutContext = React.createContext(createBatcher());\n\nfunction isSharedLayout(context) {\n  return !!context.forceUpdate;\n}\n/**\n * This component is responsible for scheduling the measuring of the motion component\n */\n\n\nvar Measure =\n/** @class */\nfunction (_super) {\n  tslib.__extends(Measure, _super);\n\n  function Measure() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * If this is a child of a SyncContext, register the VisualElement with it on mount.\n   */\n\n\n  Measure.prototype.componentDidMount = function () {\n    var _a = this.props,\n        syncLayout = _a.syncLayout,\n        framerSyncLayout = _a.framerSyncLayout,\n        visualElement = _a.visualElement;\n    isSharedLayout(syncLayout) && syncLayout.register(visualElement);\n    isSharedLayout(framerSyncLayout) && framerSyncLayout.register(visualElement);\n    visualElement.onUnmount(function () {\n      if (isSharedLayout(syncLayout)) {\n        syncLayout.remove(visualElement);\n      }\n\n      if (isSharedLayout(framerSyncLayout)) {\n        framerSyncLayout.remove(visualElement);\n      }\n    });\n  };\n  /**\n   * If this is a child of a SyncContext, notify it that it needs to re-render. It will then\n   * handle the snapshotting.\n   *\n   * If it is stand-alone component, add it to the batcher.\n   */\n\n\n  Measure.prototype.getSnapshotBeforeUpdate = function () {\n    var _a = this.props,\n        syncLayout = _a.syncLayout,\n        visualElement = _a.visualElement;\n\n    if (isSharedLayout(syncLayout)) {\n      syncLayout.syncUpdate();\n    } else {\n      snapshotViewportBox(visualElement);\n      syncLayout.add(visualElement);\n    }\n\n    return null;\n  };\n\n  Measure.prototype.componentDidUpdate = function () {\n    var syncLayout = this.props.syncLayout;\n    if (!isSharedLayout(syncLayout)) syncLayout.flush();\n  };\n\n  Measure.prototype.render = function () {\n    return null;\n  };\n\n  return Measure;\n}(React__default['default'].Component);\n\nfunction MeasureContextProvider(props) {\n  var syncLayout = React.useContext(SharedLayoutContext);\n  var framerSyncLayout = React.useContext(FramerTreeLayoutContext);\n  return React__default['default'].createElement(Measure, tslib.__assign({}, props, {\n    syncLayout: syncLayout,\n    framerSyncLayout: framerSyncLayout\n  }));\n}\n\nvar layoutAnimations = {\n  measureLayout: MeasureContextProvider,\n  layoutAnimation: AnimateLayoutContextProvider\n};\n\nvar createProjectionState = function () {\n  return {\n    isEnabled: false,\n    isHydrated: false,\n    isTargetLocked: false,\n    target: axisBox(),\n    targetFinal: axisBox()\n  };\n};\n\nfunction createLayoutState() {\n  return {\n    isHydrated: false,\n    layout: axisBox(),\n    layoutCorrected: axisBox(),\n    treeScale: {\n      x: 1,\n      y: 1\n    },\n    delta: delta(),\n    deltaFinal: delta(),\n    deltaTransform: \"\"\n  };\n}\n\nvar zeroLayout = createLayoutState();\n/**\n * Build a transform style that takes a calculated delta between the element's current\n * space on screen and projects it into the desired space.\n */\n\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n  var x = _a.x,\n      y = _a.y;\n  /**\n   * The translations we use to calculate are always relative to the viewport coordinate space.\n   * But when we apply scales, we also scale the coordinate space of an element and its children.\n   * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n   * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n   */\n\n  var xTranslate = x.translate / treeScale.x;\n  var yTranslate = y.translate / treeScale.y;\n  var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n\n  if (latestTransform) {\n    var rotate = latestTransform.rotate,\n        rotateX = latestTransform.rotateX,\n        rotateY = latestTransform.rotateY;\n    if (rotate) transform += \"rotate(\" + rotate + \") \";\n    if (rotateX) transform += \"rotateX(\" + rotateX + \") \";\n    if (rotateY) transform += \"rotateY(\" + rotateY + \") \";\n  }\n\n  transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n  return !latestTransform && transform === identityProjection ? \"\" : transform;\n}\n/**\n * Take the calculated delta origin and apply it as a transform string.\n */\n\n\nfunction buildLayoutProjectionTransformOrigin(_a) {\n  var deltaFinal = _a.deltaFinal;\n  return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\n\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, {\n  x: 1,\n  y: 1\n});\nvar names = [\"LayoutMeasure\", \"BeforeLayoutMeasure\", \"LayoutUpdate\", \"ViewportBoxUpdate\", \"Update\", \"Render\", \"AnimationComplete\", \"LayoutAnimationComplete\", \"AnimationStart\", \"SetAxisTarget\", \"Unmount\"];\n\nfunction createLifecycles() {\n  var managers = names.map(function () {\n    return new SubscriptionManager();\n  });\n  var propSubscriptions = {};\n  var lifecycles = {\n    clearAllListeners: function () {\n      return managers.forEach(function (manager) {\n        return manager.clear();\n      });\n    },\n    updatePropListeners: function (props) {\n      return names.forEach(function (name) {\n        var _a;\n\n        (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);\n        var on = \"on\" + name;\n        var propListener = props[on];\n\n        if (propListener) {\n          propSubscriptions[name] = lifecycles[on](propListener);\n        }\n      });\n    }\n  };\n  managers.forEach(function (manager, i) {\n    lifecycles[\"on\" + names[i]] = function (handler) {\n      return manager.add(handler);\n    };\n\n    lifecycles[\"notify\" + names[i]] = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return manager.notify.apply(manager, tslib.__spreadArray([], tslib.__read(args)));\n    };\n  });\n  return lifecycles;\n}\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n  var _a;\n\n  for (var key in next) {\n    var nextValue = next[key];\n    var prevValue = prev[key];\n\n    if (isMotionValue(nextValue)) {\n      /**\n       * If this is a motion value found in props or style, we want to add it\n       * to our visual element's motion value map.\n       */\n      element.addValue(key, nextValue);\n    } else if (isMotionValue(prevValue)) {\n      /**\n       * If we're swapping to a new motion value, create a new motion value\n       * from that\n       */\n      element.addValue(key, motionValue(nextValue));\n    } else if (prevValue !== nextValue) {\n      /**\n       * If this is a flat value that has changed, update the motion value\n       * or create one if it doesn't exist. We only want to do this if we're\n       * not handling the value with our animation state.\n       */\n      if (element.hasValue(key)) {\n        var existingValue = element.getValue(key); // TODO: Only update values that aren't being animated or even looked at\n\n        !existingValue.hasAnimated && existingValue.set(nextValue);\n      } else {\n        element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));\n      }\n    }\n  } // Handle removed values\n\n\n  for (var key in prev) {\n    if (next[key] === undefined) element.removeValue(key);\n  }\n\n  return next;\n}\n\nfunction updateLayoutDeltas(_a, _b, treePath, transformOrigin) {\n  var delta = _a.delta,\n      layout = _a.layout,\n      layoutCorrected = _a.layoutCorrected,\n      treeScale = _a.treeScale;\n  var target = _b.target;\n  /**\n   * Reset the corrected box with the latest values from box, as we're then going\n   * to perform mutative operations on it.\n   */\n\n  resetBox(layoutCorrected, layout);\n  /**\n   * Apply all the parent deltas to this box to produce the corrected box. This\n   * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n   */\n\n  applyTreeDeltas(layoutCorrected, treeScale, treePath);\n  /**\n   * Update the delta between the corrected box and the target box before user-set transforms were applied.\n   * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n   * for our layout reprojection, but still allow them to be scaled correctly by the user.\n   * It might be that to simplify this we may want to accept that user-set scale is also corrected\n   * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n   * to allow people to choose whether these styles are corrected based on just the\n   * layout reprojection or the final bounding box.\n   */\n\n  updateBoxDelta(delta, layoutCorrected, target, transformOrigin);\n}\n\nvar FlatTree =\n/** @class */\nfunction () {\n  function FlatTree() {\n    this.children = [];\n    this.isDirty = false;\n  }\n\n  FlatTree.prototype.add = function (child) {\n    addUniqueItem(this.children, child);\n    this.isDirty = true;\n  };\n\n  FlatTree.prototype.remove = function (child) {\n    removeItem(this.children, child);\n    this.isDirty = true;\n  };\n\n  FlatTree.prototype.forEach = function (callback) {\n    this.isDirty && this.children.sort(compareByDepth);\n    this.isDirty = false;\n    this.children.forEach(callback);\n  };\n\n  return FlatTree;\n}();\n\nfunction setCurrentViewportBox(visualElement) {\n  var projectionParent = visualElement.getProjectionParent();\n\n  if (!projectionParent) {\n    visualElement.rebaseProjectionTarget();\n    return;\n  }\n\n  var relativeOffset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\n  eachAxis(function (axis) {\n    visualElement.setProjectionTargetAxis(axis, relativeOffset[axis].min, relativeOffset[axis].max, true);\n  });\n}\n\nvar visualElement = function (_a) {\n  var _b = _a.treeType,\n      treeType = _b === void 0 ? \"\" : _b,\n      build = _a.build,\n      getBaseTarget = _a.getBaseTarget,\n      makeTargetAnimatable = _a.makeTargetAnimatable,\n      measureViewportBox = _a.measureViewportBox,\n      renderInstance = _a.render,\n      readValueFromInstance = _a.readValueFromInstance,\n      resetTransform = _a.resetTransform,\n      restoreTransform = _a.restoreTransform,\n      removeValueFromRenderState = _a.removeValueFromRenderState,\n      sortNodePosition = _a.sortNodePosition,\n      scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n  return function (_a, options) {\n    var parent = _a.parent,\n        props = _a.props,\n        presenceId = _a.presenceId,\n        blockInitialAnimation = _a.blockInitialAnimation,\n        visualState = _a.visualState;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var latestValues = visualState.latestValues,\n        renderState = visualState.renderState;\n    /**\n     * The instance of the render-specific node that will be hydrated by the\n     * exposed React ref. So for example, this visual element can host a\n     * HTMLElement, plain object, or Three.js object. The functions provided\n     * in VisualElementConfig allow us to interface with this instance.\n     */\n\n    var instance;\n    /**\n     * Manages the subscriptions for a visual element's lifecycle, for instance\n     * onRender and onViewportBoxUpdate.\n     */\n\n    var lifecycles = createLifecycles();\n    /**\n     *\n     */\n\n    var projection = createProjectionState();\n    /**\n     * A reference to the nearest projecting parent. This is either\n     * undefined if we haven't looked for the nearest projecting parent,\n     * false if there is no parent performing layout projection, or a reference\n     * to the projecting parent.\n     */\n\n    var projectionParent;\n    /**\n     * This is a reference to the visual state of the \"lead\" visual element.\n     * Usually, this will be this visual element. But if it shares a layoutId\n     * with other visual elements, only one of them will be designated lead by\n     * AnimateSharedLayout. All the other visual elements will take on the visual\n     * appearance of the lead while they crossfade to it.\n     */\n\n    var leadProjection = projection;\n    var leadLatestValues = latestValues;\n    var unsubscribeFromLeadVisualElement;\n    /**\n     * The latest layout measurements and calculated projections. This\n     * is seperate from the target projection data in visualState as\n     * many visual elements might point to the same piece of visualState as\n     * a target, whereas they might each have different layouts and thus\n     * projection calculations needed to project into the same viewport box.\n     */\n\n    var layoutState = createLayoutState();\n    /**\n     *\n     */\n\n    var crossfader;\n    /**\n     * Keep track of whether the viewport box has been updated since the\n     * last time the layout projection was re-calculated.\n     */\n\n    var hasViewportBoxUpdated = false;\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n\n    var values = new Map();\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n\n    var valueSubscriptions = new Map();\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n\n    var prevMotionValues = {};\n    /**\n     * x/y motion values that track the progress of initiated layout\n     * animations.\n     *\n     * TODO: Target for removal\n     */\n\n    var projectionTargetProgress;\n    /**\n     * When values are removed from all animation props we need to search\n     * for a fallback value to animate to. These values are tracked in baseTarget.\n     */\n\n    var baseTarget = tslib.__assign({}, latestValues); // Internal methods ========================\n\n    /**\n     * On mount, this will be hydrated with a callback to disconnect\n     * this visual element from its parent on unmount.\n     */\n\n\n    var removeFromVariantTree;\n    /**\n     *\n     */\n\n    function render() {\n      if (!instance) return;\n\n      if (element.isProjectionReady()) {\n        /**\n         * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n         * This is the final box that we will then project into by calculating a transform delta and\n         * applying it to the corrected box.\n         */\n        applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);\n        /**\n         * Update the delta between the corrected box and the final target box, after\n         * user-set transforms are applied to it. This will be used by the renderer to\n         * create a transform style that will reproject the element from its actual layout\n         * into the desired bounding box.\n         */\n\n        updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);\n      }\n\n      triggerBuild();\n      renderInstance(instance, renderState);\n    }\n\n    function triggerBuild() {\n      var valuesToRender = latestValues;\n\n      if (crossfader && crossfader.isActive()) {\n        var crossfadedValues = crossfader.getCrossfadeState(element);\n        if (crossfadedValues) valuesToRender = crossfadedValues;\n      }\n\n      build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);\n    }\n\n    function update() {\n      lifecycles.notifyUpdate(latestValues);\n    }\n\n    function updateLayoutProjection() {\n      if (!element.isProjectionReady()) return;\n      var delta = layoutState.delta,\n          treeScale = layoutState.treeScale;\n      var prevTreeScaleX = treeScale.x;\n      var prevTreeScaleY = treeScale.y;\n      var prevDeltaTransform = layoutState.deltaTransform;\n      updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);\n      hasViewportBoxUpdated && element.notifyViewportBoxUpdate(leadProjection.target, delta);\n      hasViewportBoxUpdated = false;\n      var deltaTransform = buildLayoutProjectionTransform(delta, treeScale);\n\n      if (deltaTransform !== prevDeltaTransform || // Also compare calculated treeScale, for values that rely on this only for scale correction\n      prevTreeScaleX !== treeScale.x || prevTreeScaleY !== treeScale.y) {\n        element.scheduleRender();\n      }\n\n      layoutState.deltaTransform = deltaTransform;\n    }\n\n    function updateTreeLayoutProjection() {\n      element.layoutTree.forEach(fireUpdateLayoutProjection);\n    }\n    /**\n     *\n     */\n\n\n    function bindToMotionValue(key, value) {\n      var removeOnChange = value.onChange(function (latestValue) {\n        latestValues[key] = latestValue;\n        props.onUpdate && sync__default['default'].update(update, false, true);\n      });\n      var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n      valueSubscriptions.set(key, function () {\n        removeOnChange();\n        removeOnRenderRequest();\n      });\n    }\n    /**\n     * Any motion values that are provided to the element when created\n     * aren't yet bound to the element, as this would technically be impure.\n     * However, we iterate through the motion values and set them to the\n     * initial values for this component.\n     *\n     * TODO: This is impure and we should look at changing this to run on mount.\n     * Doing so will break some tests but this isn't neccessarily a breaking change,\n     * more a reflection of the test.\n     */\n\n\n    var initialMotionValues = scrapeMotionValuesFromProps(props);\n\n    for (var key in initialMotionValues) {\n      var value = initialMotionValues[key];\n\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n      }\n    }\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n\n\n    var isControllingVariants = checkIfControllingVariants(props);\n    var isVariantNode = checkIfVariantNode(props);\n\n    var element = tslib.__assign(tslib.__assign({\n      treeType: treeType,\n\n      /**\n       * This is a mirror of the internal instance prop, which keeps\n       * VisualElement type-compatible with React's RefObject.\n       */\n      current: null,\n\n      /**\n       * The depth of this visual element within the visual element tree.\n       */\n      depth: parent ? parent.depth + 1 : 0,\n      parent: parent,\n      children: new Set(),\n\n      /**\n       * An ancestor path back to the root visual element. This is used\n       * by layout projection to quickly recurse back up the tree.\n       */\n      path: parent ? tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(parent.path)), [parent]) : [],\n      layoutTree: parent ? parent.layoutTree : new FlatTree(),\n\n      /**\n       *\n       */\n      presenceId: presenceId,\n      projection: projection,\n\n      /**\n       * If this component is part of the variant tree, it should track\n       * any children that are also part of the tree. This is essentially\n       * a shadow tree to simplify logic around how to stagger over children.\n       */\n      variantChildren: isVariantNode ? new Set() : undefined,\n\n      /**\n       * Whether this instance is visible. This can be changed imperatively\n       * by AnimateSharedLayout, is analogous to CSS's visibility in that\n       * hidden elements should take up layout, and needs enacting by the configured\n       * render function.\n       */\n      isVisible: undefined,\n\n      /**\n       * Normally, if a component is controlled by a parent's variants, it can\n       * rely on that ancestor to trigger animations further down the tree.\n       * However, if a component is created after its parent is mounted, the parent\n       * won't trigger that mount animation so the child needs to.\n       *\n       * TODO: This might be better replaced with a method isParentMounted\n       */\n      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),\n\n      /**\n       * This can be set by AnimatePresence to force components that mount\n       * at the same time as it to mount as if they have initial={false} set.\n       */\n      blockInitialAnimation: blockInitialAnimation,\n\n      /**\n       * Determine whether this component has mounted yet. This is mostly used\n       * by variant children to determine whether they need to trigger their\n       * own animations on mount.\n       */\n      isMounted: function () {\n        return Boolean(instance);\n      },\n      mount: function (newInstance) {\n        instance = element.current = newInstance;\n        element.pointTo(element);\n\n        if (isVariantNode && parent && !isControllingVariants) {\n          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n        }\n\n        parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n      },\n\n      /**\n       *\n       */\n      unmount: function () {\n        sync.cancelSync.update(update);\n        sync.cancelSync.render(render);\n        sync.cancelSync.preRender(element.updateLayoutProjection);\n        valueSubscriptions.forEach(function (remove) {\n          return remove();\n        });\n        element.stopLayoutAnimation();\n        element.layoutTree.remove(element);\n        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n        parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n        lifecycles.clearAllListeners();\n      },\n\n      /**\n       * Add a child visual element to our set of children.\n       */\n      addVariantChild: function (child) {\n        var _a;\n\n        var closestVariantNode = element.getClosestVariantNode();\n\n        if (closestVariantNode) {\n          (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n          return function () {\n            return closestVariantNode.variantChildren.delete(child);\n          };\n        }\n      },\n      sortNodePosition: function (other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (!sortNodePosition || treeType !== other.treeType) return 0;\n        return sortNodePosition(element.getInstance(), other.getInstance());\n      },\n\n      /**\n       * Returns the closest variant node in the tree starting from\n       * this visual element.\n       */\n      getClosestVariantNode: function () {\n        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n      },\n\n      /**\n       * A method that schedules an update to layout projections throughout\n       * the tree. We inherit from the parent so there's only ever one\n       * job scheduled on the next frame - that of the root visual element.\n       */\n      scheduleUpdateLayoutProjection: parent ? parent.scheduleUpdateLayoutProjection : function () {\n        return sync__default['default'].preRender(element.updateTreeLayoutProjection, false, true);\n      },\n\n      /**\n       * Expose the latest layoutId prop.\n       */\n      getLayoutId: function () {\n        return props.layoutId;\n      },\n\n      /**\n       * Returns the current instance.\n       */\n      getInstance: function () {\n        return instance;\n      },\n\n      /**\n       * Get/set the latest static values.\n       */\n      getStaticValue: function (key) {\n        return latestValues[key];\n      },\n      setStaticValue: function (key, value) {\n        return latestValues[key] = value;\n      },\n\n      /**\n       * Returns the latest motion value state. Currently only used to take\n       * a snapshot of the visual element - perhaps this can return the whole\n       * visual state\n       */\n      getLatestValues: function () {\n        return latestValues;\n      },\n\n      /**\n       * Set the visiblity of the visual element. If it's changed, schedule\n       * a render to reflect these changes.\n       */\n      setVisibility: function (visibility) {\n        if (element.isVisible === visibility) return;\n        element.isVisible = visibility;\n        element.scheduleRender();\n      },\n\n      /**\n       * Make a target animatable by Popmotion. For instance, if we're\n       * trying to animate width from 100px to 100vw we need to measure 100vw\n       * in pixels to determine what we really need to animate to. This is also\n       * pluggable to support Framer's custom value types like Color,\n       * and CSS variables.\n       */\n      makeTargetAnimatable: function (target, canMutate) {\n        if (canMutate === void 0) {\n          canMutate = true;\n        }\n\n        return makeTargetAnimatable(element, target, props, canMutate);\n      },\n      // Motion values ========================\n\n      /**\n       * Add a motion value and bind it to this visual element.\n       */\n      addValue: function (key, value) {\n        // Remove existing value if it exists\n        if (element.hasValue(key)) element.removeValue(key);\n        values.set(key, value);\n        latestValues[key] = value.get();\n        bindToMotionValue(key, value);\n      },\n\n      /**\n       * Remove a motion value and unbind any active subscriptions.\n       */\n      removeValue: function (key) {\n        var _a;\n\n        values.delete(key);\n        (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n        valueSubscriptions.delete(key);\n        delete latestValues[key];\n        removeValueFromRenderState(key, renderState);\n      },\n\n      /**\n       * Check whether we have a motion value for this key\n       */\n      hasValue: function (key) {\n        return values.has(key);\n      },\n\n      /**\n       * Get a motion value for this key. If called with a default\n       * value, we'll create one if none exists.\n       */\n      getValue: function (key, defaultValue) {\n        var value = values.get(key);\n\n        if (value === undefined && defaultValue !== undefined) {\n          value = motionValue(defaultValue);\n          element.addValue(key, value);\n        }\n\n        return value;\n      },\n\n      /**\n       * Iterate over our motion values.\n       */\n      forEachValue: function (callback) {\n        return values.forEach(callback);\n      },\n\n      /**\n       * If we're trying to animate to a previously unencountered value,\n       * we need to check for it in our state and as a last resort read it\n       * directly from the instance (which might have performance implications).\n       */\n      readValue: function (key) {\n        var _a;\n\n        return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options);\n      },\n\n      /**\n       * Set the base target to later animate back to. This is currently\n       * only hydrated on creation and when we first read a value.\n       */\n      setBaseTarget: function (key, value) {\n        baseTarget[key] = value;\n      },\n\n      /**\n       * Find the base target for a value thats been removed from all animation\n       * props.\n       */\n      getBaseTarget: function (key) {\n        if (getBaseTarget) {\n          var target = getBaseTarget(props, key);\n          if (target !== undefined && !isMotionValue(target)) return target;\n        }\n\n        return baseTarget[key];\n      }\n    }, lifecycles), {\n      /**\n       * Build the renderer state based on the latest visual state.\n       */\n      build: function () {\n        triggerBuild();\n        return renderState;\n      },\n\n      /**\n       * Schedule a render on the next animation frame.\n       */\n      scheduleRender: function () {\n        sync__default['default'].render(render, false, true);\n      },\n\n      /**\n       * Synchronously fire render. It's prefered that we batch renders but\n       * in many circumstances, like layout measurement, we need to run this\n       * synchronously. However in those instances other measures should be taken\n       * to batch reads/writes.\n       */\n      syncRender: render,\n\n      /**\n       * Update the provided props. Ensure any newly-added motion values are\n       * added to our map, old ones removed, and listeners updated.\n       */\n      setProps: function (newProps) {\n        props = newProps;\n        lifecycles.updatePropListeners(newProps);\n        prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n      },\n      getProps: function () {\n        return props;\n      },\n      // Variants ==============================\n\n      /**\n       * Returns the variant definition with a given name.\n       */\n      getVariant: function (name) {\n        var _a;\n\n        return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name];\n      },\n\n      /**\n       * Returns the defined default transition on this component.\n       */\n      getDefaultTransition: function () {\n        return props.transition;\n      },\n\n      /**\n       * Used by child variant nodes to get the closest ancestor variant props.\n       */\n      getVariantContext: function (startAtParent) {\n        if (startAtParent === void 0) {\n          startAtParent = false;\n        }\n\n        if (startAtParent) return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n\n        if (!isControllingVariants) {\n          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n\n          if (props.initial !== undefined) {\n            context_1.initial = props.initial;\n          }\n\n          return context_1;\n        }\n\n        var context = {};\n\n        for (var i = 0; i < numVariantProps; i++) {\n          var name_1 = variantProps[i];\n          var prop = props[name_1];\n\n          if (isVariantLabel(prop) || prop === false) {\n            context[name_1] = prop;\n          }\n        }\n\n        return context;\n      },\n      // Layout projection ==============================\n\n      /**\n       * Enable layout projection for this visual element. Won't actually\n       * occur until we also have hydrated layout measurements.\n       */\n      enableLayoutProjection: function () {\n        projection.isEnabled = true;\n        element.layoutTree.add(element);\n      },\n\n      /**\n       * Lock the projection target, for instance when dragging, so\n       * nothing else can try and animate it.\n       */\n      lockProjectionTarget: function () {\n        projection.isTargetLocked = true;\n      },\n      unlockProjectionTarget: function () {\n        element.stopLayoutAnimation();\n        projection.isTargetLocked = false;\n      },\n      getLayoutState: function () {\n        return layoutState;\n      },\n      setCrossfader: function (newCrossfader) {\n        crossfader = newCrossfader;\n      },\n      isProjectionReady: function () {\n        return projection.isEnabled && projection.isHydrated && layoutState.isHydrated;\n      },\n\n      /**\n       * Start a layout animation on a given axis.\n       */\n      startLayoutAnimation: function (axis, transition, isRelative) {\n        if (isRelative === void 0) {\n          isRelative = false;\n        }\n\n        var progress = element.getProjectionAnimationProgress()[axis];\n\n        var _a = isRelative ? projection.relativeTarget[axis] : projection.target[axis],\n            min = _a.min,\n            max = _a.max;\n\n        var length = max - min;\n        progress.clearListeners();\n        progress.set(min);\n        progress.set(min); // Set twice to hard-reset velocity\n\n        progress.onChange(function (v) {\n          element.setProjectionTargetAxis(axis, v, v + length, isRelative);\n        });\n        return element.animateMotionValue(axis, progress, 0, transition);\n      },\n\n      /**\n       * Stop layout animations.\n       */\n      stopLayoutAnimation: function () {\n        eachAxis(function (axis) {\n          return element.getProjectionAnimationProgress()[axis].stop();\n        });\n      },\n\n      /**\n       * Measure the current viewport box with or without transforms.\n       * Only measures axis-aligned boxes, rotate and skew must be manually\n       * removed with a re-render to work.\n       */\n      measureViewportBox: function (withTransform) {\n        if (withTransform === void 0) {\n          withTransform = true;\n        }\n\n        var viewportBox = measureViewportBox(instance, options);\n        if (!withTransform) removeBoxTransforms(viewportBox, latestValues);\n        return viewportBox;\n      },\n\n      /**\n       * Get the motion values tracking the layout animations on each\n       * axis. Lazy init if not already created.\n       */\n      getProjectionAnimationProgress: function () {\n        projectionTargetProgress || (projectionTargetProgress = {\n          x: motionValue(0),\n          y: motionValue(0)\n        });\n        return projectionTargetProgress;\n      },\n\n      /**\n       * Update the projection of a single axis. Schedule an update to\n       * the tree layout projection.\n       */\n      setProjectionTargetAxis: function (axis, min, max, isRelative) {\n        if (isRelative === void 0) {\n          isRelative = false;\n        }\n\n        var target;\n\n        if (isRelative) {\n          if (!projection.relativeTarget) {\n            projection.relativeTarget = axisBox();\n          }\n\n          target = projection.relativeTarget[axis];\n        } else {\n          projection.relativeTarget = undefined;\n          target = projection.target[axis];\n        }\n\n        projection.isHydrated = true;\n        target.min = min;\n        target.max = max; // Flag that we want to fire the onViewportBoxUpdate event handler\n\n        hasViewportBoxUpdated = true;\n        lifecycles.notifySetAxisTarget();\n      },\n\n      /**\n       * Rebase the projection target on top of the provided viewport box\n       * or the measured layout. This ensures that non-animating elements\n       * don't fall out of sync differences in measurements vs projections\n       * after a page scroll or other relayout.\n       */\n      rebaseProjectionTarget: function (force, box) {\n        if (box === void 0) {\n          box = layoutState.layout;\n        }\n\n        var _a = element.getProjectionAnimationProgress(),\n            x = _a.x,\n            y = _a.y;\n\n        var shouldRebase = !projection.relativeTarget && !projection.isTargetLocked && !x.isAnimating() && !y.isAnimating();\n\n        if (force || shouldRebase) {\n          eachAxis(function (axis) {\n            var _a = box[axis],\n                min = _a.min,\n                max = _a.max;\n            element.setProjectionTargetAxis(axis, min, max);\n          });\n        }\n      },\n\n      /**\n       * Notify the visual element that its layout is up-to-date.\n       * Currently Animate.tsx uses this to check whether a layout animation\n       * needs to be performed.\n       */\n      notifyLayoutReady: function (config) {\n        setCurrentViewportBox(element);\n        element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);\n      },\n\n      /**\n       * Temporarily reset the transform of the instance.\n       */\n      resetTransform: function () {\n        return resetTransform(element, instance, props);\n      },\n      restoreTransform: function () {\n        return restoreTransform(instance, renderState);\n      },\n      updateLayoutProjection: updateLayoutProjection,\n      updateTreeLayoutProjection: function () {\n        element.layoutTree.forEach(fireResolveRelativeTargetBox);\n        /**\n         * Schedule the projection updates at the end of the current preRender\n         * step. This will ensure that all layout trees will first resolve\n         * relative projection boxes into viewport boxes, and *then*\n         * update projections.\n         */\n\n        sync__default['default'].preRender(updateTreeLayoutProjection, false, true); // sync.postRender(() => element.scheduleUpdateLayoutProjection())\n      },\n      getProjectionParent: function () {\n        if (projectionParent === undefined) {\n          var foundParent = false; // Search backwards through the tree path\n\n          for (var i = element.path.length - 1; i >= 0; i--) {\n            var ancestor = element.path[i];\n\n            if (ancestor.projection.isEnabled) {\n              foundParent = ancestor;\n              break;\n            }\n          }\n\n          projectionParent = foundParent;\n        }\n\n        return projectionParent;\n      },\n      resolveRelativeTargetBox: function () {\n        var relativeParent = element.getProjectionParent();\n        if (!projection.relativeTarget || !relativeParent) return;\n        calcRelativeBox(projection, relativeParent.projection);\n\n        if (isDraggable(relativeParent)) {\n          var target = projection.target;\n          applyBoxTransforms(target, target, relativeParent.getLatestValues());\n        }\n      },\n      shouldResetTransform: function () {\n        return Boolean(props._layoutResetTransform);\n      },\n\n      /**\n       *\n       */\n      pointTo: function (newLead) {\n        leadProjection = newLead.projection;\n        leadLatestValues = newLead.getLatestValues();\n        /**\n         * Subscribe to lead component's layout animations\n         */\n\n        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n        unsubscribeFromLeadVisualElement = popmotion.pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function () {\n          var _a;\n\n          if (element.isPresent) {\n            element.presence = Presence.Present;\n          } else {\n            (_a = element.layoutSafeToRemove) === null || _a === void 0 ? void 0 : _a.call(element);\n          }\n        }));\n      },\n      // TODO: Clean this up\n      isPresent: true,\n      presence: Presence.Entering\n    });\n\n    return element;\n  };\n};\n\nfunction fireResolveRelativeTargetBox(child) {\n  child.resolveRelativeTargetBox();\n}\n\nfunction fireUpdateLayoutProjection(child) {\n  child.updateLayoutProjection();\n}\n\nvar variantProps = tslib.__spreadArray([\"initial\"], tslib.__read(variantPriorityOrder));\n\nvar numVariantProps = variantProps.length;\nvar positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\"]);\n\nvar isPositionalKey = function (key) {\n  return positionalKeys.has(key);\n};\n\nvar hasPositionalKey = function (target) {\n  return Object.keys(target).some(isPositionalKey);\n};\n\nvar setAndResetVelocity = function (value, to) {\n  // Looks odd but setting it twice doesn't render, it'll just\n  // set both prev and current to the latest value\n  value.set(to, false);\n  value.set(to);\n};\n\nvar isNumOrPxType = function (v) {\n  return v === styleValueTypes.number || v === styleValueTypes.px;\n};\n\nvar BoundingBoxDimension;\n\n(function (BoundingBoxDimension) {\n  BoundingBoxDimension[\"width\"] = \"width\";\n  BoundingBoxDimension[\"height\"] = \"height\";\n  BoundingBoxDimension[\"left\"] = \"left\";\n  BoundingBoxDimension[\"right\"] = \"right\";\n  BoundingBoxDimension[\"top\"] = \"top\";\n  BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\n\nvar getPosFromMatrix = function (matrix, pos) {\n  return parseFloat(matrix.split(\", \")[pos]);\n};\n\nvar getTranslateFromMatrix = function (pos2, pos3) {\n  return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform) return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n\n    if (matrix3d) {\n      return getPosFromMatrix(matrix3d[1], pos3);\n    } else {\n      var matrix = transform.match(/^matrix\\((.+)\\)$/);\n\n      if (matrix) {\n        return getPosFromMatrix(matrix[1], pos2);\n      } else {\n        return 0;\n      }\n    }\n  };\n};\n\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) {\n  return !transformKeys.has(key);\n});\n\nfunction removeNonTranslationalTransform(visualElement) {\n  var removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  }); // Apply changes to element before measurement\n\n  if (removedTransforms.length) visualElement.syncRender();\n  return removedTransforms;\n}\n\nvar positionalValues = {\n  // Dimensions\n  width: function (_a) {\n    var x = _a.x;\n    return x.max - x.min;\n  },\n  height: function (_a) {\n    var y = _a.y;\n    return y.max - y.min;\n  },\n  top: function (_bbox, _a) {\n    var top = _a.top;\n    return parseFloat(top);\n  },\n  left: function (_bbox, _a) {\n    var left = _a.left;\n    return parseFloat(left);\n  },\n  bottom: function (_a, _b) {\n    var y = _a.y;\n    var top = _b.top;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: function (_a, _b) {\n    var x = _a.x;\n    var left = _b.left;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\n\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n  var originBbox = visualElement.measureViewportBox();\n  var element = visualElement.getInstance();\n  var elementComputedStyle = getComputedStyle(element);\n  var display = elementComputedStyle.display,\n      top = elementComputedStyle.top,\n      left = elementComputedStyle.left,\n      bottom = elementComputedStyle.bottom,\n      right = elementComputedStyle.right,\n      transform = elementComputedStyle.transform;\n  var originComputedStyle = {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    transform: transform\n  }; // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  } // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n\n\n  visualElement.syncRender();\n  var targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach(function (key) {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    var value = visualElement.getValue(key);\n    setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\n\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n  if (origin === void 0) {\n    origin = {};\n  }\n\n  if (transitionEnd === void 0) {\n    transitionEnd = {};\n  }\n\n  target = tslib.__assign({}, target);\n  transitionEnd = tslib.__assign({}, transitionEnd);\n  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey); // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n\n  var removedTransformValues = [];\n  var hasAttemptedToRemoveTransformValues = false;\n  var changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    var from = origin[key];\n    var to = target[key];\n    var fromType = findDimensionValueType(from);\n    var toType; // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n\n    if (isKeyframesTarget(to)) {\n      var numKeyframes = to.length;\n\n      for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          heyListen.invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          heyListen.invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        var current = value.get();\n\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === styleValueTypes.px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        // If one or the other value is 0, it's safe to coerce it to the\n        // type of the other without measurement\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n\n  if (changedValueTypeKeys.length) {\n    var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys); // If we removed transform values, reapply them before the next render\n\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(function (_a) {\n        var _b = tslib.__read(_a, 2),\n            key = _b[0],\n            value = _b[1];\n\n        visualElement.getValue(key).set(value);\n      });\n    } // Reapply original values\n\n\n    visualElement.syncRender();\n    return {\n      target: convertedTarget,\n      transitionEnd: transitionEnd\n    };\n  } else {\n    return {\n      target: target,\n      transitionEnd: transitionEnd\n    };\n  }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\n\n\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\n\n\nvar parseDomVariant = function (visualElement, target, origin, transitionEnd) {\n  var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n  target = resolved.target;\n  transitionEnd = resolved.transitionEnd;\n  return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\nfunction getComputedStyle$1(element) {\n  return window.getComputedStyle(element);\n}\n\nvar htmlConfig = {\n  treeType: \"dom\",\n  readValueFromInstance: function (domElement, key) {\n    if (isTransformProp(key)) {\n      var defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      var computedStyle = getComputedStyle$1(domElement);\n      return (isCSSVariable$1(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n    }\n  },\n  sortNodePosition: function (a, b) {\n    /**\n     * compareDocumentPosition returns a bitmask, by using the bitwise &\n     * we're returning true if 2 in that bitmask is set to true. 2 is set\n     * to true if b preceeds a.\n     */\n    return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n  },\n  getBaseTarget: function (props, key) {\n    var _a;\n\n    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n  },\n  measureViewportBox: function (element, _a) {\n    var transformPagePoint = _a.transformPagePoint;\n    return getBoundingBox(element, transformPagePoint);\n  },\n\n  /**\n   * Reset the transform on the current Element. This is called as part\n   * of a batched process across the entire layout tree. To remove this write\n   * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n   * works\n   */\n  resetTransform: function (element, domElement, props) {\n    var transformTemplate = props.transformTemplate;\n    domElement.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\"; // Ensure that whatever happens next, we restore our transform on the next frame\n\n    element.scheduleRender();\n  },\n  restoreTransform: function (instance, mutableState) {\n    instance.style.transform = mutableState.style.transform;\n  },\n  removeValueFromRenderState: function (key, _a) {\n    var vars = _a.vars,\n        style = _a.style;\n    delete vars[key];\n    delete style[key];\n  },\n\n  /**\n   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n   * can be animated by Motion.\n   */\n  makeTargetAnimatable: function (element, _a, _b, isMounted) {\n    var transformValues = _b.transformValues;\n\n    if (isMounted === void 0) {\n      isMounted = true;\n    }\n\n    var transition = _a.transition,\n        transitionEnd = _a.transitionEnd,\n        target = tslib.__rest(_a, [\"transition\", \"transitionEnd\"]);\n\n    var origin = getOrigin(target, transition || {}, element);\n    /**\n     * If Framer has provided a function to convert `Color` etc value types, convert them\n     */\n\n    if (transformValues) {\n      if (transitionEnd) transitionEnd = transformValues(transitionEnd);\n      if (target) target = transformValues(target);\n      if (origin) origin = transformValues(origin);\n    }\n\n    if (isMounted) {\n      checkTargetForNewValues(element, target, origin);\n      var parsed = parseDomVariant(element, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n\n    return tslib.__assign({\n      transition: transition,\n      transitionEnd: transitionEnd\n    }, target);\n  },\n  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n  build: function (element, renderState, latestValues, projection, layoutState, options, props) {\n    if (element.isVisible !== undefined) {\n      renderState.style.visibility = element.isVisible ? \"visible\" : \"hidden\";\n    }\n\n    var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n    buildHTMLStyles(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform ? buildLayoutProjectionTransformOrigin : undefined);\n  },\n  render: renderHTML\n};\nvar htmlVisualElement = visualElement(htmlConfig);\nvar svgVisualElement = visualElement(tslib.__assign(tslib.__assign({}, htmlConfig), {\n  getBaseTarget: function (props, key) {\n    return props[key];\n  },\n  readValueFromInstance: function (domElement, key) {\n    var _a;\n\n    if (isTransformProp(key)) {\n      return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;\n    }\n\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n    return domElement.getAttribute(key);\n  },\n  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n  build: function (_element, renderState, latestValues, projection, layoutState, options, props) {\n    var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n    buildSVGAttrs(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform ? buildLayoutProjectionTransformOrigin : undefined);\n  },\n  render: renderSVG\n}));\n\nvar createDomVisualElement = function (Component, options) {\n  return isSVGComponent(Component) ? svgVisualElement(options, {\n    enableHardwareAcceleration: false\n  }) : htmlVisualElement(options, {\n    enableHardwareAcceleration: true\n  });\n};\n\nvar featureBundle = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, animations), gestureAnimations), drag), layoutAnimations);\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */\n\n\nvar motion = /*@__PURE__*/createMotionProxy(function (Component, config) {\n  return createDomMotionConfig(Component, config, featureBundle, createDomVisualElement);\n});\n/**\n * Create a DOM `motion` component with the provided string. This is primarily intended\n * as a full alternative to `motion` for consumers who have to support environments that don't\n * support `Proxy`.\n *\n * ```javascript\n * import { createDomMotionComponent } from \"framer-motion\"\n *\n * const motion = {\n *   div: createDomMotionComponent('div')\n * }\n * ```\n *\n * @public\n */\n\nfunction createDomMotionComponent(key) {\n  return createMotionComponent(createDomMotionConfig(key, {\n    forwardMotionProps: false\n  }, featureBundle, createDomVisualElement));\n}\n/**\n * @public\n */\n\n\nvar m = createMotionProxy(createDomMotionConfig);\n\nfunction useForceUpdate() {\n  var unloadingRef = React.useRef(false);\n\n  var _a = tslib.__read(React.useState(0), 2),\n      forcedRenderCount = _a[0],\n      setForcedRenderCount = _a[1];\n\n  useUnmountEffect(function () {\n    return unloadingRef.current = true;\n  });\n  return React.useCallback(function () {\n    !unloadingRef.current && setForcedRenderCount(forcedRenderCount + 1);\n  }, [forcedRenderCount]);\n}\n\nvar presenceId = 0;\n\nfunction getPresenceId() {\n  var id = presenceId;\n  presenceId++;\n  return id;\n}\n\nvar PresenceChild = function (_a) {\n  var children = _a.children,\n      initial = _a.initial,\n      isPresent = _a.isPresent,\n      onExitComplete = _a.onExitComplete,\n      custom = _a.custom,\n      presenceAffectsLayout = _a.presenceAffectsLayout;\n  var presenceChildren = useConstant(newChildrenMap);\n  var id = useConstant(getPresenceId);\n  var context = React.useMemo(function () {\n    return {\n      id: id,\n      initial: initial,\n      isPresent: isPresent,\n      custom: custom,\n      onExitComplete: function (childId) {\n        presenceChildren.set(childId, true);\n        var allComplete = true;\n        presenceChildren.forEach(function (isComplete) {\n          if (!isComplete) allComplete = false;\n        });\n        allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n      },\n      register: function (childId) {\n        presenceChildren.set(childId, false);\n        return function () {\n          return presenceChildren.delete(childId);\n        };\n      }\n    };\n  },\n  /**\n   * If the presence of a child affects the layout of the components around it,\n   * we want to make a new context value to ensure they get re-rendered\n   * so they can detect that layout change.\n   */\n  presenceAffectsLayout ? undefined : [isPresent]);\n  React.useMemo(function () {\n    presenceChildren.forEach(function (_, key) {\n      return presenceChildren.set(key, false);\n    });\n  }, [isPresent]);\n  /**\n   * If there's no `motion` components to fire exit animations, we want to remove this\n   * component immediately.\n   */\n\n  React__namespace.useEffect(function () {\n    !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n  }, [isPresent]);\n  return React__namespace.createElement(PresenceContext.Provider, {\n    value: context\n  }, children);\n};\n\nfunction newChildrenMap() {\n  return new Map();\n}\n\nfunction getChildKey(child) {\n  return child.key || \"\";\n}\n\nfunction updateChildLookup(children, allChildren) {\n  var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n  children.forEach(function (child) {\n    var key = getChildKey(child);\n\n    if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n      if (seenChildren.has(key)) {\n        console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n      }\n\n      seenChildren.add(key);\n    }\n\n    allChildren.set(key, child);\n  });\n}\n\nfunction onlyElements(children) {\n  var filtered = []; // We use forEach here instead of map as map mutates the component key by preprending `.$`\n\n  React.Children.forEach(children, function (child) {\n    if (React.isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\n\n\nvar AnimatePresence = function (_a) {\n  var children = _a.children,\n      custom = _a.custom,\n      _b = _a.initial,\n      initial = _b === void 0 ? true : _b,\n      onExitComplete = _a.onExitComplete,\n      exitBeforeEnter = _a.exitBeforeEnter,\n      _c = _a.presenceAffectsLayout,\n      presenceAffectsLayout = _c === void 0 ? true : _c; // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n\n  var forceRender = useForceUpdate();\n  var layoutContext = React.useContext(SharedLayoutContext);\n\n  if (isSharedLayout(layoutContext)) {\n    forceRender = layoutContext.forceUpdate;\n  }\n\n  var isInitialRender = React.useRef(true); // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n\n  var filteredChildren = onlyElements(children); // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n\n  var presentChildren = React.useRef(filteredChildren); // A lookup table to quickly reference components by key\n\n  var allChildren = React.useRef(new Map()).current; // A living record of all currently exiting components.\n\n  var exiting = React.useRef(new Set()).current;\n  updateChildLookup(filteredChildren, allChildren); // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n\n  if (isInitialRender.current) {\n    isInitialRender.current = false;\n    return React__namespace.createElement(React__namespace.Fragment, null, filteredChildren.map(function (child) {\n      return React__namespace.createElement(PresenceChild, {\n        key: getChildKey(child),\n        isPresent: true,\n        initial: initial ? undefined : false,\n        presenceAffectsLayout: presenceAffectsLayout\n      }, child);\n    }));\n  } // If this is a subsequent render, deal with entering and exiting children\n\n\n  var childrenToRender = tslib.__spreadArray([], tslib.__read(filteredChildren)); // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n\n\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey); // Diff the present children with our target children and mark those that are exiting\n\n  var numPresent = presentKeys.length;\n\n  for (var i = 0; i < numPresent; i++) {\n    var key = presentKeys[i];\n\n    if (targetKeys.indexOf(key) === -1) {\n      exiting.add(key);\n    } else {\n      // In case this key has re-entered, remove from the exiting list\n      exiting.delete(key);\n    }\n  } // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n\n\n  if (exitBeforeEnter && exiting.size) {\n    childrenToRender = [];\n  } // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n\n\n  exiting.forEach(function (key) {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    var child = allChildren.get(key);\n    if (!child) return;\n    var insertionIndex = presentKeys.indexOf(key);\n\n    var onExit = function () {\n      allChildren.delete(key);\n      exiting.delete(key); // Remove this child from the present children\n\n      var removeIndex = presentChildren.current.findIndex(function (presentChild) {\n        return presentChild.key === key;\n      });\n      presentChildren.current.splice(removeIndex, 1); // Defer re-rendering until all exiting children have indeed left\n\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren;\n        forceRender();\n        onExitComplete && onExitComplete();\n      }\n    };\n\n    childrenToRender.splice(insertionIndex, 0, React__namespace.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: false,\n      onExitComplete: onExit,\n      custom: custom,\n      presenceAffectsLayout: presenceAffectsLayout\n    }, child));\n  }); // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n\n  childrenToRender = childrenToRender.map(function (child) {\n    var key = child.key;\n    return exiting.has(key) ? child : React__namespace.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true,\n      presenceAffectsLayout: presenceAffectsLayout\n    }, child);\n  });\n  presentChildren.current = childrenToRender;\n\n  if (process.env.NODE_ENV !== \"production\" && exitBeforeEnter && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n  }\n\n  return React__namespace.createElement(React__namespace.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function (child) {\n    return React.cloneElement(child);\n  }));\n};\n/**\n * Animate a single value or a `MotionValue`.\n *\n * The first argument is either a `MotionValue` to animate, or an initial animation value.\n *\n * The second is either a value to animate to, or an array of keyframes to animate through.\n *\n * The third argument can be either tween or spring options, and optional lifecycle methods: `onUpdate`, `onPlay`, `onComplete`, `onRepeat` and `onStop`.\n *\n * Returns `AnimationPlaybackControls`, currently just a `stop` method.\n *\n * ```javascript\n * const x = useMotionValue(0)\n *\n * useEffect(() => {\n *   const controls = animate(x, 100, {\n *     type: \"spring\",\n *     stiffness: 2000,\n *     onComplete: v => {}\n *   })\n *\n *   return controls.stop\n * })\n * ```\n *\n * @public\n */\n\n\nfunction animate(from, to, transition) {\n  if (transition === void 0) {\n    transition = {};\n  }\n\n  var value = isMotionValue(from) ? from : motionValue(from);\n  startAnimation(\"\", value, to, transition);\n  return {\n    stop: function () {\n      return value.stop();\n    }\n  };\n}\n\nfunction createCrossfader() {\n  /**\n   * The current state of the crossfade as a value between 0 and 1\n   */\n  var progress = motionValue(1);\n  var options = {\n    lead: undefined,\n    follow: undefined,\n    crossfadeOpacity: false,\n    preserveFollowOpacity: false\n  };\n\n  var prevOptions = tslib.__assign({}, options);\n\n  var leadState = {};\n  var followState = {};\n  /**\n   *\n   */\n\n  var isActive = false;\n  /**\n   *\n   */\n\n  var finalCrossfadeFrame = null;\n  /**\n   * Framestamp of the last frame we updated values at.\n   */\n\n  var prevUpdate = 0;\n\n  function startCrossfadeAnimation(target, transition) {\n    var lead = options.lead,\n        follow = options.follow;\n    isActive = true;\n    finalCrossfadeFrame = null;\n    var hasUpdated = false;\n\n    var onUpdate = function () {\n      hasUpdated = true;\n      lead && lead.scheduleRender();\n      follow && follow.scheduleRender();\n    };\n\n    var onComplete = function () {\n      isActive = false;\n      /**\n       * If the crossfade animation is no longer active, flag a frame\n       * that we're still allowed to crossfade\n       */\n\n      finalCrossfadeFrame = sync.getFrameData().timestamp;\n    };\n\n    transition = transition && getValueTransition(transition, \"crossfade\");\n    return animate(progress, target, tslib.__assign(tslib.__assign({}, transition), {\n      onUpdate: onUpdate,\n      onComplete: function () {\n        if (!hasUpdated) {\n          progress.set(target);\n          /**\n           * If we never ran an update, for instance if this was an instant transition, fire a\n           * simulated final frame to ensure the crossfade gets applied correctly.\n           */\n\n          sync__default['default'].read(onComplete);\n        } else {\n          onComplete();\n        }\n\n        onUpdate();\n      }\n    }));\n  }\n\n  function updateCrossfade() {\n    var _a, _b;\n    /**\n     * We only want to compute the crossfade once per frame, so we\n     * compare the previous update framestamp with the current frame\n     * and early return if they're the same.\n     */\n\n\n    var timestamp = sync.getFrameData().timestamp;\n    var lead = options.lead,\n        follow = options.follow;\n    if (timestamp === prevUpdate || !lead) return;\n    prevUpdate = timestamp;\n    /**\n     * Merge each component's latest values into our crossfaded state\n     * before crossfading.\n     */\n\n    var latestLeadValues = lead.getLatestValues();\n    Object.assign(leadState, latestLeadValues);\n    var latestFollowValues = follow ? follow.getLatestValues() : options.prevValues;\n    Object.assign(followState, latestFollowValues);\n    var p = progress.get();\n    /**\n     * Crossfade the opacity between the two components. This will result\n     * in a different opacity for each component.\n     */\n\n    var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\n    var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\n\n    if (options.crossfadeOpacity && follow) {\n      leadState.opacity = popmotion.mix(\n      /**\n       * If the follow child has been completely hidden we animate\n       * this opacity from its previous opacity, but otherwise from completely transparent.\n       */\n      follow.isVisible !== false ? 0 : followTargetOpacity, leadTargetOpacity, easeCrossfadeIn(p));\n      followState.opacity = options.preserveFollowOpacity ? followTargetOpacity : popmotion.mix(followTargetOpacity, 0, easeCrossfadeOut(p));\n    } else if (!follow) {\n      leadState.opacity = popmotion.mix(followTargetOpacity, leadTargetOpacity, p);\n    }\n\n    mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\n  }\n\n  return {\n    isActive: function () {\n      return leadState && (isActive || sync.getFrameData().timestamp === finalCrossfadeFrame);\n    },\n    fromLead: function (transition) {\n      return startCrossfadeAnimation(0, transition);\n    },\n    toLead: function (transition) {\n      var initialProgress = 0;\n\n      if (!options.prevValues && !options.follow) {\n        /**\n         * If we're not coming from anywhere, start at the end of the animation.\n         */\n        initialProgress = 1;\n      } else if (prevOptions.lead === options.follow && prevOptions.follow === options.lead) {\n        /**\n         * If we're swapping follow/lead we can reverse the progress\n         */\n        initialProgress = 1 - progress.get();\n      }\n\n      progress.set(initialProgress);\n      return startCrossfadeAnimation(1, transition);\n    },\n    reset: function () {\n      return progress.set(1);\n    },\n    stop: function () {\n      return progress.stop();\n    },\n    getCrossfadeState: function (element) {\n      updateCrossfade();\n\n      if (element === options.lead) {\n        return leadState;\n      } else if (element === options.follow) {\n        return followState;\n      }\n    },\n    setOptions: function (newOptions) {\n      prevOptions = options;\n      options = newOptions;\n      leadState = {};\n      followState = {};\n    },\n    getLatestValues: function () {\n      return leadState;\n    }\n  };\n}\n\nvar easeCrossfadeIn = compress(0, 0.5, popmotion.circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, popmotion.linear);\n\nfunction compress(min, max, easing) {\n  return function (p) {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(popmotion.progress(min, max, p));\n  };\n}\n\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\n\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\n  /**\n   * Mix border radius\n   */\n  for (var i = 0; i < numBorders; i++) {\n    var borderLabel = \"border\" + borders[i] + \"Radius\";\n    var followRadius = getRadius(latestFollowValues, borderLabel);\n    var leadRadius = getRadius(latestLeadValues, borderLabel);\n    if (followRadius === undefined && leadRadius === undefined) continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    /**\n     * Currently we're only crossfading between numerical border radius.\n     * It would be possible to crossfade between percentages for a little\n     * extra bundle size.\n     */\n\n    if (typeof followRadius === \"number\" && typeof leadRadius === \"number\") {\n      var radius = Math.max(popmotion.mix(followRadius, leadRadius, p), 0);\n      leadState[borderLabel] = followState[borderLabel] = radius;\n    }\n  }\n  /**\n   * Mix rotation\n   */\n\n\n  if (latestFollowValues.rotate || latestLeadValues.rotate) {\n    var rotate = popmotion.mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\n    leadState.rotate = followState.rotate = rotate;\n  }\n  /**\n   * We only want to mix the background color if there's a follow element\n   * that we're not crossfading opacity between. For instance with switch\n   * AnimateSharedLayout animations, this helps the illusion of a continuous\n   * element being animated but also cuts down on the number of paints triggered\n   * for elements where opacity is doing that work for us.\n   */\n\n\n  if (!hasFollowElement && latestLeadValues.backgroundColor && latestFollowValues.backgroundColor) {\n    /**\n     * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n     * We could probably create a mixer that runs at the start of the animation but\n     * the idea behind the crossfader is that it runs dynamically between two potentially\n     * changing targets (ie opacity or borderRadius may be animating independently via variants)\n     */\n    leadState.backgroundColor = followState.backgroundColor = popmotion.mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\n  }\n}\n\nfunction getRadius(values, radiusName) {\n  var _a;\n\n  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n\nfunction layoutStack() {\n  var stack = new Set();\n  var state = {\n    leadIsExiting: false\n  };\n\n  var prevState = tslib.__assign({}, state);\n\n  var prevValues;\n  var prevViewportBox;\n  var prevDragCursor;\n  var crossfader = createCrossfader();\n  var needsCrossfadeAnimation = false;\n\n  function getFollowViewportBox() {\n    return state.follow ? state.follow.prevViewportBox : prevViewportBox;\n  }\n\n  function getFollowLayout() {\n    var _a;\n\n    return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\n  }\n\n  return {\n    add: function (element) {\n      element.setCrossfader(crossfader);\n      stack.add(element);\n      /**\n       * Hydrate new element with previous drag position if we have one\n       */\n\n      if (prevDragCursor) element.prevDragCursor = prevDragCursor;\n      if (!state.lead) state.lead = element;\n    },\n    remove: function (element) {\n      stack.delete(element);\n    },\n    getLead: function () {\n      return state.lead;\n    },\n    updateSnapshot: function () {\n      if (!state.lead) return;\n      prevValues = crossfader.isActive() ? crossfader.getLatestValues() : state.lead.getLatestValues();\n      prevViewportBox = state.lead.prevViewportBox;\n      var dragControls = elementDragControls.get(state.lead);\n\n      if (dragControls && dragControls.isDragging) {\n        prevDragCursor = dragControls.cursorProgress;\n      }\n    },\n    clearSnapshot: function () {\n      prevDragCursor = prevViewportBox = undefined;\n    },\n    updateLeadAndFollow: function () {\n      var _a;\n\n      prevState = tslib.__assign({}, state);\n      var lead;\n      var follow;\n      var order = Array.from(stack);\n\n      for (var i = order.length; i--; i >= 0) {\n        var element = order[i];\n        if (lead) follow !== null && follow !== void 0 ? follow : follow = element;\n        lead !== null && lead !== void 0 ? lead : lead = element;\n        if (lead && follow) break;\n      }\n\n      state.lead = lead;\n      state.follow = follow;\n      state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\n      crossfader.setOptions({\n        lead: lead,\n        follow: follow,\n        prevValues: prevValues,\n        crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot)\n      });\n\n      if ( // Don't crossfade if we've just animated back from lead and switched the\n      // old follow to the new lead.\n      state.lead !== prevState.follow && (prevState.lead !== state.lead || prevState.leadIsExiting !== state.leadIsExiting)) {\n        needsCrossfadeAnimation = true;\n      }\n    },\n    animate: function (child, shouldCrossfade) {\n      var _a;\n\n      if (shouldCrossfade === void 0) {\n        shouldCrossfade = false;\n      }\n\n      if (child === state.lead) {\n        if (shouldCrossfade) {\n          /**\n           * Point a lead to itself in case it was previously pointing\n           * to a different visual element\n           */\n          child.pointTo(state.lead);\n        } else {\n          child.setVisibility(true);\n        }\n\n        var config = {};\n        var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();\n\n        if (prevParent) {\n          /**\n           * We'll use this to determine if the element or its layoutId has been reparented.\n           */\n          config.prevParent = prevParent;\n        }\n\n        if (child.presence === Presence.Entering) {\n          config.originBox = getFollowViewportBox();\n        } else if (child.presence === Presence.Exiting) {\n          config.targetBox = getFollowLayout();\n        }\n\n        if (needsCrossfadeAnimation) {\n          needsCrossfadeAnimation = false;\n          var transition = child.getDefaultTransition();\n          child.presence === Presence.Entering ? crossfader.toLead(transition) : crossfader.fromLead(transition);\n        }\n\n        child.notifyLayoutReady(config);\n      } else {\n        if (shouldCrossfade) {\n          state.lead && child.pointTo(state.lead);\n        } else {\n          child.setVisibility(false);\n        }\n      }\n    }\n  };\n}\n\nfunction resetRotate(child) {\n  // If there's no detected rotation values, we can early return without a forced render.\n  var hasRotate = false; // Keep a record of all the values we've reset\n\n  var resetValues = {}; // Check the rotate value of all axes and reset to 0\n\n  for (var i = 0; i < transformAxes.length; i++) {\n    var axis = transformAxes[i];\n    var key = \"rotate\" + axis; // If this rotation doesn't exist as a motion value, then we don't\n    // need to reset it\n\n    if (!child.hasValue(key) || child.getStaticValue(key) === 0) continue;\n    hasRotate = true; // Record the rotation and then temporarily set it to 0\n\n    resetValues[key] = child.getStaticValue(key);\n    child.setStaticValue(key, 0);\n  } // If there's no rotation values, we don't need to do any more.\n\n\n  if (!hasRotate) return; // Force a render of this element to apply the transform with all rotations\n  // set to 0.\n\n  child.syncRender(); // Put back all the values we reset\n\n  for (var key in resetValues) {\n    child.setStaticValue(key, resetValues[key]);\n  } // Schedule a render for the next frame. This ensures we won't visually\n  // see the element with the reset rotate value applied.\n\n\n  child.scheduleRender();\n}\n/**\n * @public\n */\n\n\nvar AnimateSharedLayout =\n/** @class */\nfunction (_super) {\n  tslib.__extends(AnimateSharedLayout, _super);\n\n  function AnimateSharedLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A list of all the children in the shared layout\n     */\n\n\n    _this.children = new Set();\n    /**\n     * As animate components with a defined `layoutId` are added/removed to the tree,\n     * we store them in order. When one is added, it will animate out from the\n     * previous one, and when it's removed, it'll animate to the previous one.\n     */\n\n    _this.stacks = new Map();\n    /**\n     * Track whether the component has mounted. If it hasn't, the presence of added children\n     * are set to Present, whereas if it has they're considered Entering\n     */\n\n    _this.hasMounted = false;\n    /**\n     * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n     * and schedule one.\n     */\n\n    _this.updateScheduled = false;\n    /**\n     * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n     */\n\n    _this.renderScheduled = false;\n    /**\n     * The methods provided to all children in the shared layout tree.\n     */\n\n    _this.syncContext = tslib.__assign(tslib.__assign({}, createBatcher()), {\n      syncUpdate: function (force) {\n        return _this.scheduleUpdate(force);\n      },\n      forceUpdate: function () {\n        // By copying syncContext to itself, when this component re-renders it'll also re-render\n        // all children subscribed to the SharedLayout context.\n        _this.syncContext = tslib.__assign({}, _this.syncContext);\n\n        _this.scheduleUpdate(true);\n      },\n      register: function (child) {\n        return _this.addChild(child);\n      },\n      remove: function (child) {\n        return _this.removeChild(child);\n      }\n    });\n    return _this;\n  }\n\n  AnimateSharedLayout.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n  };\n\n  AnimateSharedLayout.prototype.componentDidUpdate = function () {\n    this.startLayoutAnimation();\n  };\n\n  AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n    this.renderScheduled = true;\n    return true;\n  };\n\n  AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n    var _this = this;\n    /**\n     * Reset update and render scheduled status\n     */\n\n\n    this.renderScheduled = this.updateScheduled = false;\n    var type = this.props.type;\n    /**\n     * Update presence metadata based on the latest AnimatePresence status.\n     * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n     */\n\n    this.children.forEach(function (child) {\n      if (!child.isPresent) {\n        child.presence = Presence.Exiting;\n      } else if (child.presence !== Presence.Entering) {\n        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;\n      }\n    });\n    this.updateStacks();\n    /**\n     * Create a handler which we can use to flush the children animations\n     */\n\n    var handler = {\n      layoutReady: function (child) {\n        if (child.getLayoutId() !== undefined) {\n          var stack = _this.getStack(child);\n\n          stack.animate(child, type === \"crossfade\");\n        } else {\n          child.notifyLayoutReady();\n        }\n      },\n      parent: this.context.visualElement\n    };\n    /**\n     * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n     * This requires some co-ordination across components to stop layout thrashing\n     * and ensure measurements are taken at the correct time.\n     *\n     * Here we use that same mechanism of schedule/flush.\n     */\n\n    this.children.forEach(function (child) {\n      return _this.syncContext.add(child);\n    });\n    this.syncContext.flush(handler);\n    /**\n     * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.clearSnapshot();\n    });\n  };\n\n  AnimateSharedLayout.prototype.updateStacks = function () {\n    this.stacks.forEach(function (stack) {\n      return stack.updateLeadAndFollow();\n    });\n  };\n\n  AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!(force || !this.updateScheduled)) return;\n    /**\n     * Flag we've scheduled an update\n     */\n\n    this.updateScheduled = true;\n    /**\n     * Write: Reset transforms so bounding boxes can be accurately measured.\n     */\n\n    this.children.forEach(function (child) {\n      resetRotate(child);\n      if (child.shouldResetTransform()) child.resetTransform();\n    });\n    /**\n     * Read: Snapshot children\n     */\n\n    this.children.forEach(snapshotViewportBox);\n    /**\n     * Every child keeps a local snapshot, but we also want to record\n     * snapshots of the visible children as, if they're are being removed\n     * in this render, we can still access them.\n     *\n     * TODO: What would be better here is doing a single loop where we\n     * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.updateSnapshot();\n    });\n    /**\n     * Force a rerender by setting state if we aren't already going to render.\n     */\n\n    if (force || !this.renderScheduled) {\n      this.renderScheduled = true;\n      this.forceUpdate();\n    }\n  };\n\n  AnimateSharedLayout.prototype.addChild = function (child) {\n    this.children.add(child);\n    this.addToStack(child);\n    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n  };\n\n  AnimateSharedLayout.prototype.removeChild = function (child) {\n    this.scheduleUpdate();\n    this.children.delete(child);\n    this.removeFromStack(child);\n  };\n\n  AnimateSharedLayout.prototype.addToStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.add(child);\n  };\n\n  AnimateSharedLayout.prototype.removeFromStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.remove(child);\n  };\n  /**\n   * Return a stack of animate children based on the provided layoutId.\n   * Will create a stack if none currently exists with that layoutId.\n   */\n\n\n  AnimateSharedLayout.prototype.getStack = function (child) {\n    var id = child.getLayoutId();\n    if (id === undefined) return; // Create stack if it doesn't already exist\n\n    !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n    return this.stacks.get(id);\n  };\n\n  AnimateSharedLayout.prototype.render = function () {\n    return React__namespace.createElement(SharedLayoutContext.Provider, {\n      value: this.syncContext\n    }, this.props.children);\n  };\n\n  AnimateSharedLayout.contextType = MotionContext;\n  return AnimateSharedLayout;\n}(React__namespace.Component);\n/**\n * `MotionConfig` is used to set configuration options for all children `motion` components.\n *\n * ```jsx\n * import { motion, MotionConfig } from \"framer-motion\"\n *\n * export function App() {\n *   return (\n *     <MotionConfig transition={{ type: \"spring\" }}>\n *       <motion.div animate={{ x: 100 }} />\n *     </MotionConfig>\n *   )\n * }\n * ```\n *\n * @public\n */\n\n\nfunction MotionConfig(_a) {\n  var children = _a.children,\n      config = tslib.__rest(_a, [\"children\"]);\n  /**\n   * Inherit props from any parent MotionConfig components\n   */\n\n\n  config = tslib.__assign(tslib.__assign({}, React.useContext(MotionConfigContext)), config);\n  /**\n   * Don't allow isStatic to change between renders as it affects how many hooks\n   * motion components fire.\n   */\n\n  config.isStatic = useConstant(function () {\n    return config.isStatic;\n  });\n  /**\n   * Creating a new config context object will re-render every `motion` component\n   * every time it renders. So we only want to create a new one sparingly.\n   */\n\n  var transitionDependency = typeof config.transition === \"object\" ? config.transition.toString() : \"\";\n  var context = React.useMemo(function () {\n    return config;\n  }, [transitionDependency, config.transformPagePoint]);\n  return React__namespace.createElement(MotionConfigContext.Provider, {\n    value: context\n  }, children);\n}\n/**\n * Used in conjunction with the `m` component to reduce bundle size.\n *\n * `m` is a version of the `motion` component that only loads functionality\n * critical for the initial render.\n *\n * `LazyMotion` can then be used to either synchronously or asynchronously\n * load animation and gesture support.\n *\n * ```jsx\n * // Synchronous loading\n * import { LazyMotion, m, domAnimations } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={domAnimations}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n *\n * // Asynchronous loading\n * import { LazyMotion, m } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={() => import('./path/to/domAnimations')}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n * ```\n *\n * @public\n */\n\n\nfunction LazyMotion(_a) {\n  var children = _a.children,\n      features = _a.features,\n      _b = _a.strict,\n      strict = _b === void 0 ? false : _b;\n\n  var _c = tslib.__read(React.useState(!isLazyBundle(features)), 2),\n      setIsLoaded = _c[1];\n\n  var loadedRenderer = React.useRef(undefined);\n  /**\n   * If this is a synchronous load, load features immediately\n   */\n\n  if (!isLazyBundle(features)) {\n    var renderer = features.renderer,\n        loadedFeatures = tslib.__rest(features, [\"renderer\"]);\n\n    loadedRenderer.current = renderer;\n    loadFeatures(loadedFeatures);\n  }\n\n  React.useEffect(function () {\n    if (isLazyBundle(features)) {\n      features().then(function (_a) {\n        var renderer = _a.renderer,\n            loadedFeatures = tslib.__rest(_a, [\"renderer\"]);\n\n        loadFeatures(loadedFeatures);\n        loadedRenderer.current = renderer;\n        setIsLoaded(true);\n      });\n    }\n  }, []);\n  return React__namespace.createElement(LazyContext.Provider, {\n    value: {\n      renderer: loadedRenderer.current,\n      strict: strict\n    }\n  }, children);\n}\n\nfunction isLazyBundle(features) {\n  return typeof features === \"function\";\n}\n/**\n * @public\n */\n\n\nvar domAnimation = tslib.__assign(tslib.__assign({\n  renderer: createDomVisualElement\n}, animations), gestureAnimations);\n/**\n * @public\n */\n\n\nvar domMax = tslib.__assign(tslib.__assign(tslib.__assign({}, domAnimation), drag), layoutAnimations);\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * @library\n *\n * ```jsx\n * export function MyComponent() {\n *   const scale = useMotionValue(1)\n *\n *   return <Frame scale={scale} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\n\n\nfunction useMotionValue(initial) {\n  var value = useConstant(function () {\n    return motionValue(initial);\n  });\n  /**\n   * If this motion value is being used in static mode, like on\n   * the Framer canvas, force components to rerender when the motion\n   * value is updated.\n   */\n\n  var isStatic = React.useContext(MotionConfigContext).isStatic;\n\n  if (isStatic) {\n    var _a = tslib.__read(React.useState(initial), 2),\n        setLatest_1 = _a[1];\n\n    React.useEffect(function () {\n      return value.onChange(setLatest_1);\n    }, []);\n  }\n\n  return value;\n}\n\nfunction useOnChange(value, callback) {\n  React.useEffect(function () {\n    if (isMotionValue(value)) return value.onChange(callback);\n  }, [callback]);\n}\n\nfunction useMultiOnChange(values, handler) {\n  React.useEffect(function () {\n    var subscriptions = values.map(function (value) {\n      return value.onChange(handler);\n    });\n    return function () {\n      return subscriptions.forEach(function (unsubscribe) {\n        return unsubscribe();\n      });\n    };\n  });\n}\n\nfunction useCombineMotionValues(values, combineValues) {\n  /**\n   * Initialise the returned motion value. This remains the same between renders.\n   */\n  var value = useMotionValue(combineValues());\n  /**\n   * Create a function that will update the template motion value with the latest values.\n   * This is pre-bound so whenever a motion value updates it can schedule its\n   * execution in Framesync. If it's already been scheduled it won't be fired twice\n   * in a single frame.\n   */\n\n  var updateValue = function () {\n    return value.set(combineValues());\n  };\n  /**\n   * Synchronously update the motion value with the latest values during the render.\n   * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n   */\n\n\n  updateValue();\n  /**\n   * Subscribe to all motion values found within the template. Whenever any of them change,\n   * schedule an update.\n   */\n\n  useMultiOnChange(values, function () {\n    return sync__default['default'].update(updateValue, false, true);\n  });\n  return value;\n}\n/**\n * Combine multiple motion values into a new one using a string template literal.\n *\n * ```jsx\n * import {\n *   motion,\n *   useSpring,\n *   useMotionValue,\n *   useMotionTemplate\n * } from \"framer-motion\"\n *\n * function Component() {\n *   const shadowX = useSpring(0)\n *   const shadowY = useMotionValue(0)\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\n *\n *   return <motion.div style={{ filter: shadow }} />\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useMotionTemplate(fragments) {\n  var values = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    values[_i - 1] = arguments[_i];\n  }\n  /**\n   * Create a function that will build a string from the latest motion values.\n   */\n\n\n  var numFragments = fragments.length;\n\n  function buildValue() {\n    var output = \"\";\n\n    for (var i = 0; i < numFragments; i++) {\n      output += fragments[i];\n      var value = values[i];\n      if (value) output += values[i].get();\n    }\n\n    return output;\n  }\n\n  return useCombineMotionValues(values, buildValue);\n}\n\nvar isCustomValueType = function (v) {\n  return typeof v === \"object\" && v.mix;\n};\n\nvar getMixer = function (v) {\n  return isCustomValueType(v) ? v.mix : undefined;\n};\n\nfunction transform() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  var useImmediate = !Array.isArray(args[0]);\n  var argOffset = useImmediate ? 0 : -1;\n  var inputValue = args[0 + argOffset];\n  var inputRange = args[1 + argOffset];\n  var outputRange = args[2 + argOffset];\n  var options = args[3 + argOffset];\n  var interpolator = popmotion.interpolate(inputRange, outputRange, tslib.__assign({\n    mixer: getMixer(outputRange[0])\n  }, options));\n  return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n  var transformer = typeof inputRangeOrTransformer === \"function\" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);\n  return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], function (_a) {\n    var _b = tslib.__read(_a, 1),\n        latest = _b[0];\n\n    return transformer(latest);\n  });\n}\n\nfunction useListTransform(values, transformer) {\n  var latest = useConstant(function () {\n    return [];\n  });\n  return useCombineMotionValues(values, function () {\n    latest.length = 0;\n    var numValues = values.length;\n\n    for (var i = 0; i < numValues; i++) {\n      latest[i] = values[i].get();\n    }\n\n    return transformer(latest);\n  });\n}\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\n\n\nfunction useSpring(source, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var isStatic = React.useContext(MotionConfigContext).isStatic;\n  var activeSpringAnimation = React.useRef(null);\n  var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n  React.useMemo(function () {\n    return value.attach(function (v, set) {\n      /**\n       * A more hollistic approach to this might be to use isStatic to fix VisualElement animations\n       * at that level, but this will work for now\n       */\n      if (isStatic) return set(v);\n\n      if (activeSpringAnimation.current) {\n        activeSpringAnimation.current.stop();\n      }\n\n      activeSpringAnimation.current = popmotion.animate(tslib.__assign(tslib.__assign({\n        from: value.get(),\n        to: v,\n        velocity: value.getVelocity()\n      }, config), {\n        onUpdate: set\n      }));\n      return value.get();\n    });\n  }, Object.values(config));\n  useOnChange(source, function (v) {\n    return value.set(parseFloat(v));\n  });\n  return value;\n}\n/**\n * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.\n *\n * ```javascript\n * const x = useMotionValue(0)\n * const xVelocity = useVelocity(x)\n * const xAcceleration = useVelocity(xVelocity)\n * ```\n *\n * @public\n */\n\n\nfunction useVelocity(value) {\n  var velocity = useMotionValue(value.getVelocity());\n  React.useEffect(function () {\n    return value.velocityUpdateSubscribers.add(function (newVelocity) {\n      velocity.set(newVelocity);\n    });\n  }, [value]);\n  return velocity;\n}\n\nfunction createScrollMotionValues() {\n  return {\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0)\n  };\n}\n\nfunction setProgress(offset, maxOffset, value) {\n  value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\n}\n\nfunction createScrollUpdater(values, getOffsets) {\n  var update = function () {\n    var _a = getOffsets(),\n        xOffset = _a.xOffset,\n        yOffset = _a.yOffset,\n        xMaxOffset = _a.xMaxOffset,\n        yMaxOffset = _a.yMaxOffset; // Set absolute positions\n\n\n    values.scrollX.set(xOffset);\n    values.scrollY.set(yOffset); // Set 0-1 progress\n\n    setProgress(xOffset, xMaxOffset, values.scrollXProgress);\n    setProgress(yOffset, yMaxOffset, values.scrollYProgress);\n  };\n\n  update();\n  return update;\n}\n\nvar getElementScrollOffsets = function (element) {\n  return function () {\n    return {\n      xOffset: element.scrollLeft,\n      yOffset: element.scrollTop,\n      xMaxOffset: element.scrollWidth - element.offsetWidth,\n      yMaxOffset: element.scrollHeight - element.offsetHeight\n    };\n  };\n};\n/**\n * Returns MotionValues that update when the provided element scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * This element must be set to `overflow: scroll` on either or both axes to report scroll offset.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useElementScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const ref = React.useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <Frame ref={ref}>\n *       <Frame scaleX={scrollYProgress} />\n *     </Frame>\n *   )\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const ref = useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <div ref={ref}>\n *       <motion.div style={{ scaleX: scrollYProgress }} />\n *     </div>\n *   )\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useElementScroll(ref) {\n  var values = useConstant(createScrollMotionValues);\n  useIsomorphicLayoutEffect(function () {\n    var element = ref.current;\n    heyListen.invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\n    if (!element) return;\n    var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\n    var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, {\n      passive: true\n    });\n    var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\n    return function () {\n      scrollListener && scrollListener();\n      resizeListener && resizeListener();\n    };\n  }, []);\n  return values;\n}\n\nvar viewportScrollValues;\n\nfunction getViewportScrollOffsets() {\n  return {\n    xOffset: window.pageXOffset,\n    yOffset: window.pageYOffset,\n    xMaxOffset: document.body.clientWidth - window.innerWidth,\n    yMaxOffset: document.body.clientHeight - window.innerHeight\n  };\n}\n\nvar hasListeners = false;\n\nfunction addEventListeners() {\n  hasListeners = true;\n  if (typeof window === \"undefined\") return;\n  var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\n  addDomEvent(window, \"scroll\", updateScrollValues, {\n    passive: true\n  });\n  addDomEvent(window, \"resize\", updateScrollValues);\n}\n/**\n * Returns MotionValues that update when the viewport scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * **Warning:** Setting `body` or `html` to `height: 100%` or similar will break the `Progress`\n * values as this breaks the browser's capability to accurately measure the page length.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useViewportScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <Frame scaleX={scrollYProgress} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\n * }\n * ```\n *\n * @public\n */\n\n\nfunction useViewportScroll() {\n  /**\n   * Lazy-initialise the viewport scroll values\n   */\n  if (!viewportScrollValues) {\n    viewportScrollValues = createScrollMotionValues();\n  }\n\n  useIsomorphicLayoutEffect(function () {\n    !hasListeners && addEventListeners();\n  }, []);\n  return viewportScrollValues;\n} // Does this device prefer reduced motion? Returns `null` server-side.\n\n\nvar prefersReducedMotion;\n\nfunction initPrefersReducedMotion() {\n  prefersReducedMotion = motionValue(null);\n  if (typeof window === \"undefined\") return;\n\n  if (window.matchMedia) {\n    var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n\n    var setReducedMotionPreferences = function () {\n      return prefersReducedMotion.set(motionMediaQuery_1.matches);\n    };\n\n    motionMediaQuery_1.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.set(false);\n  }\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\n\n\nfunction useReducedMotion() {\n  /**\n   * Lazy initialisation of prefersReducedMotion\n   */\n  !prefersReducedMotion && initPrefersReducedMotion();\n\n  var _a = tslib.__read(React.useState(prefersReducedMotion.get()), 2),\n      shouldReduceMotion = _a[0],\n      setShouldReduceMotion = _a[1];\n\n  useOnChange(prefersReducedMotion, setShouldReduceMotion);\n  return shouldReduceMotion;\n}\n/**\n * @public\n */\n\n\nfunction animationControls() {\n  /**\n   * Track whether the host component has mounted.\n   */\n  var hasMounted = false;\n  /**\n   * Pending animations that are started before a component is mounted.\n   * TODO: Remove this as animations should only run in effects\n   */\n\n  var pendingAnimations = [];\n  /**\n   * A collection of linked component animation controls.\n   */\n\n  var subscribers = new Set();\n  var controls = {\n    subscribe: function (visualElement) {\n      subscribers.add(visualElement);\n      return function () {\n        return void subscribers.delete(visualElement);\n      };\n    },\n    start: function (definition, transitionOverride) {\n      /**\n       * TODO: We only perform this hasMounted check because in Framer we used to\n       * encourage the ability to start an animation within the render phase. This\n       * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n       * we can ditch this.\n       */\n      if (hasMounted) {\n        var animations_1 = [];\n        subscribers.forEach(function (visualElement) {\n          animations_1.push(animateVisualElement(visualElement, definition, {\n            transitionOverride: transitionOverride\n          }));\n        });\n        return Promise.all(animations_1);\n      } else {\n        return new Promise(function (resolve) {\n          pendingAnimations.push({\n            animation: [definition, transitionOverride],\n            resolve: resolve\n          });\n        });\n      }\n    },\n    set: function (definition) {\n      heyListen.invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      return subscribers.forEach(function (visualElement) {\n        setValues(visualElement, definition);\n      });\n    },\n    stop: function () {\n      subscribers.forEach(function (visualElement) {\n        stopAnimation(visualElement);\n      });\n    },\n    mount: function () {\n      hasMounted = true;\n      pendingAnimations.forEach(function (_a) {\n        var animation = _a.animation,\n            resolve = _a.resolve;\n        controls.start.apply(controls, tslib.__spreadArray([], tslib.__read(animation))).then(resolve);\n      });\n      return function () {\n        hasMounted = false;\n        controls.stop();\n      };\n    }\n  };\n  return controls;\n}\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * @library\n *\n * ```jsx\n * import * as React from 'react'\n * import { Frame, useAnimation } from 'framer'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <Frame animate={controls} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\n\n\nfunction useAnimation() {\n  var controls = useConstant(animationControls);\n  React.useEffect(controls.mount, []);\n  return controls;\n}\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import { Frame, useCycle } from \"framer\"\n *\n * export function MyComponent() {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <Frame\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @motion\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\n\n\nfunction useCycle() {\n  var items = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    items[_i] = arguments[_i];\n  }\n\n  var index = React.useRef(0);\n\n  var _a = tslib.__read(React.useState(items[index.current]), 2),\n      item = _a[0],\n      setItem = _a[1];\n\n  return [item, function (next) {\n    index.current = typeof next !== \"number\" ? popmotion.wrap(0, items.length, index.current + 1) : next;\n    setItem(items[index.current]);\n  }];\n}\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\n\n\nvar DragControls =\n/** @class */\nfunction () {\n  function DragControls() {\n    this.componentControls = new Set();\n  }\n  /**\n   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n   *\n   * @internal\n   */\n\n\n  DragControls.prototype.subscribe = function (controls) {\n    var _this = this;\n\n    this.componentControls.add(controls);\n    return function () {\n      return _this.componentControls.delete(controls);\n    };\n  };\n  /**\n   * Start a drag gesture on every `motion` component that has this set of drag controls\n   * passed into it via the `dragControls` prop.\n   *\n   * ```jsx\n   * dragControls.start(e, {\n   *   snapToCursor: true\n   * })\n   * ```\n   *\n   * @param event - PointerEvent\n   * @param options - Options\n   *\n   * @public\n   */\n\n\n  DragControls.prototype.start = function (event, options) {\n    this.componentControls.forEach(function (controls) {\n      controls.start(event.nativeEvent || event, options);\n    });\n  };\n\n  DragControls.prototype.updateConstraints = function (flush) {\n    if (flush === void 0) {\n      flush = true;\n    }\n\n    this.componentControls.forEach(function (controls) {\n      controls.updateConstraints();\n    });\n    flush && flushLayout();\n  };\n\n  return DragControls;\n}();\n\nvar createDragControls = function () {\n  return new DragControls();\n};\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\n\n\nfunction useDragControls() {\n  return useConstant(createDragControls);\n}\n\nvar createObject = function () {\n  return {};\n};\n\nvar stateVisualElement = visualElement({\n  build: function () {},\n  measureViewportBox: axisBox,\n  resetTransform: function () {},\n  restoreTransform: function () {},\n  removeValueFromRenderState: function () {},\n  render: function () {},\n  scrapeMotionValuesFromProps: createObject,\n  readValueFromInstance: function (_state, key, options) {\n    return options.initialState[key] || 0;\n  },\n  makeTargetAnimatable: function (element, _a) {\n    var transition = _a.transition,\n        transitionEnd = _a.transitionEnd,\n        target = tslib.__rest(_a, [\"transition\", \"transitionEnd\"]);\n\n    var origin = getOrigin(target, transition || {}, element);\n    checkTargetForNewValues(element, target, origin);\n    return tslib.__assign({\n      transition: transition,\n      transitionEnd: transitionEnd\n    }, target);\n  }\n});\nvar useVisualState = makeUseVisualState({\n  scrapeMotionValuesFromProps: createObject,\n  createRenderState: createObject\n});\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n * @internal\n */\n\nfunction useAnimatedState(initialState) {\n  var _a = tslib.__read(React.useState(initialState), 2),\n      animationState = _a[0],\n      setAnimationState = _a[1];\n\n  var visualState = useVisualState({}, false);\n  var element = useConstant(function () {\n    return stateVisualElement({\n      props: {},\n      visualState: visualState\n    }, {\n      initialState: initialState\n    });\n  });\n  React.useEffect(function () {\n    element.mount({});\n    return element.unmount();\n  }, []);\n  React.useEffect(function () {\n    element.setProps({\n      onUpdate: function (v) {\n        return setAnimationState(tslib.__assign({}, v));\n      }\n    });\n  });\n  var startAnimation = useConstant(function () {\n    return function (animationDefinition) {\n      return animateVisualElement(element, animationDefinition);\n    };\n  });\n  return [animationState, startAnimation];\n} // Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\n\n\nvar maxScale = 100000;\n\nvar invertScale = function (scale) {\n  return scale > 0.001 ? 1 / scale : maxScale;\n};\n\nvar hasWarned = false;\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * @motion\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @library\n *\n * ```jsx\n * function MyComponent() {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\n * }\n * ```\n *\n * @deprecated\n * @internal\n */\n\nfunction useInvertedScale(scale) {\n  var parentScaleX = useMotionValue(1);\n  var parentScaleY = useMotionValue(1);\n  var visualElement = useVisualElementContext();\n  heyListen.invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n  heyListen.warning(hasWarned, \"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.\");\n  hasWarned = true;\n\n  if (scale) {\n    parentScaleX = scale.scaleX || parentScaleX;\n    parentScaleY = scale.scaleY || parentScaleY;\n  } else if (visualElement) {\n    parentScaleX = visualElement.getValue(\"scaleX\", 1);\n    parentScaleY = visualElement.getValue(\"scaleY\", 1);\n  }\n\n  var scaleX = useTransform(parentScaleX, invertScale);\n  var scaleY = useTransform(parentScaleY, invertScale);\n  return {\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n}\n\nexports.AnimatePresence = AnimatePresence;\nexports.AnimateSharedLayout = AnimateSharedLayout;\nexports.DragControls = DragControls;\nexports.FlatTree = FlatTree;\nexports.FramerTreeLayoutContext = FramerTreeLayoutContext;\nexports.LayoutGroupContext = LayoutGroupContext;\nexports.LazyMotion = LazyMotion;\nexports.MotionConfig = MotionConfig;\nexports.MotionConfigContext = MotionConfigContext;\nexports.MotionValue = MotionValue;\nexports.PresenceContext = PresenceContext;\nexports.SharedLayoutContext = SharedLayoutContext;\nexports.addScaleCorrection = addScaleCorrection;\nexports.animate = animate;\nexports.animateVisualElement = animateVisualElement;\nexports.animationControls = animationControls;\nexports.batchLayout = batchLayout;\nexports.createBatcher = createBatcher;\nexports.createCrossfader = createCrossfader;\nexports.createDomMotionComponent = createDomMotionComponent;\nexports.createMotionComponent = createMotionComponent;\nexports.domAnimation = domAnimation;\nexports.domMax = domMax;\nexports.flushLayout = flushLayout;\nexports.isValidMotionProp = isValidMotionProp;\nexports.m = m;\nexports.motion = motion;\nexports.motionValue = motionValue;\nexports.resolveMotionValue = resolveMotionValue;\nexports.snapshotViewportBox = snapshotViewportBox;\nexports.transform = transform;\nexports.useAnimation = useAnimation;\nexports.useCycle = useCycle;\nexports.useDeprecatedAnimatedState = useAnimatedState;\nexports.useDeprecatedInvertedScale = useInvertedScale;\nexports.useDomEvent = useDomEvent;\nexports.useDragControls = useDragControls;\nexports.useElementScroll = useElementScroll;\nexports.useIsPresent = useIsPresent;\nexports.useMotionTemplate = useMotionTemplate;\nexports.useMotionValue = useMotionValue;\nexports.usePresence = usePresence;\nexports.useReducedMotion = useReducedMotion;\nexports.useSpring = useSpring;\nexports.useTransform = useTransform;\nexports.useVelocity = useVelocity;\nexports.useViewportScroll = useViewportScroll;\nexports.visualElement = visualElement;","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib","require","React","heyListen","styleValueTypes","popmotion","sync","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","React__namespace","React__default","sync__default","createDefinition","propNames","isEnabled","props","some","name","featureDefinitions","measureLayout","animation","exit","drag","focus","hover","tap","pan","layoutAnimation","loadFeatures","features","key","Component","LazyContext","createContext","strict","featureNames","numFeatures","length","useFeatures","visualElement","preloadedFeatures","lazyContext","useContext","process","env","NODE_ENV","invariant","i","name_1","_a","push","createElement","__assign","MotionConfigContext","transformPagePoint","p","isStatic","MotionContext","useVisualElementContext","PresenceContext","useConstant","init","ref","useRef","current","usePresence","context","isPresent","onExitComplete","register","id","useUniqueId","useEffect","safeToRemove","useIsPresent","counter","incrementId","LayoutGroupContext","isBrowser","window","useIsomorphicLayoutEffect","useLayoutEffect","useLayoutId","layoutId","layoutGroupId","undefined","useVisualElement","visualState","createVisualElement","config","parent","presenceContext","visualElementRef","renderer","presenceId","blockInitialAnimation","initial","setProps","isPresenceRoot","syncRender","animationState","animateChanges","notifyUnmount","isRefObject","prototype","hasOwnProperty","call","useMotionRef","externalRef","useCallback","instance","mount","unmount","isVariantLabels","v","Array","isArray","isVariantLabel","getCurrent","forEachValue","getVelocity$1","velocity","getVelocity","resolveVariantFromProps","definition","custom","currentValues","currentVelocity","variants","resolveVariant","getProps","checkIfControllingVariants","animate","start","whileHover","whileDrag","whileTap","whileFocus","checkIfVariantNode","Boolean","getCurrentTreeVariants","inherit","useCreateMotionContext","useMemo","variantLabelsAsDependency","prop","join","createMotionComponent","useRender","useVisualState","MotionComponent","Fragment","Provider","forwardRef","createMotionProxy","createConfig","customMotionComponentConfig","componentCache","Map","Proxy","_target","has","set","lowercaseSVGElements","isSVGComponent","includes","indexOf","test","valueScaleCorrection","addScaleCorrection","correctors","transformAxes","order","transformProps","operationKey","axesKey","sortTransformProps","a","b","transformPropSet","Set","isTransformProp","transformOriginProps","isTransformOriginProp","isForcedMotionValue","layout","isMotionValue","translateAlias","x","y","z","transformPerspective","buildTransform","_b","transformIsDefault","transformTemplate","transform","transformKeys","_c","enableHardwareAcceleration","_d","allowTransformNone","transformString","sort","transformHasZ","numTransformKeys","trim","buildTransformOrigin","originX","originY","originZ","isCSSVariable$1","startsWith","getValueAsType","type","int","number","Math","round","numberValueTypes","borderWidth","px","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","width","maxWidth","height","maxHeight","size","top","right","bottom","left","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","margin","marginTop","marginRight","marginBottom","marginLeft","rotate","degrees","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ","skew","skewX","skewY","distance","translateX","translateY","translateZ","perspective","opacity","alpha","progressPercentage","zIndex","fillOpacity","strokeOpacity","numOctaves","buildHTMLStyles","state","latestValues","projection","layoutState","options","buildProjectionTransform","buildProjectionTransformOrigin","style","vars","transformOrigin","hasTransform","hasTransformOrigin","transformIsNone","valueType","valueAsType","default","isHydrated","correctedValue","applyTo","num","deltaFinal","treeScale","createHtmlRenderState","copyRawValuesOnly","target","source","useInitialMotionValues","useStyle","styleProp","assign","transformValues","useHTMLProps","htmlProps","draggable","userSelect","WebkitUserSelect","WebkitTouchCallout","touchAction","validMotionProps","isValidMotionProp","shouldForward","emotionIsPropValid_1","filterProps","isDom","forwardMotionProps","filteredProps","calcOrigin$1","origin","offset","calcSVGTransformOrigin","dimensions","pxOriginX","pxOriginY","progressToPixels","progress","dashKeys","array","camelKeys","buildSVGPath","attrs","totalLength","spacing","useDashCase","pathLength","pathSpacing","buildSVGAttrs","attrX","attrY","pathOffset","latest","__rest","totalPathLength","createSvgRenderState","useSVGProps","visualProps","rawStyles","createUseRender","useVisualProps","elementProps","CAMEL_CASE_PATTERN","REPLACE_TEMPLATE","camelToDash","str","replace","toLowerCase","renderHTML","element","setProperty","camelCaseAttributes","renderSVG","renderState","setAttribute","scrapeMotionValuesFromProps$1","newValues","scrapeMotionValuesFromProps","targetKey","toUpperCase","isAnimationControls","isKeyframesTarget","isCustomValue","mix","toValue","resolveFinalValueInKeyframes","resolveMotionValue","unwrappedValue","makeState","createRenderState","onMount","makeLatestValues","makeUseVisualState","scrapeMotionValues","values","motionValues","isControllingVariants","isVariantNode","variantToSet","list","resolved","transitionEnd","transition","svgMotionConfig","getBBox","getBoundingClientRect","isPath","getTotalLength","tagName","htmlMotionConfig","createDomMotionConfig","baseConfig","AnimationType","addDomEvent","eventName","handler","addEventListener","removeEventListener","useDomEvent","useFocusGesture","onFocus","setActive","Focus","onBlur","isMouseEvent","event","PointerEvent","pointerType","MouseEvent","isTouchEvent","hasTouches","touches","filterPrimaryPointer","eventHandler","isPrimaryPointer","button","defaultPagePoint","pageX","pageY","pointFromTouch","pointType","primaryTouch","changedTouches","point","pointFromMouse","extractEventInfo","getViewportPointFromEvent","wrapHandler","shouldFilterPrimaryPointer","listener","supportsPointerEvents","onpointerdown","supportsTouchEvents","ontouchstart","supportsMouseEvents","onmousedown","mouseEventNames","pointerdown","pointermove","pointerup","pointercancel","pointerover","pointerout","pointerenter","pointerleave","touchEventNames","getPointerEventName","addPointerEvent","usePointerEvent","createLock","lock","openLock","globalHorizontalLock","globalVerticalLock","getGlobalLock","openHorizontal_1","openVertical_1","isDragActive","openGestureLock","createHoverEvent","isActive","callback","info","Hover","useHoverGesture","onHoverStart","onHoverEnd","isNodeOrChild","child","parentElement","useUnmountEffect","useTapGesture","onTap","onTapStart","onTapCancel","hasPressListeners","isPressing","cancelPointerEndListeners","removePointerEndListener","checkPointerEnd","Tap","onPointerUp","getInstance","onPointerCancel","onPointerDown","pipe","makeRenderlessComponent","hook","gestureAnimations","shallowCompare","next","prev","prevLength","secondsToMilliseconds","seconds","easingLookup","linear","easeIn","easeInOut","easeOut","circIn","circInOut","circOut","backIn","backInOut","backOut","anticipate","bounceIn","bounceInOut","bounceOut","easingDefinitionToFunction","__read","x1","y1","x2","y2","cubicBezier","isEasingArray","ease","isAnimatable","complex","underDampedSpring","stiffness","damping","restDelta","restSpeed","criticallyDampedSpring","to","sqrt","linearTween","duration","keyframes","defaultTransitions","backgroundColor","color","getDefaultTransition","valueKey","transitionFactory","defaultValueTypes","outlineColor","fill","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","filter","WebkitFilter","getDefaultValueType","getAnimatableNone","defaultValueType","isTransitionDefined","when","delay","delayChildren","staggerChildren","staggerDirection","repeat","repeatType","repeatDelay","from","legacyRepeatWarning","convertTransitionToAnimationOptions","times","yoyo","flip","loop","map","warning","getDelayFromTransition","valueTransition","getValueTransition","hydrateKeyframes","__spreadArray","getPopmotionAnimationOptions","getAnimation","onComplete","isTargetAnimatable","isZero","getZeroUnit","isOriginAnimatable","onUpdate","inertia","stop","parseFloat","potentialUnitType","startAnimation","delayTimer","controls","setTimeout","clearTimeout","isNumericalString","addUniqueItem","arr","item","removeItem","index","splice","SubscriptionManager","subscriptions","add","_this","notify","c","numSubscriptions","getSize","clear","isFloat","isNaN","MotionValue","timeDelta","lastUpdated","updateSubscribers","velocityUpdateSubscribers","renderSubscribers","canTrackVelocity","updateAndNotify","render","getFrameData","delta","timestamp","postRender","scheduleVelocityCheck","velocityCheck","hasAnimated","onChange","subscription","clearListeners","onRenderRequest","attach","passiveEffect","getPrevious","velocityPerSecond","Promise","resolve","stopAnimation","then","clearAnimation","isAnimating","destroy","motionValue","testValueType","auto","parse","dimensionValueTypes","percent","vw","vh","findDimensionValueType","find","valueTypes","findValueType","setMotionValue","hasValue","getValue","addValue","setTarget","makeTargetAnimatable","setVariants","variantLabels","reversedLabels","reverse","variant","getVariant","variantChildren","setValues","checkTargetForNewValues","newValueKeys","numNewValues","targetValue","readValue","setBaseTarget","getOriginFromTransition","getOrigin","animateVisualElement","notifyAnimationStart","animations","animateVariant","all","resolvedDefinition","animateTarget","notifyAnimationComplete","transitionOverride","getChildAnimations","forwardDelay","animateChildren","first","last","_e","_f","animationTypeState","getState","valueTarget","shouldBlockAnimation","maxStaggerDuration","generateStaggerDuration","sortByTreeOrder","sortNodePosition","protectedKeys","needsAnimating","shouldBlock","variantPriorityOrder","Animate","Drag","Exit","reversePriorityOrder","numAnimationTypes","animateList","createAnimationState","createState","allAnimatedKeys","isInitialRender","buildResolvedTypeValues","acc","isAnimated","setAnimateFunction","makeAnimator","changedActiveType","getVariantContext","removedKeys","encounteredKeys","removedVariantIndex","Infinity","_loop_1","typeState","propIsVariant","activeDelta","isInherited","manuallyAnimateOnMount","prevProp","shouldAnimateType","variantsHaveChanged","definitionList","resolvedValues","reduce","prevResolvedValues","allKeys","markToAnimate","delete","apply","fallbackAnimation_1","fallbackTarget","getBaseTarget","shouldAnimate","createTypeState","subscribe","PanSession","handlers","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","getPanInfo","history","isPanStarted","isDistancePastThreshold","onStart","onMove","handlePointerMove","transformPoint","buttons","handlePointerUp","update","end","onEnd","onSessionEnd","panInfo","initialInfo","onSessionStart","removeListeners","updateHandlers","cancelSync","subtractPoint","lastDevicePoint","startDevicePoint","timestampedPoint","lastPoint","time","noop","any","convertBoundingBoxToAxisBox","min","max","convertAxisBoxToBoundingBox","transformBoundingBox","topLeft","bottomRight","axisBox","copyAxisBox","box","zeroDelta","translate","originPoint","eachAxis","clampProgress","clamp","isNear","maxDistance","calcLength","axis","calcOrigin","sourceLength","targetLength","updateAxisDelta","updateBoxDelta","defaultOrigin","calcRelativeAxis","relative","calcRelativeBox","parentProjection","relativeTarget","applyConstraints","elastic","calcConstrainedMinPoint","constraints","calcRelativeAxisConstraints","calcRelativeConstraints","layoutBox","calcViewportAxisConstraints","layoutAxis","constraintsAxis","calcViewportConstraints","constraintsBox","calcPositionFromProgress","axisLength","rebaseAxisConstraints","relativeConstraints","defaultElastic","resolveDragElastic","dragElastic","resolveAxisElastic","minLabel","maxLabel","resolvePointElastic","label","getBoundingBox","compareByDepth","depth","isProjecting","shouldResetTransform","collectProjectingAncestors","ancestors","collectProjectingChildren","children","addChild","updateLayoutMeasurement","getLayoutState","notifyBeforeLayoutMeasure","measureViewportBox","layoutCorrected","notifyLayoutMeasure","prevViewportBox","rebaseProjectionTarget","snapshotViewportBox","tweenAxis","calcRelativeOffsetAxis","calcRelativeOffset","checkIfParentHasChanged","prevId","getLayoutId","nextId","isDraggable","_dragX","resetAxis","originAxis","resetBox","originBox","scalePoint","distanceFromOrigin","scaled","applyPointDelta","boxScale","applyAxisDelta","applyBoxDelta","applyAxisTransforms","final","transforms","scaleKey","originKey","axisOrigin","xKeys","yKeys","applyBoxTransforms","finalBox","removePointDelta","removeAxisDelta","removeAxisTransforms","removeBoxTransforms","applyTreeDeltas","treePath","treeLength","node","getLatestValues","convertToRelativeProjection","isLayoutDrag","projectionParent","getProjectionParent","setProjectionTargetAxis","unresolvedJobs","pushJob","stack","job","pointer","batchLayout","flushLayout","reads","writes","setRead","setWrite","numStacks","executeJob","elementDragControls","WeakMap","lastPointerEvent","VisualElementDragControls","isDragging","currentDirection","hasMutatedConstraints","cursorProgress","openGlobalLock","panSession","enableLayoutProjection","originEvent","snapToCursor","stopMotion","initialPoint","cancelLayout","read","write","tree","hasManuallySetCursorOrigin","lockProjectionTarget","resetTransform","restoreTransform","isRelativeDrag","getAxisMotionValue","isExternalDrag","scheduleUpdateLayoutProjection","axisValue","flushSync","preRender","resolveDragConstraints","dragPropagation","onDragStart","dragDirectionLock","getCurrentDirection","onDirectionLock","updateAxis","onDrag","dragConstraints","resolveRefConstraints","onMeasureDragConstraints","constraintsElement","measuredConstraints","userConstraints","cancelDrag","unlockProjectionTarget","animateDragEnd","onDragEnd","shouldDrag","length_1","center","updateAxisMotionValue","updateVisualElementAxis","nextValue","axisLayout","axisProgress","_g","dragMomentum","remainingProps","dragKey","_dragY","dragTransition","isRelative","relativeConstraints_1","targetFinal","momentumAnimations","bounceStiffness","bounceDamping","timeConstant","startAxisValueAnimation","startLayoutAnimation","onDragTransitionEnd","stopLayoutAnimation","currentValue","boxProgress","updateConstraints","onReady","stopPointerListener","dragListener","stopResizeListener","stopLayoutUpdateListener","onLayoutUpdate","prevDragCursor","direction","lockThreshold","abs","useDrag","groupDragControls","dragControls","usePanGesture","onPan","onPanStart","onPanEnd","onPanSessionStart","hasPanEvents","Presence","VisibilityAction","isCSSVariable","cssVariableRegex","parseCSSVariable","match","exec","token","fallback","maxDepth","getVariableValue","getComputedStyle","getPropertyValue","resolveCSSVariables","HTMLElement","pixelsToPercent","pixels","correctBorderRadius","_layoutState","varToken","correctBoxShadow","original","containsCSSVariables","cssVariables","shadow","template","createTransformer","xScale","yScale","averageScale","output","i_1","cssVariable","borderCorrectionDefinition","defaultScaleCorrectors","boxShadow","progressTarget","_super","__extends","arguments","frameTarget","currentAnimationTarget","stopAxisAnimation","isAnimatingTree","targetBox","visibilityAction","shouldStackAnimate","prevParent","prevParentViewportBox","parentLayout","isProvidedCorrectDataForRelativeSharedLayout","boxHasMoved","hasMoved","isTargetLocked","setVisibility","Show","animateAxis","notifyLayoutAnimationComplete","componentDidMount","animateMotionValue","unsubLayoutReady","layoutSafeToRemove","componentWillUnmount","axisIsEqual","layoutProgress","getProjectionAnimationProgress","frame","unsubscribeProgress","layoutTransition","defaultLayoutTransition","AnimateLayoutContextProvider","isZeroBox","zeroAxis","defaultHandler","layoutReady","notifyLayoutReady","createBatcher","queue","flush","allElements","presence","Present","assignProjectionToSnapshot","SharedLayoutContext","FramerTreeLayoutContext","isSharedLayout","forceUpdate","Measure","syncLayout","framerSyncLayout","onUnmount","remove","getSnapshotBeforeUpdate","syncUpdate","componentDidUpdate","MeasureContextProvider","layoutAnimations","createProjectionState","createLayoutState","deltaTransform","zeroLayout","buildLayoutProjectionTransform","latestTransform","xTranslate","yTranslate","identityProjection","buildLayoutProjectionTransformOrigin","names","createLifecycles","managers","propSubscriptions","lifecycles","clearAllListeners","manager","updatePropListeners","on","propListener","args","_i","updateMotionValuesFromProps","prevValue","existingValue","getStaticValue","removeValue","updateLayoutDeltas","FlatTree","isDirty","setCurrentViewportBox","relativeOffset","treeType","build","renderInstance","readValueFromInstance","removeValueFromRenderState","leadProjection","leadLatestValues","unsubscribeFromLeadVisualElement","crossfader","hasViewportBoxUpdated","valueSubscriptions","prevMotionValues","projectionTargetProgress","baseTarget","removeFromVariantTree","isProjectionReady","triggerBuild","valuesToRender","crossfadedValues","getCrossfadeState","notifyUpdate","updateLayoutProjection","prevTreeScaleX","prevTreeScaleY","prevDeltaTransform","path","notifyViewportBoxUpdate","scheduleRender","updateTreeLayoutProjection","layoutTree","fireUpdateLayoutProjection","bindToMotionValue","removeOnChange","latestValue","removeOnRenderRequest","initialMotionValues","isVisible","isMounted","newInstance","pointTo","addVariantChild","closestVariantNode","getClosestVariantNode","other","setStaticValue","visibility","canMutate","defaultValue","newProps","startAtParent","context_1","numVariantProps","variantProps","setCrossfader","newCrossfader","withTransform","viewportBox","notifySetAxisTarget","force","shouldRebase","notifyLayoutUpdate","fireResolveRelativeTargetBox","foundParent","ancestor","resolveRelativeTargetBox","relativeParent","_layoutResetTransform","newLead","onSetAxisTarget","onLayoutAnimationComplete","Entering","positionalKeys","isPositionalKey","hasPositionalKey","setAndResetVelocity","isNumOrPxType","BoundingBoxDimension","getPosFromMatrix","matrix","pos","split","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","nonTranslationalTransformKeys","removeNonTranslationalTransform","removedTransforms","positionalValues","convertChangedValueTypes","changedKeys","originBbox","elementComputedStyle","display","originComputedStyle","targetBbox","checkAndConvertChangedValueTypes","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","fromType","toType","numKeyframes","convertedTarget","unitConversion","parseDomVariant","getComputedStyle$1","htmlConfig","domElement","defaultType","computedStyle","compareDocumentPosition","mutableState","parsed","isProjectionTranform","htmlVisualElement","svgVisualElement","getAttribute","_element","createDomVisualElement","featureBundle","motion","createDomMotionComponent","m","useForceUpdate","unloadingRef","useState","forcedRenderCount","setForcedRenderCount","getPresenceId","PresenceChild","presenceAffectsLayout","presenceChildren","newChildrenMap","childId","allComplete","isComplete","_","getChildKey","updateChildLookup","allChildren","seenChildren","console","warn","onlyElements","filtered","Children","isValidElement","AnimatePresence","exitBeforeEnter","forceRender","layoutContext","filteredChildren","presentChildren","exiting","childrenToRender","presentKeys","targetKeys","numPresent","insertionIndex","onExit","removeIndex","findIndex","presentChild","cloneElement","createCrossfader","lead","follow","crossfadeOpacity","preserveFollowOpacity","prevOptions","leadState","followState","finalCrossfadeFrame","prevUpdate","startCrossfadeAnimation","hasUpdated","updateCrossfade","latestLeadValues","latestFollowValues","prevValues","leadTargetOpacity","followTargetOpacity","easeCrossfadeIn","easeCrossfadeOut","mixValues","fromLead","toLead","initialProgress","reset","setOptions","newOptions","compress","easing","borders","numBorders","hasFollowElement","borderLabel","followRadius","getRadius","leadRadius","mixColor","radiusName","layoutStack","leadIsExiting","prevState","needsCrossfadeAnimation","getFollowViewportBox","getFollowLayout","getLead","updateSnapshot","clearSnapshot","updateLeadAndFollow","Exiting","shouldCrossfade","resetRotate","hasRotate","resetValues","AnimateSharedLayout","stacks","hasMounted","updateScheduled","renderScheduled","syncContext","scheduleUpdate","removeChild","shouldComponentUpdate","updateStacks","getStack","addToStack","removeFromStack","contextType","MotionConfig","transitionDependency","toString","LazyMotion","isLazyBundle","setIsLoaded","loadedRenderer","loadedFeatures","domAnimation","domMax","useMotionValue","setLatest_1","useOnChange","useMultiOnChange","unsubscribe","useCombineMotionValues","combineValues","updateValue","useMotionTemplate","fragments","numFragments","buildValue","isCustomValueType","getMixer","useImmediate","argOffset","inputValue","inputRange","outputRange","interpolator","interpolate","mixer","useTransform","input","inputRangeOrTransformer","transformer","useListTransform","numValues","useSpring","activeSpringAnimation","useVelocity","newVelocity","createScrollMotionValues","scrollX","scrollY","scrollXProgress","scrollYProgress","setProgress","maxOffset","createScrollUpdater","getOffsets","xOffset","yOffset","xMaxOffset","yMaxOffset","getElementScrollOffsets","scrollLeft","scrollTop","scrollWidth","offsetWidth","scrollHeight","offsetHeight","useElementScroll","updateScrollValues","scrollListener","passive","resizeListener","viewportScrollValues","getViewportScrollOffsets","pageXOffset","pageYOffset","document","body","clientWidth","innerWidth","clientHeight","innerHeight","hasListeners","addEventListeners","useViewportScroll","prefersReducedMotion","initPrefersReducedMotion","matchMedia","motionMediaQuery_1","setReducedMotionPreferences","matches","addListener","useReducedMotion","shouldReduceMotion","setShouldReduceMotion","animationControls","pendingAnimations","subscribers","animations_1","useAnimation","useCycle","items","setItem","wrap","DragControls","componentControls","nativeEvent","createDragControls","useDragControls","createObject","stateVisualElement","_state","initialState","useAnimatedState","setAnimationState","animationDefinition","maxScale","invertScale","hasWarned","useInvertedScale","parentScaleX","parentScaleY","useDeprecatedAnimatedState","useDeprecatedInvertedScale"],"sources":["/Users/lavanyagurajada/enguyen/ecommerce/node_modules/framer-motion/dist/framer-motion.cjs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tslib = require('tslib');\nvar React = require('react');\nvar heyListen = require('hey-listen');\nvar styleValueTypes = require('style-value-types');\nvar popmotion = require('popmotion');\nvar sync = require('framesync');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== 'default') {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function () {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n['default'] = e;\n    return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\nvar sync__default = /*#__PURE__*/_interopDefaultLegacy(sync);\n\nvar createDefinition = function (propNames) { return ({\n    isEnabled: function (props) { return propNames.some(function (name) { return !!props[name]; }); },\n}); };\nvar featureDefinitions = {\n    measureLayout: createDefinition([\n        \"layout\",\n        \"layoutId\",\n        \"drag\",\n        \"_layoutResetTransform\",\n    ]),\n    animation: createDefinition([\n        \"animate\",\n        \"exit\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"whileFocus\",\n        \"whileDrag\",\n    ]),\n    exit: createDefinition([\"exit\"]),\n    drag: createDefinition([\"drag\", \"dragControls\"]),\n    focus: createDefinition([\"whileFocus\"]),\n    hover: createDefinition([\"whileHover\", \"onHoverStart\", \"onHoverEnd\"]),\n    tap: createDefinition([\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"]),\n    pan: createDefinition([\n        \"onPan\",\n        \"onPanStart\",\n        \"onPanSessionStart\",\n        \"onPanEnd\",\n    ]),\n    layoutAnimation: createDefinition([\"layout\", \"layoutId\"]),\n};\nfunction loadFeatures(features) {\n    for (var key in features) {\n        var Component = features[key];\n        if (Component !== null)\n            featureDefinitions[key].Component = Component;\n    }\n}\n\nvar LazyContext = React.createContext({ strict: false });\n\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\n/**\n * Load features via renderless components based on the provided MotionProps.\n */\nfunction useFeatures(props, visualElement, preloadedFeatures) {\n    var features = [];\n    var lazyContext = React.useContext(LazyContext);\n    if (!visualElement)\n        return null;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (process.env.NODE_ENV !== \"production\" &&\n        preloadedFeatures &&\n        lazyContext.strict) {\n        heyListen.invariant(false, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n    }\n    for (var i = 0; i < numFeatures; i++) {\n        var name_1 = featureNames[i];\n        var _a = featureDefinitions[name_1], isEnabled = _a.isEnabled, Component = _a.Component;\n        /**\n         * It might be possible in the future to use this moment to\n         * dynamically request functionality. In initial tests this\n         * was producing a lot of duplication amongst bundles.\n         */\n        if (isEnabled(props) && Component) {\n            features.push(React__namespace.createElement(Component, tslib.__assign({ key: name_1 }, props, { visualElement: visualElement })));\n        }\n    }\n    return features;\n}\n\n/**\n * @public\n */\nvar MotionConfigContext = React.createContext({\n    transformPagePoint: function (p) { return p; },\n    isStatic: false,\n});\n\nvar MotionContext = React.createContext({});\nfunction useVisualElementContext() {\n    return React.useContext(MotionContext).visualElement;\n}\n\n/**\n * @public\n */\nvar PresenceContext = React.createContext(null);\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n    var ref = React.useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence() {\n    var context = React.useContext(PresenceContext);\n    if (context === null)\n        return [true, null];\n    var isPresent = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    // Replace with useOpaqueId when released in React\n    var id = useUniqueId();\n    React.useEffect(function () { return register(id); }, []);\n    var safeToRemove = function () { return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id); };\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\nfunction useIsPresent() {\n    return isPresent(React.useContext(PresenceContext));\n}\nfunction isPresent(context) {\n    return context === null ? true : context.isPresent;\n}\nvar counter = 0;\nvar incrementId = function () { return counter++; };\nvar useUniqueId = function () { return useConstant(incrementId); };\n\n/**\n * @internal\n */\nvar LayoutGroupContext = React.createContext(null);\n\nvar isBrowser = typeof window !== \"undefined\";\n\nvar useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;\n\nfunction useLayoutId(_a) {\n    var layoutId = _a.layoutId;\n    var layoutGroupId = React.useContext(LayoutGroupContext);\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + \"-\" + layoutId\n        : layoutId;\n}\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\n    var config = React.useContext(MotionConfigContext);\n    var lazyContext = React.useContext(LazyContext);\n    var parent = useVisualElementContext();\n    var presenceContext = React.useContext(PresenceContext);\n    var layoutId = useLayoutId(props);\n    var visualElementRef = React.useRef(undefined);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    if (!createVisualElement)\n        createVisualElement = lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState: visualState,\n            parent: parent,\n            props: tslib.__assign(tslib.__assign({}, props), { layoutId: layoutId }),\n            presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,\n            blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false,\n        });\n    }\n    var visualElement = visualElementRef.current;\n    useIsomorphicLayoutEffect(function () {\n        if (!visualElement)\n            return;\n        visualElement.setProps(tslib.__assign(tslib.__assign(tslib.__assign({}, config), props), { layoutId: layoutId }));\n        visualElement.isPresent = isPresent(presenceContext);\n        visualElement.isPresenceRoot =\n            !parent || parent.presenceId !== (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id);\n        /**\n         * Fire a render to ensure the latest state is reflected on-screen.\n         */\n        visualElement.syncRender();\n    });\n    React.useEffect(function () {\n        var _a;\n        if (!visualElement)\n            return;\n        /**\n         * In a future refactor we can replace the features-as-components and\n         * have this loop through them all firing \"effect\" listeners\n         */\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();\n    });\n    useIsomorphicLayoutEffect(function () { return function () { return visualElement === null || visualElement === void 0 ? void 0 : visualElement.notifyUnmount(); }; }, []);\n    return visualElement;\n}\n\nfunction isRefObject(ref) {\n    return (typeof ref === \"object\" &&\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\n}\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n    return React.useCallback(function (instance) {\n        var _a;\n        instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));\n        if (visualElement) {\n            instance\n                ? visualElement.mount(instance)\n                : visualElement.unmount();\n        }\n        if (externalRef) {\n            if (typeof externalRef === \"function\") {\n                externalRef(instance);\n            }\n            else if (isRefObject(externalRef)) {\n                externalRef.current = instance;\n            }\n        }\n    }, \n    /**\n     * Only pass a new ref callback to React if we've received a visual element\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */\n    [visualElement]);\n}\n\n/**\n * Decides if the supplied variable is an array of variant labels\n */\nfunction isVariantLabels(v) {\n    return Array.isArray(v);\n}\n/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === \"string\" || isVariantLabels(v);\n}\n/**\n * Creates an object containing the latest state of every MotionValue on a VisualElement\n */\nfunction getCurrent(visualElement) {\n    var current = {};\n    visualElement.forEachValue(function (value, key) { return (current[key] = value.get()); });\n    return current;\n}\n/**\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\n */\nfunction getVelocity$1(visualElement) {\n    var velocity = {};\n    visualElement.forEachValue(function (value, key) { return (velocity[key] = value.getVelocity()); });\n    return velocity;\n}\nfunction resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {\n    var _a;\n    if (currentValues === void 0) { currentValues = {}; }\n    if (currentVelocity === void 0) { currentVelocity = {}; }\n    if (typeof definition === \"string\") {\n        definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];\n    }\n    return typeof definition === \"function\"\n        ? definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity)\n        : definition;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n    var props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));\n}\nfunction checkIfControllingVariants(props) {\n    var _a;\n    return (typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === \"function\" ||\n        isVariantLabel(props.initial) ||\n        isVariantLabel(props.animate) ||\n        isVariantLabel(props.whileHover) ||\n        isVariantLabel(props.whileDrag) ||\n        isVariantLabel(props.whileTap) ||\n        isVariantLabel(props.whileFocus) ||\n        isVariantLabel(props.exit));\n}\nfunction checkIfVariantNode(props) {\n    return Boolean(checkIfControllingVariants(props) || props.variants);\n}\n\nfunction getCurrentTreeVariants(props, context) {\n    if (checkIfControllingVariants(props)) {\n        var initial = props.initial, animate = props.animate;\n        return {\n            initial: initial === false || isVariantLabel(initial)\n                ? initial\n                : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined,\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\n\nfunction useCreateMotionContext(props, isStatic) {\n    var _a = getCurrentTreeVariants(props, React.useContext(MotionContext)), initial = _a.initial, animate = _a.animate;\n    return React.useMemo(function () { return ({ initial: initial, animate: animate }); }, \n    /**\n     * Only break memoisation in static mode\n     */\n    isStatic\n        ? [\n            variantLabelsAsDependency(initial),\n            variantLabelsAsDependency(animate),\n        ]\n        : []);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\nfunction createMotionComponent(_a) {\n    var preloadedFeatures = _a.preloadedFeatures, createVisualElement = _a.createVisualElement, useRender = _a.useRender, useVisualState = _a.useVisualState, Component = _a.Component;\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        /**\n         * If we're rendering in a static environment, we only visually update the component\n         * as a result of a React-rerender rather than interactions or animations. This\n         * means we don't need to load additional memory structures like VisualElement,\n         * or any gesture/animation features.\n         */\n        var isStatic = React.useContext(MotionConfigContext).isStatic;\n        var features = null;\n        /**\n         * Create the tree context. This is memoized and will only trigger renders\n         * when the current tree variant changes in static mode.\n         */\n        var context = useCreateMotionContext(props, isStatic);\n        /**\n         *\n         */\n        var visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, props, createVisualElement);\n            /**\n             * Load Motion gesture and animation features. These are rendered as renderless\n             * components so each feature can optionally make use of React lifecycle methods.\n             *\n             * TODO: The intention is to move these away from a React-centric to a\n             * VisualElement-centric lifecycle scheme.\n             */\n            features = useFeatures(props, context.visualElement, preloadedFeatures);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (React__namespace.createElement(React__namespace.Fragment, null,\n            React__namespace.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)),\n            features));\n    }\n    return React.forwardRef(MotionComponent);\n}\n\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion(Component)\n * ```\n *\n * @public\n */\nfunction createMotionProxy(createConfig) {\n    function custom(Component, customMotionComponentConfig) {\n        if (customMotionComponentConfig === void 0) { customMotionComponentConfig = {}; }\n        return createMotionComponent(createConfig(Component, customMotionComponentConfig));\n    }\n    /**\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n     * Rather than generating them anew every render.\n     */\n    var componentCache = new Map();\n    return new Proxy(custom, {\n        /**\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\n         * DOM component with that name.\n         */\n        get: function (_target, key) {\n            /**\n             * If this element doesn't exist in the component cache, create it and cache.\n             */\n            if (!componentCache.has(key)) {\n                componentCache.set(key, custom(key));\n            }\n            return componentCache.get(key);\n        },\n    });\n}\n\n/**\n * We keep these listed seperately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\nvar lowercaseSVGElements = [\n    \"animate\",\n    \"circle\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"filter\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"rect\",\n    \"stop\",\n    \"svg\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"tspan\",\n    \"use\",\n    \"view\",\n];\n\nfunction isSVGComponent(Component) {\n    if (\n    /**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof Component !== \"string\" ||\n        /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */\n        Component.includes(\"-\")) {\n        return false;\n    }\n    else if (\n    /**\n     * If it's in our list of lowercase SVG tags, it's an SVG component\n     */\n    lowercaseSVGElements.indexOf(Component) > -1 ||\n        /**\n         * If it contains a capital letter, it's an SVG component\n         */\n        /[A-Z]/.test(Component)) {\n        return true;\n    }\n    return false;\n}\n\nvar valueScaleCorrection = {};\n/**\n * @internal\n */\nfunction addScaleCorrection(correctors) {\n    for (var key in correctors) {\n        valueScaleCorrection[key] = correctors[key];\n    }\n}\n\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\nvar transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\n/**\n * Generate a list of every possible transform key.\n */\nvar transformProps = [\"transformPerspective\", \"x\", \"y\", \"z\"];\norder.forEach(function (operationKey) {\n    return transformAxes.forEach(function (axesKey) {\n        return transformProps.push(operationKey + axesKey);\n    });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\nfunction sortTransformProps(a, b) {\n    return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */\nvar transformPropSet = new Set(transformProps);\nfunction isTransformProp(key) {\n    return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\nfunction isTransformOriginProp(key) {\n    return transformOriginProps.has(key);\n}\n\nfunction isForcedMotionValue(key, _a) {\n    var layout = _a.layout, layoutId = _a.layoutId;\n    return (isTransformProp(key) ||\n        isTransformOriginProp(key) ||\n        ((layout || layoutId !== undefined) &&\n            (!!valueScaleCorrection[key] || key === \"opacity\")));\n}\n\nvar isMotionValue = function (value) {\n    return value !== null && typeof value === \"object\" && value.getVelocity;\n};\n\nvar translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\",\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(_a, _b, transformIsDefault, transformTemplate) {\n    var transform = _a.transform, transformKeys = _a.transformKeys;\n    var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;\n    // The transform string we're going to build into.\n    var transformString = \"\";\n    // Transform keys into their default order - this will determine the output order.\n    transformKeys.sort(sortTransformProps);\n    // Track whether the defined transform has a defined z so we don't add a\n    // second to enable hardware acceleration\n    var transformHasZ = false;\n    // Loop over each transform and build them into transformString\n    var numTransformKeys = transformKeys.length;\n    for (var i = 0; i < numTransformKeys; i++) {\n        var key = transformKeys[i];\n        transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n        if (key === \"z\")\n            transformHasZ = true;\n    }\n    if (!transformHasZ && enableHardwareAcceleration) {\n        transformString += \"translateZ(0)\";\n    }\n    else {\n        transformString = transformString.trim();\n    }\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    }\n    else if (allowTransformNone && transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n/**\n * Build a transformOrigin style. Uses the same defaults as the browser for\n * undefined origins.\n */\nfunction buildTransformOrigin(_a) {\n    var _b = _a.originX, originX = _b === void 0 ? \"50%\" : _b, _c = _a.originY, originY = _c === void 0 ? \"50%\" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;\n    return originX + \" \" + originY + \" \" + originZ;\n}\n\n/**\n * Returns true if the provided key is a CSS variable\n */\nfunction isCSSVariable$1(key) {\n    return key.startsWith(\"--\");\n}\n\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nvar getValueAsType = function (value, type) {\n    return type && typeof value === \"number\"\n        ? type.transform(value)\n        : value;\n};\n\nvar int = tslib.__assign(tslib.__assign({}, styleValueTypes.number), { transform: Math.round });\n\nvar numberValueTypes = {\n    // Border props\n    borderWidth: styleValueTypes.px,\n    borderTopWidth: styleValueTypes.px,\n    borderRightWidth: styleValueTypes.px,\n    borderBottomWidth: styleValueTypes.px,\n    borderLeftWidth: styleValueTypes.px,\n    borderRadius: styleValueTypes.px,\n    radius: styleValueTypes.px,\n    borderTopLeftRadius: styleValueTypes.px,\n    borderTopRightRadius: styleValueTypes.px,\n    borderBottomRightRadius: styleValueTypes.px,\n    borderBottomLeftRadius: styleValueTypes.px,\n    // Positioning props\n    width: styleValueTypes.px,\n    maxWidth: styleValueTypes.px,\n    height: styleValueTypes.px,\n    maxHeight: styleValueTypes.px,\n    size: styleValueTypes.px,\n    top: styleValueTypes.px,\n    right: styleValueTypes.px,\n    bottom: styleValueTypes.px,\n    left: styleValueTypes.px,\n    // Spacing props\n    padding: styleValueTypes.px,\n    paddingTop: styleValueTypes.px,\n    paddingRight: styleValueTypes.px,\n    paddingBottom: styleValueTypes.px,\n    paddingLeft: styleValueTypes.px,\n    margin: styleValueTypes.px,\n    marginTop: styleValueTypes.px,\n    marginRight: styleValueTypes.px,\n    marginBottom: styleValueTypes.px,\n    marginLeft: styleValueTypes.px,\n    // Transform props\n    rotate: styleValueTypes.degrees,\n    rotateX: styleValueTypes.degrees,\n    rotateY: styleValueTypes.degrees,\n    rotateZ: styleValueTypes.degrees,\n    scale: styleValueTypes.scale,\n    scaleX: styleValueTypes.scale,\n    scaleY: styleValueTypes.scale,\n    scaleZ: styleValueTypes.scale,\n    skew: styleValueTypes.degrees,\n    skewX: styleValueTypes.degrees,\n    skewY: styleValueTypes.degrees,\n    distance: styleValueTypes.px,\n    translateX: styleValueTypes.px,\n    translateY: styleValueTypes.px,\n    translateZ: styleValueTypes.px,\n    x: styleValueTypes.px,\n    y: styleValueTypes.px,\n    z: styleValueTypes.px,\n    perspective: styleValueTypes.px,\n    transformPerspective: styleValueTypes.px,\n    opacity: styleValueTypes.alpha,\n    originX: styleValueTypes.progressPercentage,\n    originY: styleValueTypes.progressPercentage,\n    originZ: styleValueTypes.px,\n    // Misc\n    zIndex: int,\n    // SVG\n    fillOpacity: styleValueTypes.alpha,\n    strokeOpacity: styleValueTypes.alpha,\n    numOctaves: int,\n};\n\nfunction buildHTMLStyles(state, latestValues, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\n    var _a;\n    var style = state.style, vars = state.vars, transform = state.transform, transformKeys = state.transformKeys, transformOrigin = state.transformOrigin;\n    // Empty the transformKeys array. As we're throwing out refs to its items\n    // this might not be as cheap as suspected. Maybe using the array as a buffer\n    // with a manual incrementation would be better.\n    transformKeys.length = 0;\n    // Track whether we encounter any transform or transformOrigin values.\n    var hasTransform = false;\n    var hasTransformOrigin = false;\n    // Does the calculated transform essentially equal \"none\"?\n    var transformIsNone = true;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept seperately for further processing.\n     */\n    for (var key in latestValues) {\n        var value = latestValues[key];\n        /**\n         * If this is a CSS variable we don't do any further processing.\n         */\n        if (isCSSVariable$1(key)) {\n            vars[key] = value;\n            continue;\n        }\n        // Convert the value to its default value type, ie 0 -> \"0px\"\n        var valueType = numberValueTypes[key];\n        var valueAsType = getValueAsType(value, valueType);\n        if (isTransformProp(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            transform[key] = valueAsType;\n            transformKeys.push(key);\n            // If we already know we have a non-default transform, early return\n            if (!transformIsNone)\n                continue;\n            // Otherwise check to see if this is a default transform\n            if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0))\n                transformIsNone = false;\n        }\n        else if (isTransformOriginProp(key)) {\n            transformOrigin[key] = valueAsType;\n            // If this is a transform origin, flag and enable further transform-origin processing\n            hasTransformOrigin = true;\n        }\n        else {\n            /**\n             * If layout projection is on, and we need to perform scale correction for this\n             * value type, perform it.\n             */\n            if ((projection === null || projection === void 0 ? void 0 : projection.isHydrated) &&\n                (layoutState === null || layoutState === void 0 ? void 0 : layoutState.isHydrated) &&\n                valueScaleCorrection[key]) {\n                var correctedValue = valueScaleCorrection[key].process(value, layoutState, projection);\n                /**\n                 * Scale-correctable values can define a number of other values to break\n                 * down into. For instance borderRadius needs applying to borderBottomLeftRadius etc\n                 */\n                var applyTo = valueScaleCorrection[key].applyTo;\n                if (applyTo) {\n                    var num = applyTo.length;\n                    for (var i = 0; i < num; i++) {\n                        style[applyTo[i]] = correctedValue;\n                    }\n                }\n                else {\n                    style[key] = correctedValue;\n                }\n            }\n            else {\n                style[key] = valueAsType;\n            }\n        }\n    }\n    if (layoutState &&\n        projection &&\n        buildProjectionTransform &&\n        buildProjectionTransformOrigin) {\n        style.transform = buildProjectionTransform(layoutState.deltaFinal, layoutState.treeScale, hasTransform ? transform : undefined);\n        if (transformTemplate) {\n            style.transform = transformTemplate(transform, style.transform);\n        }\n        style.transformOrigin = buildProjectionTransformOrigin(layoutState);\n    }\n    else {\n        if (hasTransform) {\n            style.transform = buildTransform(state, options, transformIsNone, transformTemplate);\n        }\n        if (hasTransformOrigin) {\n            style.transformOrigin = buildTransformOrigin(transformOrigin);\n        }\n    }\n}\n\nvar createHtmlRenderState = function () { return ({\n    style: {},\n    transform: {},\n    transformKeys: [],\n    transformOrigin: {},\n    vars: {},\n}); };\n\nfunction copyRawValuesOnly(target, source, props) {\n    for (var key in source) {\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues(_a, visualState, isStatic) {\n    var transformTemplate = _a.transformTemplate;\n    return React.useMemo(function () {\n        var state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, undefined, undefined, { enableHardwareAcceleration: !isStatic }, transformTemplate);\n        var vars = state.vars, style = state.style;\n        return tslib.__assign(tslib.__assign({}, vars), style);\n    }, [visualState]);\n}\nfunction useStyle(props, visualState, isStatic) {\n    var styleProp = props.style || {};\n    var style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */\n    copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n    if (props.transformValues) {\n        style = props.transformValues(style);\n    }\n    return style;\n}\nfunction useHTMLProps(props, visualState, isStatic) {\n    // The `any` isn't ideal but it is the type of createElement props argument\n    var htmlProps = {};\n    var style = useStyle(props, visualState, isStatic);\n    if (Boolean(props.drag)) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout =\n            \"none\";\n        // Disable scrolling on the draggable direction\n        style.touchAction =\n            props.drag === true\n                ? \"none\"\n                : \"pan-\" + (props.drag === \"x\" ? \"y\" : \"x\");\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n\n/**\n * A list of all valid MotionProps.\n *\n * @internalremarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\nvar validMotionProps = new Set([\n    \"initial\",\n    \"animate\",\n    \"exit\",\n    \"style\",\n    \"variants\",\n    \"transition\",\n    \"transformTemplate\",\n    \"transformValues\",\n    \"custom\",\n    \"inherit\",\n    \"layout\",\n    \"layoutId\",\n    \"_layoutResetTransform\",\n    \"onLayoutAnimationComplete\",\n    \"onViewportBoxUpdate\",\n    \"onLayoutMeasure\",\n    \"onBeforeLayoutMeasure\",\n    \"onAnimationStart\",\n    \"onAnimationComplete\",\n    \"onUpdate\",\n    \"onDragStart\",\n    \"onDrag\",\n    \"onDragEnd\",\n    \"onMeasureDragConstraints\",\n    \"onDirectionLock\",\n    \"onDragTransitionEnd\",\n    \"drag\",\n    \"dragControls\",\n    \"dragListener\",\n    \"dragConstraints\",\n    \"dragDirectionLock\",\n    \"_dragX\",\n    \"_dragY\",\n    \"dragElastic\",\n    \"dragMomentum\",\n    \"dragPropagation\",\n    \"dragTransition\",\n    \"whileDrag\",\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanEnd\",\n    \"onPanSessionStart\",\n    \"onTap\",\n    \"onTapStart\",\n    \"onTapCancel\",\n    \"onHoverStart\",\n    \"onHoverEnd\",\n    \"whileFocus\",\n    \"whileTap\",\n    \"whileHover\",\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n    return validMotionProps.has(key);\n}\n\nvar shouldForward = function (key) { return !isValidMotionProp(key); };\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\ntry {\n    var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\").default;\n    shouldForward = function (key) {\n        // Handle events explicitly as Emotion validates them all as true\n        if (key.startsWith(\"on\")) {\n            return !isValidMotionProp(key);\n        }\n        else {\n            return emotionIsPropValid_1(key);\n        }\n    };\n}\ncatch (_a) {\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n    var filteredProps = {};\n    for (var key in props) {\n        if (shouldForward(key) ||\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\n            (!isDom && !isValidMotionProp(key))) {\n            filteredProps[key] = props[key];\n        }\n    }\n    return filteredProps;\n}\n\nfunction calcOrigin$1(origin, offset, size) {\n    return typeof origin === \"string\"\n        ? origin\n        : styleValueTypes.px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n    var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\n    var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\n    return pxOriginX + \" \" + pxOriginY;\n}\n\n// Convert a progress 0-1 to a pixels value based on the provided length\nvar progressToPixels = function (progress, length) {\n    return styleValueTypes.px.transform(progress * length);\n};\nvar dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n};\nvar camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\n    if (spacing === void 0) { spacing = 1; }\n    if (offset === void 0) { offset = 0; }\n    if (useDashCase === void 0) { useDashCase = true; }\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    var keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = progressToPixels(-offset, totalLength);\n    // Build the dash array\n    var pathLength = progressToPixels(length, totalLength);\n    var pathSpacing = progressToPixels(spacing, totalLength);\n    attrs[keys.array] = pathLength + \" \" + pathSpacing;\n}\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, _a, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\n    var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, \n    // This is object creation, which we try to avoid per-frame.\n    latest = tslib.__rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n    buildHTMLStyles(state, latest, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin);\n    state.attrs = state.style;\n    state.style = {};\n    var attrs = state.attrs, style = state.style, dimensions = state.dimensions, totalPathLength = state.totalPathLength;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        if (dimensions)\n            style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions &&\n        (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Treat x/y not as shortcuts but as actual attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    // Build SVG path if one has been measured\n    if (totalPathLength !== undefined && pathLength !== undefined) {\n        buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\nvar createSvgRenderState = function () { return (tslib.__assign(tslib.__assign({}, createHtmlRenderState()), { attrs: {} })); };\n\nfunction useSVGProps(props, visualState) {\n    var visualProps = React.useMemo(function () {\n        var state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, undefined, undefined, { enableHardwareAcceleration: false }, props.transformTemplate);\n        return tslib.__assign(tslib.__assign({}, state.attrs), { style: tslib.__assign({}, state.style) });\n    }, [visualState]);\n    if (props.style) {\n        var rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = tslib.__assign(tslib.__assign({}, rawStyles), visualProps.style);\n    }\n    return visualProps;\n}\n\nfunction createUseRender(forwardMotionProps) {\n    if (forwardMotionProps === void 0) { forwardMotionProps = false; }\n    var useRender = function (Component, props, ref, _a, isStatic) {\n        var latestValues = _a.latestValues;\n        var useVisualProps = isSVGComponent(Component)\n            ? useSVGProps\n            : useHTMLProps;\n        var visualProps = useVisualProps(props, latestValues, isStatic);\n        var filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n        var elementProps = tslib.__assign(tslib.__assign(tslib.__assign({}, filteredProps), visualProps), { ref: ref });\n        return React.createElement(Component, elementProps);\n    };\n    return useRender;\n}\n\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\n * Convert camelCase to dash-case properties.\n */\nvar camelToDash = function (str) {\n    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n\nfunction renderHTML(element, _a) {\n    var style = _a.style, vars = _a.vars;\n    // Directly assign style into the Element's style prop. In tests Object.assign is the\n    // fastest way to assign styles.\n    Object.assign(element.style, style);\n    // Loop over any CSS variables and assign those.\n    for (var key in vars) {\n        element.style.setProperty(key, vars[key]);\n    }\n}\n\n/**\n * A set of attribute names that are always read/written as camel case.\n */\nvar camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n    \"viewBox\",\n    \"gradientTransform\",\n]);\n\nfunction renderSVG(element, renderState) {\n    renderHTML(element, renderState);\n    for (var key in renderState.attrs) {\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\n\nfunction scrapeMotionValuesFromProps$1(props) {\n    var style = props.style;\n    var newValues = {};\n    for (var key in style) {\n        if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\nfunction scrapeMotionValuesFromProps(props) {\n    var newValues = scrapeMotionValuesFromProps$1(props);\n    for (var key in props) {\n        if (isMotionValue(props[key])) {\n            var targetKey = key === \"x\" || key === \"y\" ? \"attr\" + key.toUpperCase() : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\nfunction isAnimationControls(v) {\n    return typeof v === \"object\" && typeof v.start === \"function\";\n}\n\nvar isKeyframesTarget = function (v) {\n    return Array.isArray(v);\n};\n\nvar isCustomValue = function (v) {\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = function (v) {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n *\n * @internal\n */\nfunction resolveMotionValue(value) {\n    var unwrappedValue = isMotionValue(value) ? value.get() : value;\n    return isCustomValue(unwrappedValue)\n        ? unwrappedValue.toValue()\n        : unwrappedValue;\n}\n\nfunction makeState(_a, props, context, presenceContext) {\n    var scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps, createRenderState = _a.createRenderState, onMount = _a.onMount;\n    var state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    if (onMount) {\n        state.mount = function (instance) { return onMount(props, instance, state); };\n    }\n    return state;\n}\nvar makeUseVisualState = function (config) { return function (props, isStatic) {\n    var context = React.useContext(MotionContext);\n    var presenceContext = React.useContext(PresenceContext);\n    return isStatic\n        ? makeState(config, props, context, presenceContext)\n        : useConstant(function () { return makeState(config, props, context, presenceContext); });\n}; };\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    var values = {};\n    var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;\n    var motionValues = scrapeMotionValues(props);\n    for (var key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    var initial = props.initial, animate = props.animate;\n    var isControllingVariants = checkIfControllingVariants(props);\n    var isVariantNode = checkIfVariantNode(props);\n    if (context &&\n        isVariantNode &&\n        !isControllingVariants &&\n        props.inherit !== false) {\n        initial !== null && initial !== void 0 ? initial : (initial = context.initial);\n        animate !== null && animate !== void 0 ? animate : (animate = context.animate);\n    }\n    var variantToSet = blockInitialAnimation || initial === false ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== \"boolean\" &&\n        !isAnimationControls(variantToSet)) {\n        var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n        list.forEach(function (definition) {\n            var resolved = resolveVariantFromProps(props, definition);\n            if (!resolved)\n                return;\n            var transitionEnd = resolved.transitionEnd; resolved.transition; var target = tslib.__rest(resolved, [\"transitionEnd\", \"transition\"]);\n            for (var key in target)\n                values[key] = target[key];\n            for (var key in transitionEnd)\n                values[key] = transitionEnd[key];\n        });\n    }\n    return values;\n}\n\nvar svgMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n        createRenderState: createSvgRenderState,\n        onMount: function (props, instance, _a) {\n            var renderState = _a.renderState, latestValues = _a.latestValues;\n            try {\n                renderState.dimensions =\n                    typeof instance.getBBox ===\n                        \"function\"\n                        ? instance.getBBox()\n                        : instance.getBoundingClientRect();\n            }\n            catch (e) {\n                // Most likely trying to measure an unrendered element under Firefox\n                renderState.dimensions = {\n                    x: 0,\n                    y: 0,\n                    width: 0,\n                    height: 0,\n                };\n            }\n            if (isPath(instance)) {\n                renderState.totalPathLength = instance.getTotalLength();\n            }\n            buildSVGAttrs(renderState, latestValues, undefined, undefined, { enableHardwareAcceleration: false }, props.transformTemplate);\n            // TODO: Replace with direct assignment\n            renderSVG(instance, renderState);\n        },\n    }),\n};\nfunction isPath(element) {\n    return element.tagName === \"path\";\n}\n\nvar htmlMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n        createRenderState: createHtmlRenderState,\n    }),\n};\n\nfunction createDomMotionConfig(Component, _a, preloadedFeatures, createVisualElement) {\n    var _b = _a.forwardMotionProps, forwardMotionProps = _b === void 0 ? false : _b;\n    var baseConfig = isSVGComponent(Component)\n        ? svgMotionConfig\n        : htmlMotionConfig;\n    return tslib.__assign(tslib.__assign({}, baseConfig), { preloadedFeatures: preloadedFeatures, useRender: createUseRender(forwardMotionProps), createVisualElement: createVisualElement,\n        Component: Component });\n}\n\nvar AnimationType;\n(function (AnimationType) {\n    AnimationType[\"Animate\"] = \"animate\";\n    AnimationType[\"Hover\"] = \"whileHover\";\n    AnimationType[\"Tap\"] = \"whileTap\";\n    AnimationType[\"Drag\"] = \"whileDrag\";\n    AnimationType[\"Focus\"] = \"whileFocus\";\n    AnimationType[\"Exit\"] = \"exit\";\n})(AnimationType || (AnimationType = {}));\n\nfunction addDomEvent(target, eventName, handler, options) {\n    target.addEventListener(eventName, handler, options);\n    return function () { return target.removeEventListener(eventName, handler, options); };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\nfunction useDomEvent(ref, eventName, handler, options) {\n    React.useEffect(function () {\n        var element = ref.current;\n        if (handler && element) {\n            return addDomEvent(element, eventName, handler, options);\n        }\n    }, [ref, eventName, handler, options]);\n}\n\n/**\n *\n * @param props\n * @param ref\n * @internal\n */\nfunction useFocusGesture(_a) {\n    var whileFocus = _a.whileFocus, visualElement = _a.visualElement;\n    var onFocus = function () {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, true);\n    };\n    var onBlur = function () {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, false);\n    };\n    useDomEvent(visualElement, \"focus\", whileFocus ? onFocus : undefined);\n    useDomEvent(visualElement, \"blur\", whileFocus ? onBlur : undefined);\n}\n\nfunction isMouseEvent(event) {\n    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n    if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n        return !!(event.pointerType === \"mouse\");\n    }\n    return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n    var hasTouches = !!event.touches;\n    return hasTouches;\n}\n\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\nfunction filterPrimaryPointer(eventHandler) {\n    return function (event) {\n        var isMouseEvent = event instanceof MouseEvent;\n        var isPrimaryPointer = !isMouseEvent ||\n            (isMouseEvent && event.button === 0);\n        if (isPrimaryPointer) {\n            eventHandler(event);\n        }\n    };\n}\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\nfunction pointFromTouch(e, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\n    var point = primaryTouch || defaultPagePoint;\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"],\n    };\n}\nfunction pointFromMouse(point, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"],\n    };\n}\nfunction extractEventInfo(event, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    return {\n        point: isTouchEvent(event)\n            ? pointFromTouch(event, pointType)\n            : pointFromMouse(event, pointType),\n    };\n}\nfunction getViewportPointFromEvent(event) {\n    return extractEventInfo(event, \"client\");\n}\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\n    if (shouldFilterPrimaryPointer === void 0) { shouldFilterPrimaryPointer = false; }\n    var listener = function (event) {\n        return handler(event, extractEventInfo(event));\n    };\n    return shouldFilterPrimaryPointer\n        ? filterPrimaryPointer(listener)\n        : listener;\n};\n\n// We check for event support via functions in case they've been mocked by a testing suite.\nvar supportsPointerEvents = function () {\n    return isBrowser && window.onpointerdown === null;\n};\nvar supportsTouchEvents = function () {\n    return isBrowser && window.ontouchstart === null;\n};\nvar supportsMouseEvents = function () {\n    return isBrowser && window.onmousedown === null;\n};\n\nvar mouseEventNames = {\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointercancel: \"mousecancel\",\n    pointerover: \"mouseover\",\n    pointerout: \"mouseout\",\n    pointerenter: \"mouseenter\",\n    pointerleave: \"mouseleave\",\n};\nvar touchEventNames = {\n    pointerdown: \"touchstart\",\n    pointermove: \"touchmove\",\n    pointerup: \"touchend\",\n    pointercancel: \"touchcancel\",\n};\nfunction getPointerEventName(name) {\n    if (supportsPointerEvents()) {\n        return name;\n    }\n    else if (supportsTouchEvents()) {\n        return touchEventNames[name];\n    }\n    else if (supportsMouseEvents()) {\n        return mouseEventNames[name];\n    }\n    return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n    return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\nfunction createLock(name) {\n    var lock = null;\n    return function () {\n        var openLock = function () {\n            lock = null;\n        };\n        if (lock === null) {\n            lock = name;\n            return openLock;\n        }\n        return false;\n    };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag) {\n    var lock = false;\n    if (drag === \"y\") {\n        lock = globalVerticalLock();\n    }\n    else if (drag === \"x\") {\n        lock = globalHorizontalLock();\n    }\n    else {\n        var openHorizontal_1 = globalHorizontalLock();\n        var openVertical_1 = globalVerticalLock();\n        if (openHorizontal_1 && openVertical_1) {\n            lock = function () {\n                openHorizontal_1();\n                openVertical_1();\n            };\n        }\n        else {\n            // Release the locks because we don't use them\n            if (openHorizontal_1)\n                openHorizontal_1();\n            if (openVertical_1)\n                openVertical_1();\n        }\n    }\n    return lock;\n}\nfunction isDragActive() {\n    // Check the gesture lock - if we get it, it means no drag gesture is active\n    // and we can safely fire the tap gesture.\n    var openGestureLock = getGlobalLock(true);\n    if (!openGestureLock)\n        return true;\n    openGestureLock();\n    return false;\n}\n\nfunction createHoverEvent(visualElement, isActive, callback) {\n    return function (event, info) {\n        var _a;\n        if (!isMouseEvent(event) || isDragActive())\n            return;\n        callback === null || callback === void 0 ? void 0 : callback(event, info);\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Hover, isActive);\n    };\n}\nfunction useHoverGesture(_a) {\n    var onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, whileHover = _a.whileHover, visualElement = _a.visualElement;\n    usePointerEvent(visualElement, \"pointerenter\", onHoverStart || whileHover\n        ? createHoverEvent(visualElement, true, onHoverStart)\n        : undefined);\n    usePointerEvent(visualElement, \"pointerleave\", onHoverEnd || whileHover\n        ? createHoverEvent(visualElement, false, onHoverEnd)\n        : undefined);\n}\n\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nvar isNodeOrChild = function (parent, child) {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\nfunction useUnmountEffect(callback) {\n    return React.useEffect(function () { return function () { return callback(); }; }, []);\n}\n\n/**\n * @param handlers -\n * @internal\n */\nfunction useTapGesture(_a) {\n    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, visualElement = _a.visualElement;\n    var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n    var isPressing = React.useRef(false);\n    var cancelPointerEndListeners = React.useRef(null);\n    function removePointerEndListener() {\n        var _a;\n        (_a = cancelPointerEndListeners.current) === null || _a === void 0 ? void 0 : _a.call(cancelPointerEndListeners);\n        cancelPointerEndListeners.current = null;\n    }\n    function checkPointerEnd() {\n        var _a;\n        removePointerEndListener();\n        isPressing.current = false;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, false);\n        return !isDragActive();\n    }\n    function onPointerUp(event, info) {\n        if (!checkPointerEnd())\n            return;\n        /**\n         * We only count this as a tap gesture if the event.target is the same\n         * as, or a child of, this component's element\n         */\n        !isNodeOrChild(visualElement.getInstance(), event.target)\n            ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info)\n            : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);\n    }\n    function onPointerCancel(event, info) {\n        if (!checkPointerEnd())\n            return;\n        onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);\n    }\n    function onPointerDown(event, info) {\n        var _a;\n        removePointerEndListener();\n        if (isPressing.current)\n            return;\n        isPressing.current = true;\n        cancelPointerEndListeners.current = popmotion.pipe(addPointerEvent(window, \"pointerup\", onPointerUp), addPointerEvent(window, \"pointercancel\", onPointerCancel));\n        onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, true);\n    }\n    usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : undefined);\n    useUnmountEffect(removePointerEndListener);\n}\n\nvar makeRenderlessComponent = function (hook) { return function (props) {\n    hook(props);\n    return null;\n}; };\n\nvar gestureAnimations = {\n    tap: makeRenderlessComponent(useTapGesture),\n    focus: makeRenderlessComponent(useFocusGesture),\n    hover: makeRenderlessComponent(useHoverGesture),\n};\n\nfunction shallowCompare(next, prev) {\n    if (!Array.isArray(prev))\n        return false;\n    var prevLength = prev.length;\n    if (prevLength !== next.length)\n        return false;\n    for (var i = 0; i < prevLength; i++) {\n        if (prev[i] !== next[i])\n            return false;\n    }\n    return true;\n}\n\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\nvar secondsToMilliseconds = function (seconds) { return seconds * 1000; };\n\nvar easingLookup = {\n    linear: popmotion.linear,\n    easeIn: popmotion.easeIn,\n    easeInOut: popmotion.easeInOut,\n    easeOut: popmotion.easeOut,\n    circIn: popmotion.circIn,\n    circInOut: popmotion.circInOut,\n    circOut: popmotion.circOut,\n    backIn: popmotion.backIn,\n    backInOut: popmotion.backInOut,\n    backOut: popmotion.backOut,\n    anticipate: popmotion.anticipate,\n    bounceIn: popmotion.bounceIn,\n    bounceInOut: popmotion.bounceInOut,\n    bounceOut: popmotion.bounceOut,\n};\nvar easingDefinitionToFunction = function (definition) {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        heyListen.invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n        var _a = tslib.__read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];\n        return popmotion.cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === \"string\") {\n        // Else lookup from table\n        heyListen.invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\n        return easingLookup[definition];\n    }\n    return definition;\n};\nvar isEasingArray = function (ease) {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\n/**\n * Check if a value is animatable. Examples:\n *\n * : 100, \"100px\", \"#fff\"\n * : \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nvar isAnimatable = function (key, value) {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (key === \"zIndex\")\n        return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value))\n        return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n        styleValueTypes.complex.test(value) && // And it contains numbers and/or colors\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\n\nvar underDampedSpring = function () { return ({\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10,\n}); };\nvar criticallyDampedSpring = function (to) { return ({\n    type: \"spring\",\n    stiffness: 550,\n    damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n    restDelta: 0.01,\n    restSpeed: 10,\n}); };\nvar linearTween = function () { return ({\n    type: \"keyframes\",\n    ease: \"linear\",\n    duration: 0.3,\n}); };\nvar keyframes = function (values) { return ({\n    type: \"keyframes\",\n    duration: 0.8,\n    values: values,\n}); };\nvar defaultTransitions = {\n    x: underDampedSpring,\n    y: underDampedSpring,\n    z: underDampedSpring,\n    rotate: underDampedSpring,\n    rotateX: underDampedSpring,\n    rotateY: underDampedSpring,\n    rotateZ: underDampedSpring,\n    scaleX: criticallyDampedSpring,\n    scaleY: criticallyDampedSpring,\n    scale: criticallyDampedSpring,\n    opacity: linearTween,\n    backgroundColor: linearTween,\n    color: linearTween,\n    default: criticallyDampedSpring,\n};\nvar getDefaultTransition = function (valueKey, to) {\n    var transitionFactory;\n    if (isKeyframesTarget(to)) {\n        transitionFactory = keyframes;\n    }\n    else {\n        transitionFactory =\n            defaultTransitions[valueKey] || defaultTransitions.default;\n    }\n    return tslib.__assign({ to: to }, transitionFactory(to));\n};\n\n/**\n * A map of default value types for common values\n */\nvar defaultValueTypes = tslib.__assign(tslib.__assign({}, numberValueTypes), { \n    // Color props\n    color: styleValueTypes.color, backgroundColor: styleValueTypes.color, outlineColor: styleValueTypes.color, fill: styleValueTypes.color, stroke: styleValueTypes.color, \n    // Border props\n    borderColor: styleValueTypes.color, borderTopColor: styleValueTypes.color, borderRightColor: styleValueTypes.color, borderBottomColor: styleValueTypes.color, borderLeftColor: styleValueTypes.color, filter: styleValueTypes.filter, WebkitFilter: styleValueTypes.filter });\n/**\n * Gets the default ValueType for the provided value key\n */\nvar getDefaultValueType = function (key) { return defaultValueTypes[key]; };\n\nfunction getAnimatableNone(key, value) {\n    var _a;\n    var defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== styleValueTypes.filter)\n        defaultValueType = styleValueTypes.complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined(_a) {\n    _a.when; _a.delay; _a.delayChildren; _a.staggerChildren; _a.staggerDirection; _a.repeat; _a.repeatType; _a.repeatDelay; _a.from; var transition = tslib.__rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"]);\n    return !!Object.keys(transition).length;\n}\nvar legacyRepeatWarning = false;\n/**\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\n */\nfunction convertTransitionToAnimationOptions(_a) {\n    var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop = _a.loop, transition = tslib.__rest(_a, [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"]);\n    var options = tslib.__assign({}, transition);\n    if (times)\n        options[\"offset\"] = times;\n    /**\n     * Convert any existing durations from seconds to milliseconds\n     */\n    if (transition.duration)\n        options[\"duration\"] = secondsToMilliseconds(transition.duration);\n    if (transition.repeatDelay)\n        options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n    /**\n     * Map easing names to Popmotion's easing functions\n     */\n    if (ease) {\n        options[\"ease\"] = isEasingArray(ease)\n            ? ease.map(easingDefinitionToFunction)\n            : easingDefinitionToFunction(ease);\n    }\n    /**\n     * Support legacy transition API\n     */\n    if (transition.type === \"tween\")\n        options.type = \"keyframes\";\n    /**\n     * TODO: These options are officially removed from the API.\n     */\n    if (yoyo || loop || flip) {\n        heyListen.warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n        legacyRepeatWarning = true;\n        if (yoyo) {\n            options.repeatType = \"reverse\";\n        }\n        else if (loop) {\n            options.repeatType = \"loop\";\n        }\n        else if (flip) {\n            options.repeatType = \"mirror\";\n        }\n        options.repeat = loop || yoyo || flip || transition.repeat;\n    }\n    /**\n     * TODO: Popmotion 9 has the ability to automatically detect whether to use\n     * a keyframes or spring animation, but does so by detecting velocity and other spring options.\n     * It'd be good to introduce a similar thing here.\n     */\n    if (transition.type !== \"spring\")\n        options.type = \"keyframes\";\n    return options;\n}\n/**\n * Get the delay for a value by checking Transition with decreasing specificity.\n */\nfunction getDelayFromTransition(transition, key) {\n    var _a;\n    var valueTransition = getValueTransition(transition, key) || {};\n    return (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : 0;\n}\nfunction hydrateKeyframes(options) {\n    if (Array.isArray(options.to) && options.to[0] === null) {\n        options.to = tslib.__spreadArray([], tslib.__read(options.to));\n        options.to[0] = options.from;\n    }\n    return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n    var _a;\n    if (Array.isArray(options.to)) {\n        (_a = transition.duration) !== null && _a !== void 0 ? _a : (transition.duration = 0.8);\n    }\n    hydrateKeyframes(options);\n    /**\n     * Get a default transition if none is determined to be defined.\n     */\n    if (!isTransitionDefined(transition)) {\n        transition = tslib.__assign(tslib.__assign({}, transition), getDefaultTransition(key, options.to));\n    }\n    return tslib.__assign(tslib.__assign({}, options), convertTransitionToAnimationOptions(transition));\n}\n/**\n *\n */\nfunction getAnimation(key, value, target, transition, onComplete) {\n    var _a;\n    var valueTransition = getValueTransition(transition, key);\n    var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();\n    var isTargetAnimatable = isAnimatable(key, target);\n    if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n        /**\n         * If we're trying to animate from \"none\", try and get an animatable version\n         * of the target. This could be improved to work both ways.\n         */\n        origin = getAnimatableNone(key, target);\n    }\n    else if (isZero(origin) && typeof target === \"string\") {\n        origin = getZeroUnit(target);\n    }\n    else if (!Array.isArray(target) &&\n        isZero(target) &&\n        typeof origin === \"string\") {\n        target = getZeroUnit(origin);\n    }\n    var isOriginAnimatable = isAnimatable(key, origin);\n    heyListen.warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\");\n    function start() {\n        var options = {\n            from: origin,\n            to: target,\n            velocity: value.getVelocity(),\n            onComplete: onComplete,\n            onUpdate: function (v) { return value.set(v); },\n        };\n        return valueTransition.type === \"inertia\" ||\n            valueTransition.type === \"decay\"\n            ? popmotion.inertia(tslib.__assign(tslib.__assign({}, options), valueTransition))\n            : popmotion.animate(tslib.__assign(tslib.__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: function (v) {\n                    var _a;\n                    options.onUpdate(v);\n                    (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);\n                }, onComplete: function () {\n                    var _a;\n                    options.onComplete();\n                    (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n                } }));\n    }\n    function set() {\n        var _a;\n        value.set(target);\n        onComplete();\n        (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n        return { stop: function () { } };\n    }\n    return !isOriginAnimatable ||\n        !isTargetAnimatable ||\n        valueTransition.type === false\n        ? set\n        : start;\n}\nfunction isZero(value) {\n    return (value === 0 ||\n        (typeof value === \"string\" &&\n            parseFloat(value) === 0 &&\n            value.indexOf(\" \") === -1));\n}\nfunction getZeroUnit(potentialUnitType) {\n    return typeof potentialUnitType === \"number\"\n        ? 0\n        : getAnimatableNone(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n    return transition[key] || transition[\"default\"] || transition;\n}\n/**\n * Start animation on a MotionValue. This function is an interface between\n * Framer Motion and Popmotion\n *\n * @internal\n */\nfunction startAnimation(key, value, target, transition) {\n    if (transition === void 0) { transition = {}; }\n    return value.start(function (onComplete) {\n        var delayTimer;\n        var controls;\n        var animation = getAnimation(key, value, target, transition, onComplete);\n        var delay = getDelayFromTransition(transition, key);\n        var start = function () { return (controls = animation()); };\n        if (delay) {\n            delayTimer = setTimeout(start, secondsToMilliseconds(delay));\n        }\n        else {\n            start();\n        }\n        return function () {\n            clearTimeout(delayTimer);\n            controls === null || controls === void 0 ? void 0 : controls.stop();\n        };\n    });\n}\n\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nvar isNumericalString = function (v) { return /^\\-?\\d*\\.?\\d+$/.test(v); };\n\nfunction addUniqueItem(arr, item) {\n    arr.indexOf(item) === -1 && arr.push(item);\n}\nfunction removeItem(arr, item) {\n    var index = arr.indexOf(item);\n    index > -1 && arr.splice(index, 1);\n}\n\nvar SubscriptionManager = /** @class */ (function () {\n    function SubscriptionManager() {\n        this.subscriptions = [];\n    }\n    SubscriptionManager.prototype.add = function (handler) {\n        var _this = this;\n        addUniqueItem(this.subscriptions, handler);\n        return function () { return removeItem(_this.subscriptions, handler); };\n    };\n    SubscriptionManager.prototype.notify = function (a, b, c) {\n        var numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (var i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                var handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    };\n    SubscriptionManager.prototype.getSize = function () {\n        return this.subscriptions.length;\n    };\n    SubscriptionManager.prototype.clear = function () {\n        this.subscriptions.length = 0;\n    };\n    return SubscriptionManager;\n}());\n\nvar isFloat = function (value) {\n    return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nvar MotionValue = /** @class */ (function () {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */\n    function MotionValue(init) {\n        var _this = this;\n        /**\n         * Duration, in milliseconds, since last updating frame.\n         *\n         * @internal\n         */\n        this.timeDelta = 0;\n        /**\n         * Timestamp of the last time this `MotionValue` was updated.\n         *\n         * @internal\n         */\n        this.lastUpdated = 0;\n        /**\n         * Functions to notify when the `MotionValue` updates.\n         *\n         * @internal\n         */\n        this.updateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the velocity updates.\n         *\n         * @internal\n         */\n        this.velocityUpdateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the `MotionValue` updates and `render` is set to `true`.\n         *\n         * @internal\n         */\n        this.renderSubscribers = new SubscriptionManager();\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = false;\n        this.updateAndNotify = function (v, render) {\n            if (render === void 0) { render = true; }\n            _this.prev = _this.current;\n            _this.current = v;\n            // Update timestamp\n            var _a = sync.getFrameData(), delta = _a.delta, timestamp = _a.timestamp;\n            if (_this.lastUpdated !== timestamp) {\n                _this.timeDelta = delta;\n                _this.lastUpdated = timestamp;\n                sync__default['default'].postRender(_this.scheduleVelocityCheck);\n            }\n            // Update update subscribers\n            if (_this.prev !== _this.current) {\n                _this.updateSubscribers.notify(_this.current);\n            }\n            // Update velocity subscribers\n            if (_this.velocityUpdateSubscribers.getSize()) {\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n            // Update render subscribers\n            if (render) {\n                _this.renderSubscribers.notify(_this.current);\n            }\n        };\n        /**\n         * Schedule a velocity check for the next frame.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.scheduleVelocityCheck = function () { return sync__default['default'].postRender(_this.velocityCheck); };\n        /**\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\n         * This ensures velocity calculations return `0`.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.velocityCheck = function (_a) {\n            var timestamp = _a.timestamp;\n            if (timestamp !== _this.lastUpdated) {\n                _this.prev = _this.current;\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n        };\n        this.hasAnimated = false;\n        this.prev = this.current = init;\n        this.canTrackVelocity = isFloat(this.current);\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * @library\n     *\n     * ```jsx\n     * function MyComponent() {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <Frame x={x} />\n     * }\n     * ```\n     *\n     * @motion\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @internalremarks\n     *\n     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n     *\n     * ```jsx\n     * useOnChange(x, () => {})\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @public\n     */\n    MotionValue.prototype.onChange = function (subscription) {\n        return this.updateSubscribers.add(subscription);\n    };\n    MotionValue.prototype.clearListeners = function () {\n        this.updateSubscribers.clear();\n    };\n    /**\n     * Adds a function that will be notified when the `MotionValue` requests a render.\n     *\n     * @param subscriber - A function that's provided the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @internal\n     */\n    MotionValue.prototype.onRenderRequest = function (subscription) {\n        // Render immediately\n        subscription(this.get());\n        return this.renderSubscribers.add(subscription);\n    };\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */\n    MotionValue.prototype.attach = function (passiveEffect) {\n        this.passiveEffect = passiveEffect;\n    };\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    MotionValue.prototype.set = function (v, render) {\n        if (render === void 0) { render = true; }\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    };\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    MotionValue.prototype.get = function () {\n        return this.current;\n    };\n    /**\n     * @public\n     */\n    MotionValue.prototype.getPrevious = function () {\n        return this.prev;\n    };\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    MotionValue.prototype.getVelocity = function () {\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n        return this.canTrackVelocity\n            ? // These casts could be avoided if parseFloat would be typed better\n                popmotion.velocityPerSecond(parseFloat(this.current) -\n                    parseFloat(this.prev), this.timeDelta)\n            : 0;\n    };\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */\n    MotionValue.prototype.start = function (animation) {\n        var _this = this;\n        this.stop();\n        return new Promise(function (resolve) {\n            _this.hasAnimated = true;\n            _this.stopAnimation = animation(resolve);\n        }).then(function () { return _this.clearAnimation(); });\n    };\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    MotionValue.prototype.stop = function () {\n        if (this.stopAnimation)\n            this.stopAnimation();\n        this.clearAnimation();\n    };\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    MotionValue.prototype.isAnimating = function () {\n        return !!this.stopAnimation;\n    };\n    MotionValue.prototype.clearAnimation = function () {\n        this.stopAnimation = null;\n    };\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    MotionValue.prototype.destroy = function () {\n        this.updateSubscribers.clear();\n        this.renderSubscribers.clear();\n        this.stop();\n    };\n    return MotionValue;\n}());\n/**\n * @internal\n */\nfunction motionValue(init) {\n    return new MotionValue(init);\n}\n\n/**\n * Tests a provided value against a ValueType\n */\nvar testValueType = function (v) { return function (type) { return type.test(v); }; };\n\n/**\n * ValueType for \"auto\"\n */\nvar auto = {\n    test: function (v) { return v === \"auto\"; },\n    parse: function (v) { return v; },\n};\n\n/**\n * A list of value types commonly used for dimensions\n */\nvar dimensionValueTypes = [styleValueTypes.number, styleValueTypes.px, styleValueTypes.percent, styleValueTypes.degrees, styleValueTypes.vw, styleValueTypes.vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nvar findDimensionValueType = function (v) {\n    return dimensionValueTypes.find(testValueType(v));\n};\n\n/**\n * A list of all ValueTypes\n */\nvar valueTypes = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(dimensionValueTypes)), [styleValueTypes.color, styleValueTypes.complex]);\n/**\n * Tests a value against the list of ValueTypes\n */\nvar findValueType = function (v) { return valueTypes.find(testValueType(v)); };\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    var resolved = resolveVariant(visualElement, definition);\n    var _a = resolved\n        ? visualElement.makeTargetAnimatable(resolved, false)\n        : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b; _a.transition; var target = tslib.__rest(_a, [\"transitionEnd\", \"transition\"]);\n    target = tslib.__assign(tslib.__assign({}, target), transitionEnd);\n    for (var key in target) {\n        var value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\nfunction setVariants(visualElement, variantLabels) {\n    var reversedLabels = tslib.__spreadArray([], tslib.__read(variantLabels)).reverse();\n    reversedLabels.forEach(function (key) {\n        var _a;\n        var variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n            setVariants(child, variantLabels);\n        });\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n    var _a, _b, _c;\n    var _d;\n    var newValueKeys = Object.keys(target).filter(function (key) { return !visualElement.hasValue(key); });\n    var numNewValues = newValueKeys.length;\n    if (!numNewValues)\n        return;\n    for (var i = 0; i < numNewValues; i++) {\n        var key = newValueKeys[i];\n        var targetValue = target[key];\n        var value = null;\n        /**\n         * If the target is a series of keyframes, we can use the first value\n         * in the array. If this first value is null, we'll still need to read from the DOM.\n         */\n        if (Array.isArray(targetValue)) {\n            value = targetValue[0];\n        }\n        /**\n         * If the target isn't keyframes, or the first keyframe was null, we need to\n         * first check if an origin value was explicitly defined in the transition as \"from\",\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n         */\n        if (value === null) {\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n        }\n        /**\n         * If value is still undefined or null, ignore it. Preferably this would throw,\n         * but this was causing issues in Framer.\n         */\n        if (value === undefined || value === null)\n            continue;\n        if (typeof value === \"string\" && isNumericalString(value)) {\n            // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n            value = parseFloat(value);\n        }\n        else if (!findValueType(value) && styleValueTypes.complex.test(targetValue)) {\n            value = getAnimatableNone(key, targetValue);\n        }\n        visualElement.addValue(key, motionValue(value));\n        (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : (_d[key] = value);\n        visualElement.setBaseTarget(key, value);\n    }\n}\nfunction getOriginFromTransition(key, transition) {\n    if (!transition)\n        return;\n    var valueTransition = transition[key] || transition[\"default\"] || transition;\n    return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n    var _a, _b;\n    var origin = {};\n    for (var key in target) {\n        origin[key] =\n            (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n    }\n    return origin;\n}\n\n/**\n * @internal\n */\nfunction animateVisualElement(visualElement, definition, options) {\n    if (options === void 0) { options = {}; }\n    visualElement.notifyAnimationStart();\n    var animation;\n    if (Array.isArray(definition)) {\n        var animations = definition.map(function (variant) {\n            return animateVariant(visualElement, variant, options);\n        });\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        var resolvedDefinition = typeof definition === \"function\"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = animateTarget(visualElement, resolvedDefinition, options);\n    }\n    return animation.then(function () {\n        return visualElement.notifyAnimationComplete(definition);\n    });\n}\nfunction animateVariant(visualElement, variant, options) {\n    var _a;\n    if (options === void 0) { options = {}; }\n    var resolved = resolveVariant(visualElement, variant, options.custom);\n    var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    var getAnimation = resolved\n        ? function () { return animateTarget(visualElement, resolved, options); }\n        : function () { return Promise.resolve(); };\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size)\n        ? function (forwardDelay) {\n            if (forwardDelay === void 0) { forwardDelay = 0; }\n            var _a = transition.delayChildren, delayChildren = _a === void 0 ? 0 : _a, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : function () { return Promise.resolve(); };\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    var when = transition.when;\n    if (when) {\n        var _c = tslib.__read(when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation], 2), first = _c[0], last = _c[1];\n        return first().then(last);\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\n/**\n * @internal\n */\nfunction animateTarget(visualElement, definition, _a) {\n    var _b;\n    var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;\n    var _e = visualElement.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = tslib.__rest(_e, [\"transition\", \"transitionEnd\"]);\n    if (transitionOverride)\n        transition = transitionOverride;\n    var animations = [];\n    var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\n    for (var key in target) {\n        var value = visualElement.getValue(key);\n        var valueTarget = target[key];\n        if (!value ||\n            valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        var animation = startAnimation(key, value, valueTarget, tslib.__assign({ delay: delay }, transition));\n        animations.push(animation);\n    }\n    return Promise.all(animations).then(function () {\n        transitionEnd && setTarget(visualElement, transitionEnd);\n    });\n}\nfunction animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {\n    if (delayChildren === void 0) { delayChildren = 0; }\n    if (staggerChildren === void 0) { staggerChildren = 0; }\n    if (staggerDirection === void 0) { staggerDirection = 1; }\n    var animations = [];\n    var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    var generateStaggerDuration = staggerDirection === 1\n        ? function (i) {\n            if (i === void 0) { i = 0; }\n            return i * staggerChildren;\n        }\n        : function (i) {\n            if (i === void 0) { i = 0; }\n            return maxStaggerDuration - i * staggerChildren;\n        };\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach(function (child, i) {\n        animations.push(animateVariant(child, variant, tslib.__assign(tslib.__assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(function () { return child.notifyAnimationComplete(variant); }));\n    });\n    return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n    visualElement.forEachValue(function (value) { return value.stop(); });\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation(_a, key) {\n    var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;\n    var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\n\nvar variantPriorityOrder = [\n    AnimationType.Animate,\n    AnimationType.Hover,\n    AnimationType.Tap,\n    AnimationType.Drag,\n    AnimationType.Focus,\n    AnimationType.Exit,\n];\nvar reversePriorityOrder = tslib.__spreadArray([], tslib.__read(variantPriorityOrder)).reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return function (animations) {\n        return Promise.all(animations.map(function (_a) {\n            var animation = _a.animation, options = _a.options;\n            return animateVisualElement(visualElement, animation, options);\n        }));\n    };\n}\nfunction createAnimationState(visualElement) {\n    var animate = animateList(visualElement);\n    var state = createState();\n    var allAnimatedKeys = {};\n    var isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    var buildResolvedTypeValues = function (acc, definition) {\n        var resolved = resolveVariant(visualElement, definition);\n        if (resolved) {\n            resolved.transition; var transitionEnd = resolved.transitionEnd, target = tslib.__rest(resolved, [\"transition\", \"transitionEnd\"]);\n            acc = tslib.__assign(tslib.__assign(tslib.__assign({}, acc), target), transitionEnd);\n        }\n        return acc;\n    };\n    function isAnimated(key) {\n        return allAnimatedKeys[key] !== undefined;\n    }\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(options, changedActiveType) {\n        var _a;\n        var props = visualElement.getProps();\n        var context = visualElement.getVariantContext(true) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        var animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        var removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        var encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        var removedVariantIndex = Infinity;\n        var _loop_1 = function (i) {\n            var type = reversePriorityOrder[i];\n            var typeState = state[type];\n            var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n            var propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            var activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = tslib.__assign({}, encounteredKeys);\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                return \"continue\";\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            var definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;\n            var allKeys = tslib.__assign(tslib.__assign({}, prevResolvedValues), resolvedValues);\n            var markToAnimate = function (key) {\n                shouldAnimateType = true;\n                removedKeys.delete(key);\n                typeState.needsAnimating[key] = true;\n            };\n            for (var key in allKeys) {\n                var next = resolvedValues[key];\n                var prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                if (next !== prev) {\n                    /**\n                     * If both values are keyframes, we need to shallow compare them to\n                     * detect whether any value has changed. If it has, we animate it.\n                     */\n                    if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                        if (!shallowCompare(next, prev)) {\n                            markToAnimate(key);\n                        }\n                        else {\n                            /**\n                             * If it hasn't changed, we want to ensure it doesn't animate by\n                             * adding it to the list of protected keys.\n                             */\n                            typeState.protectedKeys[key] = true;\n                        }\n                    }\n                    else if (next !== undefined) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = tslib.__assign(tslib.__assign({}, encounteredKeys), resolvedValues);\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to hard-block animations\n             * TODO: Test as this should probably still handle animations triggered\n             * by removed values?\n             */\n            if (shouldAnimateType && !isInherited) {\n                animations.push.apply(animations, tslib.__spreadArray([], tslib.__read(definitionList.map(function (animation) { return ({\n                    animation: animation,\n                    options: tslib.__assign({ type: type }, options),\n                }); }))));\n            }\n        };\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (var i = 0; i < numAnimationTypes; i++) {\n            _loop_1(i);\n        }\n        allAnimatedKeys = tslib.__assign({}, encounteredKeys);\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            var fallbackAnimation_1 = {};\n            removedKeys.forEach(function (key) {\n                var fallbackTarget = visualElement.getBaseTarget(key);\n                if (fallbackTarget !== undefined) {\n                    fallbackAnimation_1[key] = fallbackTarget;\n                }\n            });\n            animations.push({ animation: fallbackAnimation_1 });\n        }\n        var shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            props.initial === false &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive, options) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        return animateChanges(options, type);\n    }\n    return {\n        isAnimated: isAnimated,\n        animateChanges: animateChanges,\n        setActive: setActive,\n        setAnimateFunction: setAnimateFunction,\n        getState: function () { return state; },\n    };\n}\nfunction variantsHaveChanged(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (isVariantLabels(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive) {\n    if (isActive === void 0) { isActive = false; }\n    return {\n        isActive: isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    var _a;\n    return _a = {},\n        _a[AnimationType.Animate] = createTypeState(true),\n        _a[AnimationType.Hover] = createTypeState(),\n        _a[AnimationType.Tap] = createTypeState(),\n        _a[AnimationType.Drag] = createTypeState(),\n        _a[AnimationType.Focus] = createTypeState(),\n        _a[AnimationType.Exit] = createTypeState(),\n        _a;\n}\n\nvar animations = {\n    animation: makeRenderlessComponent(function (_a) {\n        var visualElement = _a.visualElement, animate = _a.animate;\n        /**\n         * We dynamically generate the AnimationState manager as it contains a reference\n         * to the underlying animation library. We only want to load that if we load this,\n         * so people can optionally code split it out using the `m` component.\n         */\n        visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n        /**\n         * Subscribe any provided AnimationControls to the component's VisualElement\n         */\n        if (isAnimationControls(animate)) {\n            React.useEffect(function () { return animate.subscribe(visualElement); }, [animate]);\n        }\n    }),\n    exit: makeRenderlessComponent(function (props) {\n        var custom = props.custom, visualElement = props.visualElement;\n        var _a = tslib.__read(usePresence(), 2), isPresent = _a[0], onExitComplete = _a[1];\n        var presenceContext = React.useContext(PresenceContext);\n        React.useEffect(function () {\n            var _a, _b;\n            var animation = (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Exit, !isPresent, { custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom });\n            !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(onExitComplete));\n        }, [isPresent]);\n    }),\n};\n\n/**\n * @internal\n */\nvar PanSession = /** @class */ (function () {\n    function PanSession(event, handlers, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = function () {\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\n                return;\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n            var isPanStarted = _this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            var isDistancePastThreshold = popmotion.distance(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            var point = info.point;\n            var timestamp = sync.getFrameData().timestamp;\n            _this.history.push(tslib.__assign(tslib.__assign({}, point), { timestamp: timestamp }));\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\n            if (!isPanStarted) {\n                onStart && onStart(_this.lastMoveEvent, info);\n                _this.startEvent = _this.lastMoveEvent;\n            }\n            onMove && onMove(_this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = function (event, info) {\n            _this.lastMoveEvent = event;\n            _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\n            // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n            if (isMouseEvent(event) && event.buttons === 0) {\n                _this.handlePointerUp(event, info);\n                return;\n            }\n            // Throttle mouse move event to once per frame\n            sync__default['default'].update(_this.updatePoint, true);\n        };\n        this.handlePointerUp = function (event, info) {\n            _this.end();\n            var _a = _this.handlers, onEnd = _a.onEnd, onSessionEnd = _a.onSessionEnd;\n            var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n            if (_this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (isTouchEvent(event) && event.touches.length > 1)\n            return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        var info = extractEventInfo(event);\n        var initialInfo = transformPoint(info, this.transformPagePoint);\n        var point = initialInfo.point;\n        var timestamp = sync.getFrameData().timestamp;\n        this.history = [tslib.__assign(tslib.__assign({}, point), { timestamp: timestamp })];\n        var onSessionStart = handlers.onSessionStart;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = popmotion.pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n    }\n    PanSession.prototype.updateHandlers = function (handlers) {\n        this.handlers = handlers;\n    };\n    PanSession.prototype.end = function () {\n        this.removeListeners && this.removeListeners();\n        sync.cancelSync.update(this.updatePoint);\n    };\n    return PanSession;\n}());\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo(_a, history) {\n    var point = _a.point;\n    return {\n        point: point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    var i = history.length - 1;\n    var timestampedPoint = null;\n    var lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    var currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nfunction noop(any) {\n    return any;\n}\n\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToAxisBox(_a) {\n    var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertAxisBoxToBoundingBox(_a) {\n    var x = _a.x, y = _a.y;\n    return {\n        top: y.min,\n        bottom: y.max,\n        left: x.min,\n        right: x.max,\n    };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoundingBox(_a, transformPoint) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    if (transformPoint === void 0) { transformPoint = noop; }\n    var topLeft = transformPoint({ x: left, y: top });\n    var bottomRight = transformPoint({ x: right, y: bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n/**\n * Create an empty axis box of zero size\n */\nfunction axisBox() {\n    return { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };\n}\nfunction copyAxisBox(box) {\n    return {\n        x: tslib.__assign({}, box.x),\n        y: tslib.__assign({}, box.y),\n    };\n}\n/**\n * Create an empty box delta\n */\nvar zeroDelta = {\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n};\nfunction delta() {\n    return {\n        x: tslib.__assign({}, zeroDelta),\n        y: tslib.__assign({}, zeroDelta),\n    };\n}\n\n// Call a handler once for each axis\nfunction eachAxis(handler) {\n    return [handler(\"x\"), handler(\"y\")];\n}\n\nvar clampProgress = function (v) { return popmotion.clamp(0, 1, v); };\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\nfunction isNear(value, target, maxDistance) {\n    if (target === void 0) { target = 0; }\n    if (maxDistance === void 0) { maxDistance = 0.01; }\n    return popmotion.distance(value, target) < maxDistance;\n}\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    var origin = 0.5;\n    var sourceLength = calcLength(source);\n    var targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = popmotion.progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = popmotion.progress(source.min, source.max - targetLength, target.min);\n    }\n    return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateAxisDelta(delta, source, target, origin) {\n    if (origin === void 0) { origin = 0.5; }\n    delta.origin = origin;\n    delta.originPoint = popmotion.mix(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    if (isNear(delta.scale, 1, 0.0001))\n        delta.scale = 1;\n    delta.translate =\n        popmotion.mix(target.min, target.max, delta.origin) - delta.originPoint;\n    if (isNear(delta.translate))\n        delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateBoxDelta(delta, source, target, origin) {\n    updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\n    updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\n}\n/**\n * Currently this only accepts numerical origins, measured as 0-1, but could\n * accept pixel values by comparing to the target axis.\n */\nfunction defaultOrigin(origin) {\n    return typeof origin === \"number\" ? origin : 0.5;\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(projection, parentProjection) {\n    calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\n    calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\n}\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, _a, elastic) {\n    var min = _a.min, max = _a.max;\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic ? popmotion.mix(min, point, elastic.min) : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic ? popmotion.mix(max, point, elastic.max) : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculates a min projection point based on a pointer, pointer progress\n * within the drag target, and constraints.\n *\n * For instance if an element was 100px width, we were dragging from 0.25\n * along this axis, the pointer is at 200px, and there were no constraints,\n * we would calculate a min projection point of 175px.\n */\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\n    // Calculate a min point for this axis and apply it to the current pointer\n    var min = point - length * progress;\n    return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, _a) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    var _a;\n    var min = constraintsAxis.min - layoutAxis.min;\n    var max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        _a = tslib.__read([max, min], 2), min = _a[0], max = _a[1];\n    }\n    return {\n        min: layoutAxis.min + min,\n        max: layoutAxis.min + max,\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate the an axis position based on two axes and a progress value.\n */\nfunction calcPositionFromProgress(axis, constraints, progress) {\n    var axisLength = axis.max - axis.min;\n    var min = popmotion.mix(constraints.min, constraints.max - axisLength, progress);\n    return { min: min, max: min + axisLength };\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    var relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nvar defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    var _a;\n    return typeof dragElastic === \"number\"\n        ? dragElastic\n        : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n\n/**\n * Measure and return the element bounding box.\n *\n * We convert the box into an AxisBox2D to make it easier to work with each axis\n * individually and programmatically.\n *\n * This function optionally accepts a transformPagePoint function which allows us to compensate\n * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.\n */\nfunction getBoundingBox(element, transformPagePoint) {\n    var box = element.getBoundingClientRect();\n    return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\n}\n\nvar compareByDepth = function (a, b) {\n    return a.depth - b.depth;\n};\n\nfunction isProjecting(visualElement) {\n    var isEnabled = visualElement.projection.isEnabled;\n    return isEnabled || visualElement.shouldResetTransform();\n}\nfunction collectProjectingAncestors(visualElement, ancestors) {\n    if (ancestors === void 0) { ancestors = []; }\n    var parent = visualElement.parent;\n    if (parent)\n        collectProjectingAncestors(parent, ancestors);\n    if (isProjecting(visualElement))\n        ancestors.push(visualElement);\n    return ancestors;\n}\nfunction collectProjectingChildren(visualElement) {\n    var children = [];\n    var addChild = function (child) {\n        if (isProjecting(child))\n            children.push(child);\n        child.children.forEach(addChild);\n    };\n    visualElement.children.forEach(addChild);\n    return children.sort(compareByDepth);\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\nfunction updateLayoutMeasurement(visualElement) {\n    if (visualElement.shouldResetTransform())\n        return;\n    var layoutState = visualElement.getLayoutState();\n    visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n    layoutState.isHydrated = true;\n    layoutState.layout = visualElement.measureViewportBox();\n    layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n    visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n    sync__default['default'].update(function () { return visualElement.rebaseProjectionTarget(); });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\nfunction snapshotViewportBox(visualElement) {\n    if (visualElement.shouldResetTransform())\n        return;\n    visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n    /**\n     * Update targetBox to match the prevViewportBox. This is just to ensure\n     * that targetBox is affected by scroll in the same way as the measured box\n     */\n    visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\n\nfunction tweenAxis(target, prev, next, p) {\n    target.min = popmotion.mix(prev.min, next.min, p);\n    target.max = popmotion.mix(prev.max, next.max, p);\n}\nfunction calcRelativeOffsetAxis(parent, child) {\n    return {\n        min: child.min - parent.min,\n        max: child.max - parent.min,\n    };\n}\nfunction calcRelativeOffset(parent, child) {\n    return {\n        x: calcRelativeOffsetAxis(parent.x, child.x),\n        y: calcRelativeOffsetAxis(parent.y, child.y),\n    };\n}\nfunction checkIfParentHasChanged(prev, next) {\n    var prevId = prev.getLayoutId();\n    var nextId = next.getLayoutId();\n    return prevId !== nextId || (nextId === undefined && prev !== next);\n}\n\nfunction isDraggable(visualElement) {\n    var _a = visualElement.getProps(), drag = _a.drag, _dragX = _a._dragX;\n    return drag && !_dragX;\n}\n\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetAxis(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetBox(box, originBox) {\n    resetAxis(box.x, originBox.x);\n    resetAxis(box.y, originBox.y);\n}\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    var distanceFromOrigin = point - originPoint;\n    var scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n    if (translate === void 0) { translate = 0; }\n    if (scale === void 0) { scale = 1; }\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, _a) {\n    var x = _a.x, y = _a.y;\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction applyAxisTransforms(final, axis, transforms, _a) {\n    var _b = tslib.__read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    // Copy the current axis to the final axis before mutation\n    final.min = axis.min;\n    final.max = axis.max;\n    var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n    var originPoint = popmotion.mix(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction applyBoxTransforms(finalBox, box, transforms) {\n    applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\n    applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\n}\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\n    if (translate === void 0) { translate = 0; }\n    if (scale === void 0) { scale = 1; }\n    if (origin === void 0) { origin = 0.5; }\n    var originPoint = popmotion.mix(axis.min, axis.max, origin) - translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeAxisTransforms(axis, transforms, _a) {\n    var _b = tslib.__read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\n}\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeBoxTransforms(box, transforms) {\n    removeAxisTransforms(box.x, transforms, xKeys);\n    removeAxisTransforms(box.y, transforms, yKeys);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath) {\n    var treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    var node;\n    var delta;\n    for (var i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.getLayoutState().delta;\n        // Incoporate each ancestor's scale into a culmulative treeScale for this component\n        treeScale.x *= delta.x.scale;\n        treeScale.y *= delta.y.scale;\n        // Apply each ancestor's calculated delta into this component's recorded layout box\n        applyBoxDelta(box, delta);\n        // If this is a draggable ancestor, also incorporate the node's transform to the layout box\n        if (isDraggable(node)) {\n            applyBoxTransforms(box, box, node.getLatestValues());\n        }\n    }\n}\n\n/**\n * Returns a boolean stating whether or not we converted the projection\n * to relative projection.\n */\nfunction convertToRelativeProjection(visualElement, isLayoutDrag) {\n    if (isLayoutDrag === void 0) { isLayoutDrag = true; }\n    var projectionParent = visualElement.getProjectionParent();\n    if (!projectionParent)\n        return false;\n    var offset;\n    if (isLayoutDrag) {\n        offset = calcRelativeOffset(projectionParent.projection.target, visualElement.projection.target);\n        removeBoxTransforms(offset, projectionParent.getLatestValues());\n    }\n    else {\n        offset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\n    }\n    eachAxis(function (axis) {\n        return visualElement.setProjectionTargetAxis(axis, offset[axis].min, offset[axis].max, true);\n    });\n    return true;\n}\n\nvar unresolvedJobs = new Set();\nfunction pushJob(stack, job, pointer) {\n    if (!stack[pointer])\n        stack[pointer] = [];\n    stack[pointer].push(job);\n}\nfunction batchLayout(callback) {\n    unresolvedJobs.add(callback);\n    return function () { return unresolvedJobs.delete(callback); };\n}\nfunction flushLayout() {\n    if (!unresolvedJobs.size)\n        return;\n    var pointer = 0;\n    var reads = [[]];\n    var writes = [];\n    var setRead = function (job) { return pushJob(reads, job, pointer); };\n    var setWrite = function (job) {\n        pushJob(writes, job, pointer);\n        pointer++;\n    };\n    /**\n     * Resolve jobs into their array stacks\n     */\n    unresolvedJobs.forEach(function (callback) {\n        callback(setRead, setWrite);\n        pointer = 0;\n    });\n    unresolvedJobs.clear();\n    /**\n     * Execute jobs\n     */\n    var numStacks = writes.length;\n    for (var i = 0; i <= numStacks; i++) {\n        reads[i] && reads[i].forEach(executeJob);\n        writes[i] && writes[i].forEach(executeJob);\n    }\n}\nvar executeJob = function (job) { return job(); };\n\nvar elementDragControls = new WeakMap();\n/**\n *\n */\nvar lastPointerEvent;\nvar VisualElementDragControls = /** @class */ (function () {\n    function VisualElementDragControls(_a) {\n        var visualElement = _a.visualElement;\n        /**\n         * Track whether we're currently dragging.\n         *\n         * @internal\n         */\n        this.isDragging = false;\n        /**\n         * The current direction of drag, or `null` if both.\n         *\n         * @internal\n         */\n        this.currentDirection = null;\n        /**\n         * The permitted boundaries of travel, in pixels.\n         *\n         * @internal\n         */\n        this.constraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         *\n         * @internal\n         */\n        this.elastic = axisBox();\n        /**\n         * A reference to the host component's latest props.\n         *\n         * @internal\n         */\n        this.props = {};\n        /**\n         * @internal\n         */\n        this.hasMutatedConstraints = false;\n        /**\n         * Track the initial position of the cursor relative to the dragging element\n         * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\n         * an ideal bounding box for the VisualElement renderer to project into every frame.\n         *\n         * @internal\n         */\n        this.cursorProgress = {\n            x: 0.5,\n            y: 0.5,\n        };\n        // When updating _dragX, or _dragY instead of the VisualElement,\n        // persist their values between drag gestures.\n        this.originPoint = {};\n        // This is a reference to the global drag gesture lock, ensuring only one component\n        // can \"capture\" the drag of one or both axes.\n        // TODO: Look into moving this into pansession?\n        this.openGlobalLock = null;\n        /**\n         * @internal\n         */\n        this.panSession = null;\n        this.visualElement = visualElement;\n        this.visualElement.enableLayoutProjection();\n        elementDragControls.set(visualElement, this);\n    }\n    /**\n     * Instantiate a PanSession for the drag gesture\n     *\n     * @public\n     */\n    VisualElementDragControls.prototype.start = function (originEvent, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c, cursorProgress = _b.cursorProgress;\n        var onSessionStart = function (event) {\n            var _a;\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            _this.stopMotion();\n            /**\n             * Save the initial point. We'll use this to calculate the pointer's position rather\n             * than the one we receive when the gesture actually starts. By then, the pointer will\n             * have already moved, and the perception will be of the pointer \"slipping\" across the element\n             */\n            var initialPoint = getViewportPointFromEvent(event).point;\n            (_a = _this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(_this);\n            _this.cancelLayout = batchLayout(function (read, write) {\n                var ancestors = collectProjectingAncestors(_this.visualElement);\n                var children = collectProjectingChildren(_this.visualElement);\n                var tree = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(children));\n                var hasManuallySetCursorOrigin = false;\n                /**\n                 * Apply a simple lock to the projection target. This ensures no animations\n                 * can run on the projection box while this lock is active.\n                 */\n                _this.isLayoutDrag() && _this.visualElement.lockProjectionTarget();\n                write(function () {\n                    tree.forEach(function (element) { return element.resetTransform(); });\n                });\n                read(function () {\n                    updateLayoutMeasurement(_this.visualElement);\n                    children.forEach(updateLayoutMeasurement);\n                });\n                write(function () {\n                    tree.forEach(function (element) { return element.restoreTransform(); });\n                    if (snapToCursor) {\n                        hasManuallySetCursorOrigin = _this.snapToCursor(initialPoint);\n                    }\n                });\n                read(function () {\n                    var isRelativeDrag = Boolean(_this.getAxisMotionValue(\"x\") && !_this.isExternalDrag());\n                    if (!isRelativeDrag) {\n                        _this.visualElement.rebaseProjectionTarget(true, _this.visualElement.measureViewportBox(false));\n                    }\n                    _this.visualElement.scheduleUpdateLayoutProjection();\n                    /**\n                     * When dragging starts, we want to find where the cursor is relative to the bounding box\n                     * of the element. Every frame, we calculate a new bounding box using this relative position\n                     * and let the visualElement renderer figure out how to reproject the element into this bounding\n                     * box.\n                     *\n                     * By doing it this way, rather than applying an x/y transform directly to the element,\n                     * we can ensure the component always visually sticks to the cursor as we'd expect, even\n                     * if the DOM element itself changes layout as a result of React updates the user might\n                     * make based on the drag position.\n                     */\n                    var projection = _this.visualElement.projection;\n                    eachAxis(function (axis) {\n                        if (!hasManuallySetCursorOrigin) {\n                            var _a = projection.target[axis], min = _a.min, max = _a.max;\n                            _this.cursorProgress[axis] = cursorProgress\n                                ? cursorProgress[axis]\n                                : popmotion.progress(min, max, initialPoint[axis]);\n                        }\n                        /**\n                         * If we have external drag MotionValues, record their origin point. On pointermove\n                         * we'll apply the pan gesture offset directly to this value.\n                         */\n                        var axisValue = _this.getAxisMotionValue(axis);\n                        if (axisValue) {\n                            _this.originPoint[axis] = axisValue.get();\n                        }\n                    });\n                });\n                write(function () {\n                    sync.flushSync.update();\n                    sync.flushSync.preRender();\n                    sync.flushSync.render();\n                    sync.flushSync.postRender();\n                });\n                read(function () { return _this.resolveDragConstraints(); });\n            });\n        };\n        var onStart = function (event, info) {\n            var _a, _b, _c;\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            var _d = _this.props, drag = _d.drag, dragPropagation = _d.dragPropagation;\n            if (drag && !dragPropagation) {\n                if (_this.openGlobalLock)\n                    _this.openGlobalLock();\n                _this.openGlobalLock = getGlobalLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!_this.openGlobalLock)\n                    return;\n            }\n            flushLayout();\n            // Set current drag status\n            _this.isDragging = true;\n            _this.currentDirection = null;\n            // Fire onDragStart event\n            (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n            (_c = _this.visualElement.animationState) === null || _c === void 0 ? void 0 : _c.setActive(AnimationType.Drag, true);\n        };\n        var onMove = function (event, info) {\n            var _a, _b, _c, _d;\n            var _e = _this.props, dragPropagation = _e.dragPropagation, dragDirectionLock = _e.dragDirectionLock;\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !_this.openGlobalLock)\n                return;\n            var offset = info.offset;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && _this.currentDirection === null) {\n                _this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (_this.currentDirection !== null) {\n                    (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            _this.updateAxis(\"x\", info.point, offset);\n            _this.updateAxis(\"y\", info.point, offset);\n            // Fire onDrag event\n            (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);\n            // Update the last pointer event\n            lastPointerEvent = event;\n        };\n        var onSessionEnd = function (event, info) {\n            return _this.stop(event, info);\n        };\n        var transformPagePoint = this.props.transformPagePoint;\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart: onSessionStart,\n            onStart: onStart,\n            onMove: onMove,\n            onSessionEnd: onSessionEnd,\n        }, { transformPagePoint: transformPagePoint });\n    };\n    VisualElementDragControls.prototype.resolveDragConstraints = function () {\n        var _this = this;\n        var _a = this.props, dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;\n        var layout = this.visualElement.getLayoutState().layoutCorrected;\n        if (dragConstraints) {\n            this.constraints = isRefObject(dragConstraints)\n                ? this.resolveRefConstraints(layout, dragConstraints)\n                : calcRelativeConstraints(layout, dragConstraints);\n        }\n        else {\n            this.constraints = false;\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (this.constraints && !this.hasMutatedConstraints) {\n            eachAxis(function (axis) {\n                if (_this.getAxisMotionValue(axis)) {\n                    _this.constraints[axis] = rebaseAxisConstraints(layout[axis], _this.constraints[axis]);\n                }\n            });\n        }\n    };\n    VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\n        var _a = this.props, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;\n        var constraintsElement = constraints.current;\n        heyListen.invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n        this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\n        var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    };\n    VisualElementDragControls.prototype.cancelDrag = function () {\n        var _a, _b;\n        this.visualElement.unlockProjectionTarget();\n        (_a = this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(this);\n        this.isDragging = false;\n        this.panSession && this.panSession.end();\n        this.panSession = null;\n        if (!this.props.dragPropagation && this.openGlobalLock) {\n            this.openGlobalLock();\n            this.openGlobalLock = null;\n        }\n        (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);\n    };\n    VisualElementDragControls.prototype.stop = function (event, info) {\n        var _a, _b, _c;\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n        this.panSession = null;\n        var isDragging = this.isDragging;\n        this.cancelDrag();\n        if (!isDragging)\n            return;\n        var velocity = info.velocity;\n        this.animateDragEnd(velocity);\n        (_c = (_b = this.props).onDragEnd) === null || _c === void 0 ? void 0 : _c.call(_b, event, info);\n    };\n    VisualElementDragControls.prototype.snapToCursor = function (point) {\n        var _this = this;\n        return eachAxis(function (axis) {\n            var drag = _this.props.drag;\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, _this.currentDirection))\n                return;\n            var axisValue = _this.getAxisMotionValue(axis);\n            if (axisValue) {\n                var box = _this.visualElement.getLayoutState().layout;\n                var length_1 = box[axis].max - box[axis].min;\n                var center = box[axis].min + length_1 / 2;\n                var offset = point[axis] - center;\n                _this.originPoint[axis] = point[axis];\n                axisValue.set(offset);\n            }\n            else {\n                _this.cursorProgress[axis] = 0.5;\n                return true;\n            }\n        }).includes(true);\n    };\n    /**\n     * Update the specified axis with the latest pointer information.\n     */\n    VisualElementDragControls.prototype.updateAxis = function (axis, point, offset) {\n        var drag = this.props.drag;\n        // If we're not dragging this axis, do an early return.\n        if (!shouldDrag(axis, drag, this.currentDirection))\n            return;\n        return this.getAxisMotionValue(axis)\n            ? this.updateAxisMotionValue(axis, offset)\n            : this.updateVisualElementAxis(axis, point);\n    };\n    VisualElementDragControls.prototype.updateAxisMotionValue = function (axis, offset) {\n        var axisValue = this.getAxisMotionValue(axis);\n        if (!offset || !axisValue)\n            return;\n        var nextValue = this.originPoint[axis] + offset[axis];\n        var update = this.constraints\n            ? applyConstraints(nextValue, this.constraints[axis], this.elastic[axis])\n            : nextValue;\n        axisValue.set(update);\n    };\n    VisualElementDragControls.prototype.updateVisualElementAxis = function (axis, point) {\n        var _a;\n        // Get the actual layout bounding box of the element\n        var axisLayout = this.visualElement.getLayoutState().layout[axis];\n        // Calculate its current length. In the future we might want to lerp this to animate\n        // between lengths if the layout changes as we change the DOM\n        var axisLength = axisLayout.max - axisLayout.min;\n        // Get the initial progress that the pointer sat on this axis on gesture start.\n        var axisProgress = this.cursorProgress[axis];\n        // Calculate a new min point based on the latest pointer position, constraints and elastic\n        var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], this.elastic[axis]);\n        // Update the axis viewport target with this new min and the length\n        this.visualElement.setProjectionTargetAxis(axis, min, min + axisLength);\n    };\n    VisualElementDragControls.prototype.setProps = function (_a) {\n        var _b = _a.drag, drag = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? defaultElastic : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = tslib.__rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n        this.props = tslib.__assign({ drag: drag,\n            dragDirectionLock: dragDirectionLock,\n            dragPropagation: dragPropagation,\n            dragConstraints: dragConstraints,\n            dragElastic: dragElastic,\n            dragMomentum: dragMomentum }, remainingProps);\n    };\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - If the component will perform layout animations, we output the gesture to the component's\n     *      visual bounding box\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    VisualElementDragControls.prototype.getAxisMotionValue = function (axis) {\n        var _a = this.props, layout = _a.layout, layoutId = _a.layoutId;\n        var dragKey = \"_drag\" + axis.toUpperCase();\n        if (this.props[dragKey]) {\n            return this.props[dragKey];\n        }\n        else if (!layout && layoutId === undefined) {\n            return this.visualElement.getValue(axis, 0);\n        }\n    };\n    VisualElementDragControls.prototype.isLayoutDrag = function () {\n        return !this.getAxisMotionValue(\"x\");\n    };\n    VisualElementDragControls.prototype.isExternalDrag = function () {\n        var _a = this.props, _dragX = _a._dragX, _dragY = _a._dragY;\n        return _dragX || _dragY;\n    };\n    VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n        var _this = this;\n        var _a = this.props, drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition;\n        /**\n         * Everything beyond the drag gesture should be performed with\n         * relative projection so children stay in sync with their parent element.\n         */\n        var isRelative = convertToRelativeProjection(this.visualElement, this.isLayoutDrag() && !this.isExternalDrag());\n        /**\n         * If we had previously resolved constraints relative to the viewport,\n         * we need to also convert those to a relative coordinate space for the animation\n         */\n        var constraints = this.constraints || {};\n        if (isRelative &&\n            Object.keys(constraints).length &&\n            this.isLayoutDrag()) {\n            var projectionParent = this.visualElement.getProjectionParent();\n            if (projectionParent) {\n                var relativeConstraints_1 = calcRelativeOffset(projectionParent.projection.targetFinal, constraints);\n                eachAxis(function (axis) {\n                    var _a = relativeConstraints_1[axis], min = _a.min, max = _a.max;\n                    constraints[axis] = {\n                        min: isNaN(min) ? undefined : min,\n                        max: isNaN(max) ? undefined : max,\n                    };\n                });\n            }\n        }\n        var momentumAnimations = eachAxis(function (axis) {\n            var _a;\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\n                return;\n            }\n            var transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            var bounceStiffness = dragElastic ? 200 : 1000000;\n            var bounceDamping = dragElastic ? 40 : 10000000;\n            var inertia = tslib.__assign(tslib.__assign({ type: \"inertia\", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness,\n                bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition);\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return _this.getAxisMotionValue(axis)\n                ? _this.startAxisValueAnimation(axis, inertia)\n                : _this.visualElement.startLayoutAnimation(axis, inertia, isRelative);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(function () {\n            var _a, _b;\n            (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n    };\n    VisualElementDragControls.prototype.stopMotion = function () {\n        var _this = this;\n        eachAxis(function (axis) {\n            var axisValue = _this.getAxisMotionValue(axis);\n            axisValue\n                ? axisValue.stop()\n                : _this.visualElement.stopLayoutAnimation();\n        });\n    };\n    VisualElementDragControls.prototype.startAxisValueAnimation = function (axis, transition) {\n        var axisValue = this.getAxisMotionValue(axis);\n        if (!axisValue)\n            return;\n        var currentValue = axisValue.get();\n        axisValue.set(currentValue);\n        axisValue.set(currentValue); // Set twice to hard-reset velocity\n        return startAnimation(axis, axisValue, 0, transition);\n    };\n    VisualElementDragControls.prototype.scalePoint = function () {\n        var _this = this;\n        var _a = this.props, drag = _a.drag, dragConstraints = _a.dragConstraints;\n        if (!isRefObject(dragConstraints) || !this.constraintsBox)\n            return;\n        // Stop any current animations as there can be some visual glitching if we resize mid animation\n        this.stopMotion();\n        // Record the relative progress of the targetBox relative to the constraintsBox\n        var boxProgress = { x: 0, y: 0 };\n        eachAxis(function (axis) {\n            boxProgress[axis] = calcOrigin(_this.visualElement.projection.target[axis], _this.constraintsBox[axis]);\n        });\n        /**\n         * For each axis, calculate the current progress of the layout axis within the constraints.\n         * Then, using the latest layout and constraints measurements, reposition the new layout axis\n         * proportionally within the constraints.\n         */\n        this.updateConstraints(function () {\n            eachAxis(function (axis) {\n                if (!shouldDrag(axis, drag, null))\n                    return;\n                // Calculate the position of the targetBox relative to the constraintsBox using the\n                // previously calculated progress\n                var _a = calcPositionFromProgress(_this.visualElement.projection.target[axis], _this.constraintsBox[axis], boxProgress[axis]), min = _a.min, max = _a.max;\n                _this.visualElement.setProjectionTargetAxis(axis, min, max);\n            });\n        });\n        /**\n         * If any other draggable components are queuing the same tasks synchronously\n         * this will wait until they've all been scheduled before flushing.\n         */\n        setTimeout(flushLayout, 1);\n    };\n    VisualElementDragControls.prototype.updateConstraints = function (onReady) {\n        var _this = this;\n        this.cancelLayout = batchLayout(function (read, write) {\n            var ancestors = collectProjectingAncestors(_this.visualElement);\n            write(function () {\n                return ancestors.forEach(function (element) { return element.resetTransform(); });\n            });\n            read(function () { return updateLayoutMeasurement(_this.visualElement); });\n            write(function () {\n                return ancestors.forEach(function (element) { return element.restoreTransform(); });\n            });\n            read(function () {\n                _this.resolveDragConstraints();\n            });\n            if (onReady)\n                write(onReady);\n        });\n    };\n    VisualElementDragControls.prototype.mount = function (visualElement) {\n        var _this = this;\n        var element = visualElement.getInstance();\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n            var _a = _this.props, drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\n            drag && dragListener && _this.start(event);\n        });\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        var stopResizeListener = addDomEvent(window, \"resize\", function () {\n            _this.scalePoint();\n        });\n        /**\n         * Ensure drag constraints are resolved correctly relative to the dragging element\n         * whenever its layout changes.\n         */\n        var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\n            if (_this.isDragging) {\n                _this.resolveDragConstraints();\n            }\n        });\n        /**\n         * If the previous component with this same layoutId was dragging at the time\n         * it was unmounted, we want to continue the same gesture on this component.\n         */\n        var prevDragCursor = visualElement.prevDragCursor;\n        if (prevDragCursor) {\n            this.start(lastPointerEvent, { cursorProgress: prevDragCursor });\n        }\n        /**\n         * Return a function that will teardown the drag gesture\n         */\n        return function () {\n            stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\n            stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\n            stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n            _this.cancelDrag();\n        };\n    };\n    return VisualElementDragControls;\n}());\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold) {\n    if (lockThreshold === void 0) { lockThreshold = 10; }\n    var direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n\n/**\n * A hook that allows an element to be dragged.\n *\n * @internal\n */\nfunction useDrag(props) {\n    var groupDragControls = props.dragControls, visualElement = props.visualElement;\n    var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n    var dragControls = useConstant(function () {\n        return new VisualElementDragControls({\n            visualElement: visualElement,\n        });\n    });\n    dragControls.setProps(tslib.__assign(tslib.__assign({}, props), { transformPagePoint: transformPagePoint }));\n    // If we've been provided a DragControls for manual control over the drag gesture,\n    // subscribe this component to it on mount.\n    React.useEffect(function () { return groupDragControls && groupDragControls.subscribe(dragControls); }, [dragControls]);\n    // Mount the drag controls with the visualElement\n    React.useEffect(function () { return dragControls.mount(visualElement); }, []);\n}\n\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @internalremarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */\nfunction usePanGesture(_a) {\n    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart, visualElement = _a.visualElement;\n    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n    var panSession = React.useRef(null);\n    var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n    var handlers = {\n        onSessionStart: onPanSessionStart,\n        onStart: onPanStart,\n        onMove: onPan,\n        onEnd: function (event, info) {\n            panSession.current = null;\n            onPanEnd && onPanEnd(event, info);\n        },\n    };\n    React.useEffect(function () {\n        if (panSession.current !== null) {\n            panSession.current.updateHandlers(handlers);\n        }\n    });\n    function onPointerDown(event) {\n        panSession.current = new PanSession(event, handlers, {\n            transformPagePoint: transformPagePoint,\n        });\n    }\n    usePointerEvent(visualElement, \"pointerdown\", hasPanEvents && onPointerDown);\n    useUnmountEffect(function () { return panSession.current && panSession.current.end(); });\n}\n\nvar drag = {\n    pan: makeRenderlessComponent(usePanGesture),\n    drag: makeRenderlessComponent(useDrag),\n};\n\n/**\n * @public\n */\nvar Presence;\n(function (Presence) {\n    Presence[Presence[\"Entering\"] = 0] = \"Entering\";\n    Presence[Presence[\"Present\"] = 1] = \"Present\";\n    Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\n/**\n * @public\n */\nexports.VisibilityAction = void 0;\n(function (VisibilityAction) {\n    VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\n    VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\n})(exports.VisibilityAction || (exports.VisibilityAction = {}));\n\nfunction isCSSVariable(value) {\n    return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    var match = cssVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    var _a = tslib.__read(match, 3), token = _a[1], fallback = _a[2];\n    return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth) {\n    if (depth === void 0) { depth = 1; }\n    heyListen.invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n    var _a = tslib.__read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        return resolved.trim();\n    }\n    else if (isCSSVariable(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    }\n    else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n    var _b;\n    var target = tslib.__rest(_a, []);\n    var element = visualElement.getInstance();\n    if (!(element instanceof HTMLElement))\n        return { target: target, transitionEnd: transitionEnd };\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = tslib.__assign({}, transitionEnd);\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.forEachValue(function (value) {\n        var current = value.get();\n        if (!isCSSVariable(current))\n            return;\n        var resolved = getVariableValue(current, element);\n        if (resolved)\n            value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for (var key in target) {\n        var current = target[key];\n        if (!isCSSVariable(current))\n            continue;\n        var resolved = getVariableValue(current, element);\n        if (!resolved)\n            continue;\n        // Clone target if it hasn't already been\n        target[key] = resolved;\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd)\n            (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : (transitionEnd[key] = current);\n    }\n    return { target: target, transitionEnd: transitionEnd };\n}\n\nfunction pixelsToPercent(pixels, axis) {\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nfunction correctBorderRadius(latest, _layoutState, _a) {\n    var target = _a.target;\n    /**\n     * If latest is a string, if it's a percentage we can return immediately as it's\n     * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n     */\n    if (typeof latest === \"string\") {\n        if (styleValueTypes.px.test(latest)) {\n            latest = parseFloat(latest);\n        }\n        else {\n            return latest;\n        }\n    }\n    /**\n     * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n     * pixel value as a percentage of each axis\n     */\n    var x = pixelsToPercent(latest, target.x);\n    var y = pixelsToPercent(latest, target.y);\n    return x + \"% \" + y + \"%\";\n}\nvar varToken = \"_$css\";\nfunction correctBoxShadow(latest, _a) {\n    var delta = _a.delta, treeScale = _a.treeScale;\n    var original = latest;\n    /**\n     * We need to first strip and store CSS variables from the string.\n     */\n    var containsCSSVariables = latest.includes(\"var(\");\n    var cssVariables = [];\n    if (containsCSSVariables) {\n        latest = latest.replace(cssVariableRegex, function (match) {\n            cssVariables.push(match);\n            return varToken;\n        });\n    }\n    var shadow = styleValueTypes.complex.parse(latest);\n    // TODO: Doesn't support multiple shadows\n    if (shadow.length > 5)\n        return original;\n    var template = styleValueTypes.complex.createTransformer(latest);\n    var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n    // Calculate the overall context scale\n    var xScale = delta.x.scale * treeScale.x;\n    var yScale = delta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    /**\n     * Ideally we'd correct x and y scales individually, but because blur and\n     * spread apply to both we have to take a scale average and apply that instead.\n     * We could potentially improve the outcome of this by incorporating the ratio between\n     * the two scales.\n     */\n    var averageScale = popmotion.mix(xScale, yScale, 0.5);\n    // Blur\n    if (typeof shadow[2 + offset] === \"number\")\n        shadow[2 + offset] /= averageScale;\n    // Spread\n    if (typeof shadow[3 + offset] === \"number\")\n        shadow[3 + offset] /= averageScale;\n    var output = template(shadow);\n    if (containsCSSVariables) {\n        var i_1 = 0;\n        output = output.replace(varToken, function () {\n            var cssVariable = cssVariables[i_1];\n            i_1++;\n            return cssVariable;\n        });\n    }\n    return output;\n}\nvar borderCorrectionDefinition = {\n    process: correctBorderRadius,\n};\nvar defaultScaleCorrectors = {\n    borderRadius: tslib.__assign(tslib.__assign({}, borderCorrectionDefinition), { applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ] }),\n    borderTopLeftRadius: borderCorrectionDefinition,\n    borderTopRightRadius: borderCorrectionDefinition,\n    borderBottomLeftRadius: borderCorrectionDefinition,\n    borderBottomRightRadius: borderCorrectionDefinition,\n    boxShadow: {\n        process: correctBoxShadow,\n    },\n};\n\nvar progressTarget = 1000;\nvar Animate = /** @class */ (function (_super) {\n    tslib.__extends(Animate, _super);\n    function Animate() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A mutable object that tracks the target viewport box\n         * for the current animation frame.\n         */\n        _this.frameTarget = axisBox();\n        /**\n         * The current animation target, we use this to check whether to start\n         * a new animation or continue the existing one.\n         */\n        _this.currentAnimationTarget = axisBox();\n        /**\n         * Track whether we're animating this axis.\n         */\n        _this.isAnimating = {\n            x: false,\n            y: false,\n        };\n        _this.stopAxisAnimation = {\n            x: undefined,\n            y: undefined,\n        };\n        _this.isAnimatingTree = false;\n        _this.animate = function (target, origin, _a) {\n            if (_a === void 0) { _a = {}; }\n            var originBox = _a.originBox, targetBox = _a.targetBox, visibilityAction = _a.visibilityAction, shouldStackAnimate = _a.shouldStackAnimate, onComplete = _a.onComplete, prevParent = _a.prevParent, config = tslib.__rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\", \"shouldStackAnimate\", \"onComplete\", \"prevParent\"]);\n            var _b = _this.props, visualElement = _b.visualElement, layout = _b.layout;\n            /**\n             * Early return if we've been instructed not to animate this render.\n             */\n            if (shouldStackAnimate === false) {\n                _this.isAnimatingTree = false;\n                return _this.safeToRemove();\n            }\n            /**\n             * Prioritise tree animations\n             */\n            if (_this.isAnimatingTree && shouldStackAnimate !== true) {\n                return;\n            }\n            else if (shouldStackAnimate) {\n                _this.isAnimatingTree = true;\n            }\n            /**\n             * Allow the measured origin (prev bounding box) and target (actual layout) to be\n             * overridden by the provided config.\n             */\n            origin = originBox || origin;\n            target = targetBox || target;\n            /**\n             * If this element has a projecting parent, there's an opportunity to animate\n             * it relatively to that parent rather than relatively to the viewport. This\n             * allows us to add orchestrated animations.\n             */\n            var isRelative = false;\n            var projectionParent = visualElement.getProjectionParent();\n            if (projectionParent) {\n                var prevParentViewportBox = projectionParent.prevViewportBox;\n                var parentLayout = projectionParent.getLayoutState().layout;\n                /**\n                 * If we're being provided a previous parent VisualElement by AnimateSharedLayout\n                 */\n                if (prevParent) {\n                    /**\n                     * If we've been provided an explicit target box it means we're animating back\n                     * to this previous parent. So we can make a relative box by comparing to the previous\n                     * parent's layout\n                     */\n                    if (targetBox) {\n                        parentLayout = prevParent.getLayoutState().layout;\n                    }\n                    /**\n                     * Likewise if we've been provided an explicit origin box it means we're\n                     * animating out from a different element. So we should figure out where that was\n                     * on screen relative to the new parent element.\n                     */\n                    if (originBox &&\n                        !checkIfParentHasChanged(prevParent, projectionParent) &&\n                        prevParent.prevViewportBox) {\n                        prevParentViewportBox = prevParent.prevViewportBox;\n                    }\n                }\n                if (prevParentViewportBox &&\n                    isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox)) {\n                    isRelative = true;\n                    origin = calcRelativeOffset(prevParentViewportBox, origin);\n                    target = calcRelativeOffset(parentLayout, target);\n                }\n            }\n            var boxHasMoved = hasMoved(origin, target);\n            var animations = eachAxis(function (axis) {\n                var _a, _b;\n                /**\n                 * If layout is set to \"position\", we can resize the origin box based on the target\n                 * box and only animate its position.\n                 */\n                if (layout === \"position\") {\n                    var targetLength = target[axis].max - target[axis].min;\n                    origin[axis].max = origin[axis].min + targetLength;\n                }\n                if (visualElement.projection.isTargetLocked) {\n                    return;\n                }\n                else if (visibilityAction !== undefined) {\n                    visualElement.setVisibility(visibilityAction === exports.VisibilityAction.Show);\n                }\n                else if (boxHasMoved) {\n                    // If the box has moved, animate between it's current visual state and its\n                    // final state\n                    return _this.animateAxis(axis, target[axis], origin[axis], tslib.__assign(tslib.__assign({}, config), { isRelative: isRelative }));\n                }\n                else {\n                    (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    // If the box has remained in the same place, immediately set the axis target\n                    // to the final desired state\n                    return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max, isRelative);\n                }\n            });\n            // Force a render to ensure there's no flash of uncorrected bounding box.\n            visualElement.syncRender();\n            /**\n             * If this visualElement isn't present (ie it's been removed from the tree by the user but\n             * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n             * have successfully finished.\n             */\n            return Promise.all(animations).then(function () {\n                _this.isAnimatingTree = false;\n                onComplete && onComplete();\n                visualElement.notifyLayoutAnimationComplete();\n            });\n        };\n        return _this;\n    }\n    Animate.prototype.componentDidMount = function () {\n        var _this = this;\n        var visualElement = this.props.visualElement;\n        visualElement.animateMotionValue = startAnimation;\n        visualElement.enableLayoutProjection();\n        this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n        visualElement.layoutSafeToRemove = function () { return _this.safeToRemove(); };\n        addScaleCorrection(defaultScaleCorrectors);\n    };\n    Animate.prototype.componentWillUnmount = function () {\n        var _this = this;\n        this.unsubLayoutReady();\n        eachAxis(function (axis) { var _a, _b; return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a); });\n    };\n    /**\n     * TODO: This manually performs animations on the visualElement's layout progress\n     * values. It'd be preferable to amend the startLayoutAxisAnimation\n     * API to accept more custom animations like this.\n     */\n    Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n        var _this = this;\n        var _b, _c;\n        var _d = _a === void 0 ? {} : _a, transition = _d.transition, isRelative = _d.isRelative;\n        /**\n         * If we're not animating to a new target, don't run this animation\n         */\n        if (this.isAnimating[axis] &&\n            axisIsEqual(target, this.currentAnimationTarget[axis])) {\n            return;\n        }\n        (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n        this.isAnimating[axis] = true;\n        var visualElement = this.props.visualElement;\n        var frameTarget = this.frameTarget[axis];\n        var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];\n        /**\n         * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n         * be re-incoporated into a subsequent spring animation.\n         */\n        layoutProgress.clearListeners();\n        layoutProgress.set(0);\n        layoutProgress.set(0);\n        /**\n         * Create an animation function to run once per frame. This will tween the visual bounding box from\n         * origin to target using the latest progress value.\n         */\n        var frame = function () {\n            // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n            var p = layoutProgress.get() / progressTarget;\n            // Tween the axis and update the visualElement with the latest values\n            tweenAxis(frameTarget, origin, target, p);\n            visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max, isRelative);\n        };\n        // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n        frame();\n        // Create a function to stop animation on this specific axis\n        var unsubscribeProgress = layoutProgress.onChange(frame);\n        this.stopAxisAnimation[axis] = function () {\n            _this.isAnimating[axis] = false;\n            layoutProgress.stop();\n            unsubscribeProgress();\n        };\n        this.currentAnimationTarget[axis] = target;\n        var layoutTransition = transition ||\n            visualElement.getDefaultTransition() ||\n            defaultLayoutTransition;\n        // Start the animation on this axis\n        var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, \"layout\")).then(this.stopAxisAnimation[axis]);\n        return animation;\n    };\n    Animate.prototype.safeToRemove = function () {\n        var _a, _b;\n        (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    Animate.prototype.render = function () {\n        return null;\n    };\n    return Animate;\n}(React__namespace.Component));\nfunction AnimateLayoutContextProvider(props) {\n    var _a = tslib.__read(usePresence(), 2), safeToRemove = _a[1];\n    return React__namespace.createElement(Animate, tslib.__assign({}, props, { safeToRemove: safeToRemove }));\n}\nfunction hasMoved(a, b) {\n    return (!isZeroBox(a) &&\n        !isZeroBox(b) &&\n        (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y)));\n}\nvar zeroAxis = { min: 0, max: 0 };\nfunction isZeroBox(a) {\n    return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);\n}\nfunction axisIsEqual(a, b) {\n    return a.min === b.min && a.max === b.max;\n}\nvar defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\nfunction isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox) {\n    return prevParent || (!prevParent && !(originBox || targetBox));\n}\n\n/**\n * Default handlers for batching VisualElements\n */\nvar defaultHandler = {\n    layoutReady: function (child) { return child.notifyLayoutReady(); },\n};\n/**\n * Create a batcher to process VisualElements\n */\nfunction createBatcher() {\n    var queue = new Set();\n    return {\n        add: function (child) { return queue.add(child); },\n        flush: function (_a) {\n            var _b = _a === void 0 ? defaultHandler : _a, layoutReady = _b.layoutReady, parent = _b.parent;\n            batchLayout(function (read, write) {\n                var order = Array.from(queue).sort(compareByDepth);\n                var ancestors = parent\n                    ? collectProjectingAncestors(parent)\n                    : [];\n                write(function () {\n                    var allElements = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(order));\n                    allElements.forEach(function (element) { return element.resetTransform(); });\n                });\n                read(function () {\n                    order.forEach(updateLayoutMeasurement);\n                });\n                write(function () {\n                    ancestors.forEach(function (element) { return element.restoreTransform(); });\n                    order.forEach(layoutReady);\n                });\n                read(function () {\n                    /**\n                     * After all children have started animating, ensure any Entering components are set to Present.\n                     * If we add deferred animations (set up all animations and then start them in two loops) this\n                     * could be moved to the start loop. But it needs to happen after all the animations configs\n                     * are generated in AnimateSharedLayout as this relies on presence data\n                     */\n                    order.forEach(function (child) {\n                        if (child.isPresent)\n                            child.presence = Presence.Present;\n                    });\n                });\n                write(function () {\n                    /**\n                     * Starting these animations will have queued jobs on the frame loop. In some situations,\n                     * like when removing an element, these will be processed too late after the DOM is manipulated,\n                     * leaving a flash of incorrectly-projected content. By manually flushing these jobs\n                     * we ensure there's no flash.\n                     */\n                    sync.flushSync.preRender();\n                    sync.flushSync.render();\n                });\n                read(function () {\n                    /**\n                     * Schedule a callback at the end of the following frame to assign the latest projection\n                     * box to the prevViewportBox snapshot. Once global batching is in place this could be run\n                     * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\n                     * child attempts to calculate its previous relative position against a prevViewportBox\n                     * it will be against its latest projection box instead, as the snapshot is useless beyond this\n                     * render.\n                     */\n                    sync__default['default'].postRender(function () {\n                        return order.forEach(assignProjectionToSnapshot);\n                    });\n                    queue.clear();\n                });\n            });\n            // TODO: Need to find a layout-synchronous way of flushing this\n            flushLayout();\n        },\n    };\n}\nfunction assignProjectionToSnapshot(child) {\n    child.prevViewportBox = child.projection.target;\n}\n\nvar SharedLayoutContext = React.createContext(createBatcher());\n/**\n * @internal\n */\nvar FramerTreeLayoutContext = React.createContext(createBatcher());\nfunction isSharedLayout(context) {\n    return !!context.forceUpdate;\n}\n\n/**\n * This component is responsible for scheduling the measuring of the motion component\n */\nvar Measure = /** @class */ (function (_super) {\n    tslib.__extends(Measure, _super);\n    function Measure() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * If this is a child of a SyncContext, register the VisualElement with it on mount.\n     */\n    Measure.prototype.componentDidMount = function () {\n        var _a = this.props, syncLayout = _a.syncLayout, framerSyncLayout = _a.framerSyncLayout, visualElement = _a.visualElement;\n        isSharedLayout(syncLayout) && syncLayout.register(visualElement);\n        isSharedLayout(framerSyncLayout) &&\n            framerSyncLayout.register(visualElement);\n        visualElement.onUnmount(function () {\n            if (isSharedLayout(syncLayout)) {\n                syncLayout.remove(visualElement);\n            }\n            if (isSharedLayout(framerSyncLayout)) {\n                framerSyncLayout.remove(visualElement);\n            }\n        });\n    };\n    /**\n     * If this is a child of a SyncContext, notify it that it needs to re-render. It will then\n     * handle the snapshotting.\n     *\n     * If it is stand-alone component, add it to the batcher.\n     */\n    Measure.prototype.getSnapshotBeforeUpdate = function () {\n        var _a = this.props, syncLayout = _a.syncLayout, visualElement = _a.visualElement;\n        if (isSharedLayout(syncLayout)) {\n            syncLayout.syncUpdate();\n        }\n        else {\n            snapshotViewportBox(visualElement);\n            syncLayout.add(visualElement);\n        }\n        return null;\n    };\n    Measure.prototype.componentDidUpdate = function () {\n        var syncLayout = this.props.syncLayout;\n        if (!isSharedLayout(syncLayout))\n            syncLayout.flush();\n    };\n    Measure.prototype.render = function () {\n        return null;\n    };\n    return Measure;\n}(React__default['default'].Component));\nfunction MeasureContextProvider(props) {\n    var syncLayout = React.useContext(SharedLayoutContext);\n    var framerSyncLayout = React.useContext(FramerTreeLayoutContext);\n    return (React__default['default'].createElement(Measure, tslib.__assign({}, props, { syncLayout: syncLayout, framerSyncLayout: framerSyncLayout })));\n}\n\nvar layoutAnimations = {\n    measureLayout: MeasureContextProvider,\n    layoutAnimation: AnimateLayoutContextProvider,\n};\n\nvar createProjectionState = function () { return ({\n    isEnabled: false,\n    isHydrated: false,\n    isTargetLocked: false,\n    target: axisBox(),\n    targetFinal: axisBox(),\n}); };\nfunction createLayoutState() {\n    return {\n        isHydrated: false,\n        layout: axisBox(),\n        layoutCorrected: axisBox(),\n        treeScale: { x: 1, y: 1 },\n        delta: delta(),\n        deltaFinal: delta(),\n        deltaTransform: \"\",\n    };\n}\nvar zeroLayout = createLayoutState();\n\n/**\n * Build a transform style that takes a calculated delta between the element's current\n * space on screen and projects it into the desired space.\n */\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n    var x = _a.x, y = _a.y;\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    var xTranslate = x.translate / treeScale.x;\n    var yTranslate = y.translate / treeScale.y;\n    var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n    if (latestTransform) {\n        var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;\n        if (rotate)\n            transform += \"rotate(\" + rotate + \") \";\n        if (rotateX)\n            transform += \"rotateX(\" + rotateX + \") \";\n        if (rotateY)\n            transform += \"rotateY(\" + rotateY + \") \";\n    }\n    transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n    return !latestTransform && transform === identityProjection ? \"\" : transform;\n}\n/**\n * Take the calculated delta origin and apply it as a transform string.\n */\nfunction buildLayoutProjectionTransformOrigin(_a) {\n    var deltaFinal = _a.deltaFinal;\n    return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });\n\nvar names = [\n    \"LayoutMeasure\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutUpdate\",\n    \"ViewportBoxUpdate\",\n    \"Update\",\n    \"Render\",\n    \"AnimationComplete\",\n    \"LayoutAnimationComplete\",\n    \"AnimationStart\",\n    \"SetAxisTarget\",\n    \"Unmount\",\n];\nfunction createLifecycles() {\n    var managers = names.map(function () { return new SubscriptionManager(); });\n    var propSubscriptions = {};\n    var lifecycles = {\n        clearAllListeners: function () { return managers.forEach(function (manager) { return manager.clear(); }); },\n        updatePropListeners: function (props) {\n            return names.forEach(function (name) {\n                var _a;\n                (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);\n                var on = \"on\" + name;\n                var propListener = props[on];\n                if (propListener) {\n                    propSubscriptions[name] = lifecycles[on](propListener);\n                }\n            });\n        },\n    };\n    managers.forEach(function (manager, i) {\n        lifecycles[\"on\" + names[i]] = function (handler) { return manager.add(handler); };\n        lifecycles[\"notify\" + names[i]] = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return manager.notify.apply(manager, tslib.__spreadArray([], tslib.__read(args)));\n        };\n    });\n    return lifecycles;\n}\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n    var _a;\n    for (var key in next) {\n        var nextValue = next[key];\n        var prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */\n            element.addValue(key, nextValue);\n        }\n        else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping to a new motion value, create a new motion value\n             * from that\n             */\n            element.addValue(key, motionValue(nextValue));\n        }\n        else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                var existingValue = element.getValue(key);\n                // TODO: Only update values that aren't being animated or even looked at\n                !existingValue.hasAnimated && existingValue.set(nextValue);\n            }\n            else {\n                element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));\n            }\n        }\n    }\n    // Handle removed values\n    for (var key in prev) {\n        if (next[key] === undefined)\n            element.removeValue(key);\n    }\n    return next;\n}\n\nfunction updateLayoutDeltas(_a, _b, treePath, transformOrigin) {\n    var delta = _a.delta, layout = _a.layout, layoutCorrected = _a.layoutCorrected, treeScale = _a.treeScale;\n    var target = _b.target;\n    /**\n     * Reset the corrected box with the latest values from box, as we're then going\n     * to perform mutative operations on it.\n     */\n    resetBox(layoutCorrected, layout);\n    /**\n     * Apply all the parent deltas to this box to produce the corrected box. This\n     * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n     */\n    applyTreeDeltas(layoutCorrected, treeScale, treePath);\n    /**\n     * Update the delta between the corrected box and the target box before user-set transforms were applied.\n     * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n     * for our layout reprojection, but still allow them to be scaled correctly by the user.\n     * It might be that to simplify this we may want to accept that user-set scale is also corrected\n     * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n     * to allow people to choose whether these styles are corrected based on just the\n     * layout reprojection or the final bounding box.\n     */\n    updateBoxDelta(delta, layoutCorrected, target, transformOrigin);\n}\n\nvar FlatTree = /** @class */ (function () {\n    function FlatTree() {\n        this.children = [];\n        this.isDirty = false;\n    }\n    FlatTree.prototype.add = function (child) {\n        addUniqueItem(this.children, child);\n        this.isDirty = true;\n    };\n    FlatTree.prototype.remove = function (child) {\n        removeItem(this.children, child);\n        this.isDirty = true;\n    };\n    FlatTree.prototype.forEach = function (callback) {\n        this.isDirty && this.children.sort(compareByDepth);\n        this.isDirty = false;\n        this.children.forEach(callback);\n    };\n    return FlatTree;\n}());\n\nfunction setCurrentViewportBox(visualElement) {\n    var projectionParent = visualElement.getProjectionParent();\n    if (!projectionParent) {\n        visualElement.rebaseProjectionTarget();\n        return;\n    }\n    var relativeOffset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\n    eachAxis(function (axis) {\n        visualElement.setProjectionTargetAxis(axis, relativeOffset[axis].min, relativeOffset[axis].max, true);\n    });\n}\n\nvar visualElement = function (_a) {\n    var _b = _a.treeType, treeType = _b === void 0 ? \"\" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, resetTransform = _a.resetTransform, restoreTransform = _a.restoreTransform, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n    return function (_a, options) {\n        var parent = _a.parent, props = _a.props, presenceId = _a.presenceId, blockInitialAnimation = _a.blockInitialAnimation, visualState = _a.visualState;\n        if (options === void 0) { options = {}; }\n        var latestValues = visualState.latestValues, renderState = visualState.renderState;\n        /**\n         * The instance of the render-specific node that will be hydrated by the\n         * exposed React ref. So for example, this visual element can host a\n         * HTMLElement, plain object, or Three.js object. The functions provided\n         * in VisualElementConfig allow us to interface with this instance.\n         */\n        var instance;\n        /**\n         * Manages the subscriptions for a visual element's lifecycle, for instance\n         * onRender and onViewportBoxUpdate.\n         */\n        var lifecycles = createLifecycles();\n        /**\n         *\n         */\n        var projection = createProjectionState();\n        /**\n         * A reference to the nearest projecting parent. This is either\n         * undefined if we haven't looked for the nearest projecting parent,\n         * false if there is no parent performing layout projection, or a reference\n         * to the projecting parent.\n         */\n        var projectionParent;\n        /**\n         * This is a reference to the visual state of the \"lead\" visual element.\n         * Usually, this will be this visual element. But if it shares a layoutId\n         * with other visual elements, only one of them will be designated lead by\n         * AnimateSharedLayout. All the other visual elements will take on the visual\n         * appearance of the lead while they crossfade to it.\n         */\n        var leadProjection = projection;\n        var leadLatestValues = latestValues;\n        var unsubscribeFromLeadVisualElement;\n        /**\n         * The latest layout measurements and calculated projections. This\n         * is seperate from the target projection data in visualState as\n         * many visual elements might point to the same piece of visualState as\n         * a target, whereas they might each have different layouts and thus\n         * projection calculations needed to project into the same viewport box.\n         */\n        var layoutState = createLayoutState();\n        /**\n         *\n         */\n        var crossfader;\n        /**\n         * Keep track of whether the viewport box has been updated since the\n         * last time the layout projection was re-calculated.\n         */\n        var hasViewportBoxUpdated = false;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        var values = new Map();\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        var valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        var prevMotionValues = {};\n        /**\n         * x/y motion values that track the progress of initiated layout\n         * animations.\n         *\n         * TODO: Target for removal\n         */\n        var projectionTargetProgress;\n        /**\n         * When values are removed from all animation props we need to search\n         * for a fallback value to animate to. These values are tracked in baseTarget.\n         */\n        var baseTarget = tslib.__assign({}, latestValues);\n        // Internal methods ========================\n        /**\n         * On mount, this will be hydrated with a callback to disconnect\n         * this visual element from its parent on unmount.\n         */\n        var removeFromVariantTree;\n        /**\n         *\n         */\n        function render() {\n            if (!instance)\n                return;\n            if (element.isProjectionReady()) {\n                /**\n                 * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n                 * This is the final box that we will then project into by calculating a transform delta and\n                 * applying it to the corrected box.\n                 */\n                applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);\n                /**\n                 * Update the delta between the corrected box and the final target box, after\n                 * user-set transforms are applied to it. This will be used by the renderer to\n                 * create a transform style that will reproject the element from its actual layout\n                 * into the desired bounding box.\n                 */\n                updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);\n            }\n            triggerBuild();\n            renderInstance(instance, renderState);\n        }\n        function triggerBuild() {\n            var valuesToRender = latestValues;\n            if (crossfader && crossfader.isActive()) {\n                var crossfadedValues = crossfader.getCrossfadeState(element);\n                if (crossfadedValues)\n                    valuesToRender = crossfadedValues;\n            }\n            build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);\n        }\n        function update() {\n            lifecycles.notifyUpdate(latestValues);\n        }\n        function updateLayoutProjection() {\n            if (!element.isProjectionReady())\n                return;\n            var delta = layoutState.delta, treeScale = layoutState.treeScale;\n            var prevTreeScaleX = treeScale.x;\n            var prevTreeScaleY = treeScale.y;\n            var prevDeltaTransform = layoutState.deltaTransform;\n            updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);\n            hasViewportBoxUpdated &&\n                element.notifyViewportBoxUpdate(leadProjection.target, delta);\n            hasViewportBoxUpdated = false;\n            var deltaTransform = buildLayoutProjectionTransform(delta, treeScale);\n            if (deltaTransform !== prevDeltaTransform ||\n                // Also compare calculated treeScale, for values that rely on this only for scale correction\n                prevTreeScaleX !== treeScale.x ||\n                prevTreeScaleY !== treeScale.y) {\n                element.scheduleRender();\n            }\n            layoutState.deltaTransform = deltaTransform;\n        }\n        function updateTreeLayoutProjection() {\n            element.layoutTree.forEach(fireUpdateLayoutProjection);\n        }\n        /**\n         *\n         */\n        function bindToMotionValue(key, value) {\n            var removeOnChange = value.onChange(function (latestValue) {\n                latestValues[key] = latestValue;\n                props.onUpdate && sync__default['default'].update(update, false, true);\n            });\n            var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n            valueSubscriptions.set(key, function () {\n                removeOnChange();\n                removeOnRenderRequest();\n            });\n        }\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\n         * more a reflection of the test.\n         */\n        var initialMotionValues = scrapeMotionValuesFromProps(props);\n        for (var key in initialMotionValues) {\n            var value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        var isControllingVariants = checkIfControllingVariants(props);\n        var isVariantNode = checkIfVariantNode(props);\n        var element = tslib.__assign(tslib.__assign({ treeType: treeType, \n            /**\n             * This is a mirror of the internal instance prop, which keeps\n             * VisualElement type-compatible with React's RefObject.\n             */\n            current: null, \n            /**\n             * The depth of this visual element within the visual element tree.\n             */\n            depth: parent ? parent.depth + 1 : 0, parent: parent, children: new Set(), \n            /**\n             * An ancestor path back to the root visual element. This is used\n             * by layout projection to quickly recurse back up the tree.\n             */\n            path: parent ? tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(parent.path)), [parent]) : [], layoutTree: parent ? parent.layoutTree : new FlatTree(), \n            /**\n             *\n             */\n            presenceId: presenceId,\n            projection: projection, \n            /**\n             * If this component is part of the variant tree, it should track\n             * any children that are also part of the tree. This is essentially\n             * a shadow tree to simplify logic around how to stagger over children.\n             */\n            variantChildren: isVariantNode ? new Set() : undefined, \n            /**\n             * Whether this instance is visible. This can be changed imperatively\n             * by AnimateSharedLayout, is analogous to CSS's visibility in that\n             * hidden elements should take up layout, and needs enacting by the configured\n             * render function.\n             */\n            isVisible: undefined, \n            /**\n             * Normally, if a component is controlled by a parent's variants, it can\n             * rely on that ancestor to trigger animations further down the tree.\n             * However, if a component is created after its parent is mounted, the parent\n             * won't trigger that mount animation so the child needs to.\n             *\n             * TODO: This might be better replaced with a method isParentMounted\n             */\n            manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()), \n            /**\n             * This can be set by AnimatePresence to force components that mount\n             * at the same time as it to mount as if they have initial={false} set.\n             */\n            blockInitialAnimation: blockInitialAnimation, \n            /**\n             * Determine whether this component has mounted yet. This is mostly used\n             * by variant children to determine whether they need to trigger their\n             * own animations on mount.\n             */\n            isMounted: function () { return Boolean(instance); }, mount: function (newInstance) {\n                instance = element.current = newInstance;\n                element.pointTo(element);\n                if (isVariantNode && parent && !isControllingVariants) {\n                    removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n                }\n                parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n            },\n            /**\n             *\n             */\n            unmount: function () {\n                sync.cancelSync.update(update);\n                sync.cancelSync.render(render);\n                sync.cancelSync.preRender(element.updateLayoutProjection);\n                valueSubscriptions.forEach(function (remove) { return remove(); });\n                element.stopLayoutAnimation();\n                element.layoutTree.remove(element);\n                removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n                parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n                lifecycles.clearAllListeners();\n            },\n            /**\n             * Add a child visual element to our set of children.\n             */\n            addVariantChild: function (child) {\n                var _a;\n                var closestVariantNode = element.getClosestVariantNode();\n                if (closestVariantNode) {\n                    (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n                    return function () { return closestVariantNode.variantChildren.delete(child); };\n                }\n            },\n            sortNodePosition: function (other) {\n                /**\n                 * If these nodes aren't even of the same type we can't compare their depth.\n                 */\n                if (!sortNodePosition || treeType !== other.treeType)\n                    return 0;\n                return sortNodePosition(element.getInstance(), other.getInstance());\n            }, \n            /**\n             * Returns the closest variant node in the tree starting from\n             * this visual element.\n             */\n            getClosestVariantNode: function () {\n                return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n            }, \n            /**\n             * A method that schedules an update to layout projections throughout\n             * the tree. We inherit from the parent so there's only ever one\n             * job scheduled on the next frame - that of the root visual element.\n             */\n            scheduleUpdateLayoutProjection: parent\n                ? parent.scheduleUpdateLayoutProjection\n                : function () {\n                    return sync__default['default'].preRender(element.updateTreeLayoutProjection, false, true);\n                }, \n            /**\n             * Expose the latest layoutId prop.\n             */\n            getLayoutId: function () { return props.layoutId; }, \n            /**\n             * Returns the current instance.\n             */\n            getInstance: function () { return instance; }, \n            /**\n             * Get/set the latest static values.\n             */\n            getStaticValue: function (key) { return latestValues[key]; }, setStaticValue: function (key, value) { return (latestValues[key] = value); }, \n            /**\n             * Returns the latest motion value state. Currently only used to take\n             * a snapshot of the visual element - perhaps this can return the whole\n             * visual state\n             */\n            getLatestValues: function () { return latestValues; }, \n            /**\n             * Set the visiblity of the visual element. If it's changed, schedule\n             * a render to reflect these changes.\n             */\n            setVisibility: function (visibility) {\n                if (element.isVisible === visibility)\n                    return;\n                element.isVisible = visibility;\n                element.scheduleRender();\n            },\n            /**\n             * Make a target animatable by Popmotion. For instance, if we're\n             * trying to animate width from 100px to 100vw we need to measure 100vw\n             * in pixels to determine what we really need to animate to. This is also\n             * pluggable to support Framer's custom value types like Color,\n             * and CSS variables.\n             */\n            makeTargetAnimatable: function (target, canMutate) {\n                if (canMutate === void 0) { canMutate = true; }\n                return makeTargetAnimatable(element, target, props, canMutate);\n            },\n            // Motion values ========================\n            /**\n             * Add a motion value and bind it to this visual element.\n             */\n            addValue: function (key, value) {\n                // Remove existing value if it exists\n                if (element.hasValue(key))\n                    element.removeValue(key);\n                values.set(key, value);\n                latestValues[key] = value.get();\n                bindToMotionValue(key, value);\n            },\n            /**\n             * Remove a motion value and unbind any active subscriptions.\n             */\n            removeValue: function (key) {\n                var _a;\n                values.delete(key);\n                (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n                valueSubscriptions.delete(key);\n                delete latestValues[key];\n                removeValueFromRenderState(key, renderState);\n            }, \n            /**\n             * Check whether we have a motion value for this key\n             */\n            hasValue: function (key) { return values.has(key); }, \n            /**\n             * Get a motion value for this key. If called with a default\n             * value, we'll create one if none exists.\n             */\n            getValue: function (key, defaultValue) {\n                var value = values.get(key);\n                if (value === undefined && defaultValue !== undefined) {\n                    value = motionValue(defaultValue);\n                    element.addValue(key, value);\n                }\n                return value;\n            }, \n            /**\n             * Iterate over our motion values.\n             */\n            forEachValue: function (callback) { return values.forEach(callback); }, \n            /**\n             * If we're trying to animate to a previously unencountered value,\n             * we need to check for it in our state and as a last resort read it\n             * directly from the instance (which might have performance implications).\n             */\n            readValue: function (key) { var _a; return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options); }, \n            /**\n             * Set the base target to later animate back to. This is currently\n             * only hydrated on creation and when we first read a value.\n             */\n            setBaseTarget: function (key, value) {\n                baseTarget[key] = value;\n            },\n            /**\n             * Find the base target for a value thats been removed from all animation\n             * props.\n             */\n            getBaseTarget: function (key) {\n                if (getBaseTarget) {\n                    var target = getBaseTarget(props, key);\n                    if (target !== undefined && !isMotionValue(target))\n                        return target;\n                }\n                return baseTarget[key];\n            } }, lifecycles), { \n            /**\n             * Build the renderer state based on the latest visual state.\n             */\n            build: function () {\n                triggerBuild();\n                return renderState;\n            },\n            /**\n             * Schedule a render on the next animation frame.\n             */\n            scheduleRender: function () {\n                sync__default['default'].render(render, false, true);\n            }, \n            /**\n             * Synchronously fire render. It's prefered that we batch renders but\n             * in many circumstances, like layout measurement, we need to run this\n             * synchronously. However in those instances other measures should be taken\n             * to batch reads/writes.\n             */\n            syncRender: render, \n            /**\n             * Update the provided props. Ensure any newly-added motion values are\n             * added to our map, old ones removed, and listeners updated.\n             */\n            setProps: function (newProps) {\n                props = newProps;\n                lifecycles.updatePropListeners(newProps);\n                prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n            }, getProps: function () { return props; }, \n            // Variants ==============================\n            /**\n             * Returns the variant definition with a given name.\n             */\n            getVariant: function (name) { var _a; return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name]; }, \n            /**\n             * Returns the defined default transition on this component.\n             */\n            getDefaultTransition: function () { return props.transition; }, \n            /**\n             * Used by child variant nodes to get the closest ancestor variant props.\n             */\n            getVariantContext: function (startAtParent) {\n                if (startAtParent === void 0) { startAtParent = false; }\n                if (startAtParent)\n                    return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n                if (!isControllingVariants) {\n                    var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n                    if (props.initial !== undefined) {\n                        context_1.initial = props.initial;\n                    }\n                    return context_1;\n                }\n                var context = {};\n                for (var i = 0; i < numVariantProps; i++) {\n                    var name_1 = variantProps[i];\n                    var prop = props[name_1];\n                    if (isVariantLabel(prop) || prop === false) {\n                        context[name_1] = prop;\n                    }\n                }\n                return context;\n            },\n            // Layout projection ==============================\n            /**\n             * Enable layout projection for this visual element. Won't actually\n             * occur until we also have hydrated layout measurements.\n             */\n            enableLayoutProjection: function () {\n                projection.isEnabled = true;\n                element.layoutTree.add(element);\n            },\n            /**\n             * Lock the projection target, for instance when dragging, so\n             * nothing else can try and animate it.\n             */\n            lockProjectionTarget: function () {\n                projection.isTargetLocked = true;\n            },\n            unlockProjectionTarget: function () {\n                element.stopLayoutAnimation();\n                projection.isTargetLocked = false;\n            }, getLayoutState: function () { return layoutState; }, setCrossfader: function (newCrossfader) {\n                crossfader = newCrossfader;\n            }, isProjectionReady: function () {\n                return projection.isEnabled &&\n                    projection.isHydrated &&\n                    layoutState.isHydrated;\n            }, \n            /**\n             * Start a layout animation on a given axis.\n             */\n            startLayoutAnimation: function (axis, transition, isRelative) {\n                if (isRelative === void 0) { isRelative = false; }\n                var progress = element.getProjectionAnimationProgress()[axis];\n                var _a = isRelative\n                    ? projection.relativeTarget[axis]\n                    : projection.target[axis], min = _a.min, max = _a.max;\n                var length = max - min;\n                progress.clearListeners();\n                progress.set(min);\n                progress.set(min); // Set twice to hard-reset velocity\n                progress.onChange(function (v) {\n                    element.setProjectionTargetAxis(axis, v, v + length, isRelative);\n                });\n                return element.animateMotionValue(axis, progress, 0, transition);\n            },\n            /**\n             * Stop layout animations.\n             */\n            stopLayoutAnimation: function () {\n                eachAxis(function (axis) {\n                    return element.getProjectionAnimationProgress()[axis].stop();\n                });\n            },\n            /**\n             * Measure the current viewport box with or without transforms.\n             * Only measures axis-aligned boxes, rotate and skew must be manually\n             * removed with a re-render to work.\n             */\n            measureViewportBox: function (withTransform) {\n                if (withTransform === void 0) { withTransform = true; }\n                var viewportBox = measureViewportBox(instance, options);\n                if (!withTransform)\n                    removeBoxTransforms(viewportBox, latestValues);\n                return viewportBox;\n            },\n            /**\n             * Get the motion values tracking the layout animations on each\n             * axis. Lazy init if not already created.\n             */\n            getProjectionAnimationProgress: function () {\n                projectionTargetProgress || (projectionTargetProgress = {\n                    x: motionValue(0),\n                    y: motionValue(0),\n                });\n                return projectionTargetProgress;\n            },\n            /**\n             * Update the projection of a single axis. Schedule an update to\n             * the tree layout projection.\n             */\n            setProjectionTargetAxis: function (axis, min, max, isRelative) {\n                if (isRelative === void 0) { isRelative = false; }\n                var target;\n                if (isRelative) {\n                    if (!projection.relativeTarget) {\n                        projection.relativeTarget = axisBox();\n                    }\n                    target = projection.relativeTarget[axis];\n                }\n                else {\n                    projection.relativeTarget = undefined;\n                    target = projection.target[axis];\n                }\n                projection.isHydrated = true;\n                target.min = min;\n                target.max = max;\n                // Flag that we want to fire the onViewportBoxUpdate event handler\n                hasViewportBoxUpdated = true;\n                lifecycles.notifySetAxisTarget();\n            },\n            /**\n             * Rebase the projection target on top of the provided viewport box\n             * or the measured layout. This ensures that non-animating elements\n             * don't fall out of sync differences in measurements vs projections\n             * after a page scroll or other relayout.\n             */\n            rebaseProjectionTarget: function (force, box) {\n                if (box === void 0) { box = layoutState.layout; }\n                var _a = element.getProjectionAnimationProgress(), x = _a.x, y = _a.y;\n                var shouldRebase = !projection.relativeTarget &&\n                    !projection.isTargetLocked &&\n                    !x.isAnimating() &&\n                    !y.isAnimating();\n                if (force || shouldRebase) {\n                    eachAxis(function (axis) {\n                        var _a = box[axis], min = _a.min, max = _a.max;\n                        element.setProjectionTargetAxis(axis, min, max);\n                    });\n                }\n            },\n            /**\n             * Notify the visual element that its layout is up-to-date.\n             * Currently Animate.tsx uses this to check whether a layout animation\n             * needs to be performed.\n             */\n            notifyLayoutReady: function (config) {\n                setCurrentViewportBox(element);\n                element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);\n            }, \n            /**\n             * Temporarily reset the transform of the instance.\n             */\n            resetTransform: function () { return resetTransform(element, instance, props); }, restoreTransform: function () { return restoreTransform(instance, renderState); }, updateLayoutProjection: updateLayoutProjection,\n            updateTreeLayoutProjection: function () {\n                element.layoutTree.forEach(fireResolveRelativeTargetBox);\n                /**\n                 * Schedule the projection updates at the end of the current preRender\n                 * step. This will ensure that all layout trees will first resolve\n                 * relative projection boxes into viewport boxes, and *then*\n                 * update projections.\n                 */\n                sync__default['default'].preRender(updateTreeLayoutProjection, false, true);\n                // sync.postRender(() => element.scheduleUpdateLayoutProjection())\n            },\n            getProjectionParent: function () {\n                if (projectionParent === undefined) {\n                    var foundParent = false;\n                    // Search backwards through the tree path\n                    for (var i = element.path.length - 1; i >= 0; i--) {\n                        var ancestor = element.path[i];\n                        if (ancestor.projection.isEnabled) {\n                            foundParent = ancestor;\n                            break;\n                        }\n                    }\n                    projectionParent = foundParent;\n                }\n                return projectionParent;\n            },\n            resolveRelativeTargetBox: function () {\n                var relativeParent = element.getProjectionParent();\n                if (!projection.relativeTarget || !relativeParent)\n                    return;\n                calcRelativeBox(projection, relativeParent.projection);\n                if (isDraggable(relativeParent)) {\n                    var target = projection.target;\n                    applyBoxTransforms(target, target, relativeParent.getLatestValues());\n                }\n            },\n            shouldResetTransform: function () {\n                return Boolean(props._layoutResetTransform);\n            },\n            /**\n             *\n             */\n            pointTo: function (newLead) {\n                leadProjection = newLead.projection;\n                leadLatestValues = newLead.getLatestValues();\n                /**\n                 * Subscribe to lead component's layout animations\n                 */\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n                unsubscribeFromLeadVisualElement = popmotion.pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function () {\n                    var _a;\n                    if (element.isPresent) {\n                        element.presence = Presence.Present;\n                    }\n                    else {\n                        (_a = element.layoutSafeToRemove) === null || _a === void 0 ? void 0 : _a.call(element);\n                    }\n                }));\n            }, \n            // TODO: Clean this up\n            isPresent: true, presence: Presence.Entering });\n        return element;\n    };\n};\nfunction fireResolveRelativeTargetBox(child) {\n    child.resolveRelativeTargetBox();\n}\nfunction fireUpdateLayoutProjection(child) {\n    child.updateLayoutProjection();\n}\nvar variantProps = tslib.__spreadArray([\"initial\"], tslib.__read(variantPriorityOrder));\nvar numVariantProps = variantProps.length;\n\nvar positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\",\n]);\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\nvar hasPositionalKey = function (target) {\n    return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = function (value, to) {\n    // Looks odd but setting it twice doesn't render, it'll just\n    // set both prev and current to the latest value\n    value.set(to, false);\n    value.set(to);\n};\nvar isNumOrPxType = function (v) {\n    return v === styleValueTypes.number || v === styleValueTypes.px;\n};\nvar BoundingBoxDimension;\n(function (BoundingBoxDimension) {\n    BoundingBoxDimension[\"width\"] = \"width\";\n    BoundingBoxDimension[\"height\"] = \"height\";\n    BoundingBoxDimension[\"left\"] = \"left\";\n    BoundingBoxDimension[\"right\"] = \"right\";\n    BoundingBoxDimension[\"top\"] = \"top\";\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = function (matrix, pos) {\n    return parseFloat(matrix.split(\", \")[pos]);\n};\nvar getTranslateFromMatrix = function (pos2, pos3) { return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform)\n        return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        var matrix = transform.match(/^matrix\\((.+)\\)$/);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n}; };\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });\nfunction removeNonTranslationalTransform(visualElement) {\n    var removedTransforms = [];\n    nonTranslationalTransformKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    // Apply changes to element before measurement\n    if (removedTransforms.length)\n        visualElement.syncRender();\n    return removedTransforms;\n}\nvar positionalValues = {\n    // Dimensions\n    width: function (_a) {\n        var x = _a.x;\n        return x.max - x.min;\n    },\n    height: function (_a) {\n        var y = _a.y;\n        return y.max - y.min;\n    },\n    top: function (_bbox, _a) {\n        var top = _a.top;\n        return parseFloat(top);\n    },\n    left: function (_bbox, _a) {\n        var left = _a.left;\n        return parseFloat(left);\n    },\n    bottom: function (_a, _b) {\n        var y = _a.y;\n        var top = _b.top;\n        return parseFloat(top) + (y.max - y.min);\n    },\n    right: function (_a, _b) {\n        var x = _a.x;\n        var left = _b.left;\n        return parseFloat(left) + (x.max - x.min);\n    },\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n    var originBbox = visualElement.measureViewportBox();\n    var element = visualElement.getInstance();\n    var elementComputedStyle = getComputedStyle(element);\n    var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;\n    var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform };\n    // If the element is currently set to display: \"none\", make it visible before\n    // measuring the target bounding box\n    if (display === \"none\") {\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\n    }\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n    visualElement.syncRender();\n    var targetBbox = visualElement.measureViewportBox();\n    changedKeys.forEach(function (key) {\n        // Restore styles to their **calculated computed style**, not their actual\n        // originally set style. This allows us to animate between equivalent pixel units.\n        var value = visualElement.getValue(key);\n        setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n    });\n    return target;\n};\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n    if (origin === void 0) { origin = {}; }\n    if (transitionEnd === void 0) { transitionEnd = {}; }\n    target = tslib.__assign({}, target);\n    transitionEnd = tslib.__assign({}, transitionEnd);\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n    // We want to remove any transform values that could affect the element's bounding box before\n    // it's measured. We'll reapply these later.\n    var removedTransformValues = [];\n    var hasAttemptedToRemoveTransformValues = false;\n    var changedValueTypeKeys = [];\n    targetPositionalKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (!visualElement.hasValue(key))\n            return;\n        var from = origin[key];\n        var to = target[key];\n        var fromType = findDimensionValueType(from);\n        var toType;\n        // TODO: The current implementation of this basically throws an error\n        // if you try and do value conversion via keyframes. There's probably\n        // a way of doing this but the performance implications would need greater scrutiny,\n        // as it'd be doing multiple resize-remeasure operations.\n        if (isKeyframesTarget(to)) {\n            var numKeyframes = to.length;\n            for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n                if (!toType) {\n                    toType = findDimensionValueType(to[i]);\n                    heyListen.invariant(toType === fromType ||\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\n                }\n                else {\n                    heyListen.invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n                }\n            }\n        }\n        else {\n            toType = findDimensionValueType(to);\n        }\n        if (fromType !== toType) {\n            // If they're both just number or px, convert them both to numbers rather than\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n                var current = value.get();\n                if (typeof current === \"string\") {\n                    value.set(parseFloat(current));\n                }\n                if (typeof to === \"string\") {\n                    target[key] = parseFloat(to);\n                }\n                else if (Array.isArray(to) && toType === styleValueTypes.px) {\n                    target[key] = to.map(parseFloat);\n                }\n            }\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\n                (from === 0 || to === 0)) {\n                // If one or the other value is 0, it's safe to coerce it to the\n                // type of the other without measurement\n                if (from === 0) {\n                    value.set(toType.transform(from));\n                }\n                else {\n                    target[key] = fromType.transform(to);\n                }\n            }\n            else {\n                // If we're going to do value conversion via DOM measurements, we first\n                // need to remove non-positional transform values that could affect the bbox measurements.\n                if (!hasAttemptedToRemoveTransformValues) {\n                    removedTransformValues = removeNonTranslationalTransform(visualElement);\n                    hasAttemptedToRemoveTransformValues = true;\n                }\n                changedValueTypeKeys.push(key);\n                transitionEnd[key] =\n                    transitionEnd[key] !== undefined\n                        ? transitionEnd[key]\n                        : target[key];\n                setAndResetVelocity(value, to);\n            }\n        }\n    });\n    if (changedValueTypeKeys.length) {\n        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n        // If we removed transform values, reapply them before the next render\n        if (removedTransformValues.length) {\n            removedTransformValues.forEach(function (_a) {\n                var _b = tslib.__read(_a, 2), key = _b[0], value = _b[1];\n                visualElement.getValue(key).set(value);\n            });\n        }\n        // Reapply original values\n        visualElement.syncRender();\n        return { target: convertedTarget, transitionEnd: transitionEnd };\n    }\n    else {\n        return { target: target, transitionEnd: transitionEnd };\n    }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n    return hasPositionalKey(target)\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\n        : { target: target, transitionEnd: transitionEnd };\n}\n\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\nvar parseDomVariant = function (visualElement, target, origin, transitionEnd) {\n    var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n    target = resolved.target;\n    transitionEnd = resolved.transitionEnd;\n    return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\nfunction getComputedStyle$1(element) {\n    return window.getComputedStyle(element);\n}\nvar htmlConfig = {\n    treeType: \"dom\",\n    readValueFromInstance: function (domElement, key) {\n        if (isTransformProp(key)) {\n            var defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            var computedStyle = getComputedStyle$1(domElement);\n            return ((isCSSVariable$1(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0);\n        }\n    },\n    sortNodePosition: function (a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    },\n    getBaseTarget: function (props, key) {\n        var _a;\n        return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n    },\n    measureViewportBox: function (element, _a) {\n        var transformPagePoint = _a.transformPagePoint;\n        return getBoundingBox(element, transformPagePoint);\n    },\n    /**\n     * Reset the transform on the current Element. This is called as part\n     * of a batched process across the entire layout tree. To remove this write\n     * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n     * works\n     */\n    resetTransform: function (element, domElement, props) {\n        var transformTemplate = props.transformTemplate;\n        domElement.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\";\n        // Ensure that whatever happens next, we restore our transform on the next frame\n        element.scheduleRender();\n    },\n    restoreTransform: function (instance, mutableState) {\n        instance.style.transform = mutableState.style.transform;\n    },\n    removeValueFromRenderState: function (key, _a) {\n        var vars = _a.vars, style = _a.style;\n        delete vars[key];\n        delete style[key];\n    },\n    /**\n     * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n     * can be animated by Motion.\n     */\n    makeTargetAnimatable: function (element, _a, _b, isMounted) {\n        var transformValues = _b.transformValues;\n        if (isMounted === void 0) { isMounted = true; }\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = tslib.__rest(_a, [\"transition\", \"transitionEnd\"]);\n        var origin = getOrigin(target, transition || {}, element);\n        /**\n         * If Framer has provided a function to convert `Color` etc value types, convert them\n         */\n        if (transformValues) {\n            if (transitionEnd)\n                transitionEnd = transformValues(transitionEnd);\n            if (target)\n                target = transformValues(target);\n            if (origin)\n                origin = transformValues(origin);\n        }\n        if (isMounted) {\n            checkTargetForNewValues(element, target, origin);\n            var parsed = parseDomVariant(element, target, origin, transitionEnd);\n            transitionEnd = parsed.transitionEnd;\n            target = parsed.target;\n        }\n        return tslib.__assign({ transition: transition,\n            transitionEnd: transitionEnd }, target);\n    },\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n    build: function (element, renderState, latestValues, projection, layoutState, options, props) {\n        if (element.isVisible !== undefined) {\n            renderState.style.visibility = element.isVisible\n                ? \"visible\"\n                : \"hidden\";\n        }\n        var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n        buildHTMLStyles(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform\n            ? buildLayoutProjectionTransformOrigin\n            : undefined);\n    },\n    render: renderHTML,\n};\nvar htmlVisualElement = visualElement(htmlConfig);\n\nvar svgVisualElement = visualElement(tslib.__assign(tslib.__assign({}, htmlConfig), { getBaseTarget: function (props, key) {\n        return props[key];\n    },\n    readValueFromInstance: function (domElement, key) {\n        var _a;\n        if (isTransformProp(key)) {\n            return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return domElement.getAttribute(key);\n    },\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n    build: function (_element, renderState, latestValues, projection, layoutState, options, props) {\n        var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n        buildSVGAttrs(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform\n            ? buildLayoutProjectionTransformOrigin\n            : undefined);\n    }, render: renderSVG }));\n\nvar createDomVisualElement = function (Component, options) {\n    return isSVGComponent(Component)\n        ? svgVisualElement(options, { enableHardwareAcceleration: false })\n        : htmlVisualElement(options, { enableHardwareAcceleration: true });\n};\n\nvar featureBundle = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, animations), gestureAnimations), drag), layoutAnimations);\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */\nvar motion = /*@__PURE__*/ createMotionProxy(function (Component, config) {\n    return createDomMotionConfig(Component, config, featureBundle, createDomVisualElement);\n});\n/**\n * Create a DOM `motion` component with the provided string. This is primarily intended\n * as a full alternative to `motion` for consumers who have to support environments that don't\n * support `Proxy`.\n *\n * ```javascript\n * import { createDomMotionComponent } from \"framer-motion\"\n *\n * const motion = {\n *   div: createDomMotionComponent('div')\n * }\n * ```\n *\n * @public\n */\nfunction createDomMotionComponent(key) {\n    return createMotionComponent(createDomMotionConfig(key, { forwardMotionProps: false }, featureBundle, createDomVisualElement));\n}\n\n/**\n * @public\n */\nvar m = createMotionProxy(createDomMotionConfig);\n\nfunction useForceUpdate() {\n    var unloadingRef = React.useRef(false);\n    var _a = tslib.__read(React.useState(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\n    useUnmountEffect(function () { return (unloadingRef.current = true); });\n    return React.useCallback(function () {\n        !unloadingRef.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [forcedRenderCount]);\n}\n\nvar presenceId = 0;\nfunction getPresenceId() {\n    var id = presenceId;\n    presenceId++;\n    return id;\n}\nvar PresenceChild = function (_a) {\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;\n    var presenceChildren = useConstant(newChildrenMap);\n    var id = useConstant(getPresenceId);\n    var context = React.useMemo(function () { return ({\n        id: id,\n        initial: initial,\n        isPresent: isPresent,\n        custom: custom,\n        onExitComplete: function (childId) {\n            presenceChildren.set(childId, true);\n            var allComplete = true;\n            presenceChildren.forEach(function (isComplete) {\n                if (!isComplete)\n                    allComplete = false;\n            });\n            allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n        },\n        register: function (childId) {\n            presenceChildren.set(childId, false);\n            return function () { return presenceChildren.delete(childId); };\n        },\n    }); }, \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout ? undefined : [isPresent]);\n    React.useMemo(function () {\n        presenceChildren.forEach(function (_, key) { return presenceChildren.set(key, false); });\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React__namespace.useEffect(function () {\n        !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n    }, [isPresent]);\n    return (React__namespace.createElement(PresenceContext.Provider, { value: context }, children));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nfunction getChildKey(child) {\n    return child.key || \"\";\n}\nfunction updateChildLookup(children, allChildren) {\n    var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n    children.forEach(function (child) {\n        var key = getChildKey(child);\n        if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n            if (seenChildren.has(key)) {\n                console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n            }\n            seenChildren.add(key);\n        }\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    React.Children.forEach(children, function (child) {\n        if (React.isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var forceRender = useForceUpdate();\n    var layoutContext = React.useContext(SharedLayoutContext);\n    if (isSharedLayout(layoutContext)) {\n        forceRender = layoutContext.forceUpdate;\n    }\n    var isInitialRender = React.useRef(true);\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = React.useRef(filteredChildren);\n    // A lookup table to quickly reference components by key\n    var allChildren = React.useRef(new Map())\n        .current;\n    // A living record of all currently exiting components.\n    var exiting = React.useRef(new Set()).current;\n    updateChildLookup(filteredChildren, allChildren);\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    if (isInitialRender.current) {\n        isInitialRender.current = false;\n        return (React__namespace.createElement(React__namespace.Fragment, null, filteredChildren.map(function (child) { return (React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout }, child)); })));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    var childrenToRender = tslib.__spreadArray([], tslib.__read(filteredChildren));\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for (var i = 0; i < numPresent; i++) {\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n        else {\n            // In case this key has re-entered, remove from the exiting list\n            exiting.delete(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function (key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        var child = allChildren.get(key);\n        if (!child)\n            return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function () {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function (child) {\n        var key = child.key;\n        return exiting.has(key) ? (child) : (React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    presentChildren.current = childrenToRender;\n    if (process.env.NODE_ENV !== \"production\" &&\n        exitBeforeEnter &&\n        childrenToRender.length > 1) {\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n    }\n    return (React__namespace.createElement(React__namespace.Fragment, null, exiting.size\n        ? childrenToRender\n        : childrenToRender.map(function (child) { return React.cloneElement(child); })));\n};\n\n/**\n * Animate a single value or a `MotionValue`.\n *\n * The first argument is either a `MotionValue` to animate, or an initial animation value.\n *\n * The second is either a value to animate to, or an array of keyframes to animate through.\n *\n * The third argument can be either tween or spring options, and optional lifecycle methods: `onUpdate`, `onPlay`, `onComplete`, `onRepeat` and `onStop`.\n *\n * Returns `AnimationPlaybackControls`, currently just a `stop` method.\n *\n * ```javascript\n * const x = useMotionValue(0)\n *\n * useEffect(() => {\n *   const controls = animate(x, 100, {\n *     type: \"spring\",\n *     stiffness: 2000,\n *     onComplete: v => {}\n *   })\n *\n *   return controls.stop\n * })\n * ```\n *\n * @public\n */\nfunction animate(from, to, transition) {\n    if (transition === void 0) { transition = {}; }\n    var value = isMotionValue(from) ? from : motionValue(from);\n    startAnimation(\"\", value, to, transition);\n    return {\n        stop: function () { return value.stop(); },\n    };\n}\n\nfunction createCrossfader() {\n    /**\n     * The current state of the crossfade as a value between 0 and 1\n     */\n    var progress = motionValue(1);\n    var options = {\n        lead: undefined,\n        follow: undefined,\n        crossfadeOpacity: false,\n        preserveFollowOpacity: false,\n    };\n    var prevOptions = tslib.__assign({}, options);\n    var leadState = {};\n    var followState = {};\n    /**\n     *\n     */\n    var isActive = false;\n    /**\n     *\n     */\n    var finalCrossfadeFrame = null;\n    /**\n     * Framestamp of the last frame we updated values at.\n     */\n    var prevUpdate = 0;\n    function startCrossfadeAnimation(target, transition) {\n        var lead = options.lead, follow = options.follow;\n        isActive = true;\n        finalCrossfadeFrame = null;\n        var hasUpdated = false;\n        var onUpdate = function () {\n            hasUpdated = true;\n            lead && lead.scheduleRender();\n            follow && follow.scheduleRender();\n        };\n        var onComplete = function () {\n            isActive = false;\n            /**\n             * If the crossfade animation is no longer active, flag a frame\n             * that we're still allowed to crossfade\n             */\n            finalCrossfadeFrame = sync.getFrameData().timestamp;\n        };\n        transition = transition && getValueTransition(transition, \"crossfade\");\n        return animate(progress, target, tslib.__assign(tslib.__assign({}, transition), { onUpdate: onUpdate, onComplete: function () {\n                if (!hasUpdated) {\n                    progress.set(target);\n                    /**\n                     * If we never ran an update, for instance if this was an instant transition, fire a\n                     * simulated final frame to ensure the crossfade gets applied correctly.\n                     */\n                    sync__default['default'].read(onComplete);\n                }\n                else {\n                    onComplete();\n                }\n                onUpdate();\n            } }));\n    }\n    function updateCrossfade() {\n        var _a, _b;\n        /**\n         * We only want to compute the crossfade once per frame, so we\n         * compare the previous update framestamp with the current frame\n         * and early return if they're the same.\n         */\n        var timestamp = sync.getFrameData().timestamp;\n        var lead = options.lead, follow = options.follow;\n        if (timestamp === prevUpdate || !lead)\n            return;\n        prevUpdate = timestamp;\n        /**\n         * Merge each component's latest values into our crossfaded state\n         * before crossfading.\n         */\n        var latestLeadValues = lead.getLatestValues();\n        Object.assign(leadState, latestLeadValues);\n        var latestFollowValues = follow\n            ? follow.getLatestValues()\n            : options.prevValues;\n        Object.assign(followState, latestFollowValues);\n        var p = progress.get();\n        /**\n         * Crossfade the opacity between the two components. This will result\n         * in a different opacity for each component.\n         */\n        var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\n        var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\n        if (options.crossfadeOpacity && follow) {\n            leadState.opacity = popmotion.mix(\n            /**\n             * If the follow child has been completely hidden we animate\n             * this opacity from its previous opacity, but otherwise from completely transparent.\n             */\n            follow.isVisible !== false ? 0 : followTargetOpacity, leadTargetOpacity, easeCrossfadeIn(p));\n            followState.opacity = options.preserveFollowOpacity\n                ? followTargetOpacity\n                : popmotion.mix(followTargetOpacity, 0, easeCrossfadeOut(p));\n        }\n        else if (!follow) {\n            leadState.opacity = popmotion.mix(followTargetOpacity, leadTargetOpacity, p);\n        }\n        mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\n    }\n    return {\n        isActive: function () {\n            return leadState &&\n                (isActive || sync.getFrameData().timestamp === finalCrossfadeFrame);\n        },\n        fromLead: function (transition) {\n            return startCrossfadeAnimation(0, transition);\n        },\n        toLead: function (transition) {\n            var initialProgress = 0;\n            if (!options.prevValues && !options.follow) {\n                /**\n                 * If we're not coming from anywhere, start at the end of the animation.\n                 */\n                initialProgress = 1;\n            }\n            else if (prevOptions.lead === options.follow &&\n                prevOptions.follow === options.lead) {\n                /**\n                 * If we're swapping follow/lead we can reverse the progress\n                 */\n                initialProgress = 1 - progress.get();\n            }\n            progress.set(initialProgress);\n            return startCrossfadeAnimation(1, transition);\n        },\n        reset: function () { return progress.set(1); },\n        stop: function () { return progress.stop(); },\n        getCrossfadeState: function (element) {\n            updateCrossfade();\n            if (element === options.lead) {\n                return leadState;\n            }\n            else if (element === options.follow) {\n                return followState;\n            }\n        },\n        setOptions: function (newOptions) {\n            prevOptions = options;\n            options = newOptions;\n            leadState = {};\n            followState = {};\n        },\n        getLatestValues: function () {\n            return leadState;\n        },\n    };\n}\nvar easeCrossfadeIn = compress(0, 0.5, popmotion.circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, popmotion.linear);\nfunction compress(min, max, easing) {\n    return function (p) {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(popmotion.progress(min, max, p));\n    };\n}\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\n    /**\n     * Mix border radius\n     */\n    for (var i = 0; i < numBorders; i++) {\n        var borderLabel = \"border\" + borders[i] + \"Radius\";\n        var followRadius = getRadius(latestFollowValues, borderLabel);\n        var leadRadius = getRadius(latestLeadValues, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        /**\n         * Currently we're only crossfading between numerical border radius.\n         * It would be possible to crossfade between percentages for a little\n         * extra bundle size.\n         */\n        if (typeof followRadius === \"number\" &&\n            typeof leadRadius === \"number\") {\n            var radius = Math.max(popmotion.mix(followRadius, leadRadius, p), 0);\n            leadState[borderLabel] = followState[borderLabel] = radius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (latestFollowValues.rotate || latestLeadValues.rotate) {\n        var rotate = popmotion.mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\n        leadState.rotate = followState.rotate = rotate;\n    }\n    /**\n     * We only want to mix the background color if there's a follow element\n     * that we're not crossfading opacity between. For instance with switch\n     * AnimateSharedLayout animations, this helps the illusion of a continuous\n     * element being animated but also cuts down on the number of paints triggered\n     * for elements where opacity is doing that work for us.\n     */\n    if (!hasFollowElement &&\n        latestLeadValues.backgroundColor &&\n        latestFollowValues.backgroundColor) {\n        /**\n         * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n         * We could probably create a mixer that runs at the start of the animation but\n         * the idea behind the crossfader is that it runs dynamically between two potentially\n         * changing targets (ie opacity or borderRadius may be animating independently via variants)\n         */\n        leadState.backgroundColor = followState.backgroundColor = popmotion.mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\n    }\n}\nfunction getRadius(values, radiusName) {\n    var _a;\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n\nfunction layoutStack() {\n    var stack = new Set();\n    var state = { leadIsExiting: false };\n    var prevState = tslib.__assign({}, state);\n    var prevValues;\n    var prevViewportBox;\n    var prevDragCursor;\n    var crossfader = createCrossfader();\n    var needsCrossfadeAnimation = false;\n    function getFollowViewportBox() {\n        return state.follow ? state.follow.prevViewportBox : prevViewportBox;\n    }\n    function getFollowLayout() {\n        var _a;\n        return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\n    }\n    return {\n        add: function (element) {\n            element.setCrossfader(crossfader);\n            stack.add(element);\n            /**\n             * Hydrate new element with previous drag position if we have one\n             */\n            if (prevDragCursor)\n                element.prevDragCursor = prevDragCursor;\n            if (!state.lead)\n                state.lead = element;\n        },\n        remove: function (element) {\n            stack.delete(element);\n        },\n        getLead: function () { return state.lead; },\n        updateSnapshot: function () {\n            if (!state.lead)\n                return;\n            prevValues = crossfader.isActive()\n                ? crossfader.getLatestValues()\n                : state.lead.getLatestValues();\n            prevViewportBox = state.lead.prevViewportBox;\n            var dragControls = elementDragControls.get(state.lead);\n            if (dragControls && dragControls.isDragging) {\n                prevDragCursor = dragControls.cursorProgress;\n            }\n        },\n        clearSnapshot: function () {\n            prevDragCursor = prevViewportBox = undefined;\n        },\n        updateLeadAndFollow: function () {\n            var _a;\n            prevState = tslib.__assign({}, state);\n            var lead;\n            var follow;\n            var order = Array.from(stack);\n            for (var i = order.length; i--; i >= 0) {\n                var element = order[i];\n                if (lead)\n                    follow !== null && follow !== void 0 ? follow : (follow = element);\n                lead !== null && lead !== void 0 ? lead : (lead = element);\n                if (lead && follow)\n                    break;\n            }\n            state.lead = lead;\n            state.follow = follow;\n            state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\n            crossfader.setOptions({\n                lead: lead,\n                follow: follow,\n                prevValues: prevValues,\n                crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot),\n            });\n            if (\n            // Don't crossfade if we've just animated back from lead and switched the\n            // old follow to the new lead.\n            state.lead !== prevState.follow &&\n                (prevState.lead !== state.lead ||\n                    prevState.leadIsExiting !== state.leadIsExiting)) {\n                needsCrossfadeAnimation = true;\n            }\n        },\n        animate: function (child, shouldCrossfade) {\n            var _a;\n            if (shouldCrossfade === void 0) { shouldCrossfade = false; }\n            if (child === state.lead) {\n                if (shouldCrossfade) {\n                    /**\n                     * Point a lead to itself in case it was previously pointing\n                     * to a different visual element\n                     */\n                    child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(true);\n                }\n                var config = {};\n                var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();\n                if (prevParent) {\n                    /**\n                     * We'll use this to determine if the element or its layoutId has been reparented.\n                     */\n                    config.prevParent = prevParent;\n                }\n                if (child.presence === Presence.Entering) {\n                    config.originBox = getFollowViewportBox();\n                }\n                else if (child.presence === Presence.Exiting) {\n                    config.targetBox = getFollowLayout();\n                }\n                if (needsCrossfadeAnimation) {\n                    needsCrossfadeAnimation = false;\n                    var transition = child.getDefaultTransition();\n                    child.presence === Presence.Entering\n                        ? crossfader.toLead(transition)\n                        : crossfader.fromLead(transition);\n                }\n                child.notifyLayoutReady(config);\n            }\n            else {\n                if (shouldCrossfade) {\n                    state.lead && child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(false);\n                }\n            }\n        },\n    };\n}\n\nfunction resetRotate(child) {\n    // If there's no detected rotation values, we can early return without a forced render.\n    var hasRotate = false;\n    // Keep a record of all the values we've reset\n    var resetValues = {};\n    // Check the rotate value of all axes and reset to 0\n    for (var i = 0; i < transformAxes.length; i++) {\n        var axis = transformAxes[i];\n        var key = \"rotate\" + axis;\n        // If this rotation doesn't exist as a motion value, then we don't\n        // need to reset it\n        if (!child.hasValue(key) || child.getStaticValue(key) === 0)\n            continue;\n        hasRotate = true;\n        // Record the rotation and then temporarily set it to 0\n        resetValues[key] = child.getStaticValue(key);\n        child.setStaticValue(key, 0);\n    }\n    // If there's no rotation values, we don't need to do any more.\n    if (!hasRotate)\n        return;\n    // Force a render of this element to apply the transform with all rotations\n    // set to 0.\n    child.syncRender();\n    // Put back all the values we reset\n    for (var key in resetValues) {\n        child.setStaticValue(key, resetValues[key]);\n    }\n    // Schedule a render for the next frame. This ensures we won't visually\n    // see the element with the reset rotate value applied.\n    child.scheduleRender();\n}\n\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */ (function (_super) {\n    tslib.__extends(AnimateSharedLayout, _super);\n    function AnimateSharedLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A list of all the children in the shared layout\n         */\n        _this.children = new Set();\n        /**\n         * As animate components with a defined `layoutId` are added/removed to the tree,\n         * we store them in order. When one is added, it will animate out from the\n         * previous one, and when it's removed, it'll animate to the previous one.\n         */\n        _this.stacks = new Map();\n        /**\n         * Track whether the component has mounted. If it hasn't, the presence of added children\n         * are set to Present, whereas if it has they're considered Entering\n         */\n        _this.hasMounted = false;\n        /**\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n         * and schedule one.\n         */\n        _this.updateScheduled = false;\n        /**\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n         */\n        _this.renderScheduled = false;\n        /**\n         * The methods provided to all children in the shared layout tree.\n         */\n        _this.syncContext = tslib.__assign(tslib.__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\n                // all children subscribed to the SharedLayout context.\n                _this.syncContext = tslib.__assign({}, _this.syncContext);\n                _this.scheduleUpdate(true);\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\n        return _this;\n    }\n    AnimateSharedLayout.prototype.componentDidMount = function () {\n        this.hasMounted = true;\n    };\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\n        this.startLayoutAnimation();\n    };\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n        this.renderScheduled = true;\n        return true;\n    };\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n        var _this = this;\n        /**\n         * Reset update and render scheduled status\n         */\n        this.renderScheduled = this.updateScheduled = false;\n        var type = this.props.type;\n        /**\n         * Update presence metadata based on the latest AnimatePresence status.\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n         */\n        this.children.forEach(function (child) {\n            if (!child.isPresent) {\n                child.presence = Presence.Exiting;\n            }\n            else if (child.presence !== Presence.Entering) {\n                child.presence =\n                    child.presence === Presence.Exiting\n                        ? Presence.Entering\n                        : Presence.Present;\n            }\n        });\n        this.updateStacks();\n        /**\n         * Create a handler which we can use to flush the children animations\n         */\n        var handler = {\n            layoutReady: function (child) {\n                if (child.getLayoutId() !== undefined) {\n                    var stack = _this.getStack(child);\n                    stack.animate(child, type === \"crossfade\");\n                }\n                else {\n                    child.notifyLayoutReady();\n                }\n            },\n            parent: this.context.visualElement,\n        };\n        /**\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n         * This requires some co-ordination across components to stop layout thrashing\n         * and ensure measurements are taken at the correct time.\n         *\n         * Here we use that same mechanism of schedule/flush.\n         */\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\n        this.syncContext.flush(handler);\n        /**\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n         */\n        this.stacks.forEach(function (stack) { return stack.clearSnapshot(); });\n    };\n    AnimateSharedLayout.prototype.updateStacks = function () {\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\n    };\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n        if (force === void 0) { force = false; }\n        if (!(force || !this.updateScheduled))\n            return;\n        /**\n         * Flag we've scheduled an update\n         */\n        this.updateScheduled = true;\n        /**\n         * Write: Reset transforms so bounding boxes can be accurately measured.\n         */\n        this.children.forEach(function (child) {\n            resetRotate(child);\n            if (child.shouldResetTransform())\n                child.resetTransform();\n        });\n        /**\n         * Read: Snapshot children\n         */\n        this.children.forEach(snapshotViewportBox);\n        /**\n         * Every child keeps a local snapshot, but we also want to record\n         * snapshots of the visible children as, if they're are being removed\n         * in this render, we can still access them.\n         *\n         * TODO: What would be better here is doing a single loop where we\n         * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n         */\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\n        /**\n         * Force a rerender by setting state if we aren't already going to render.\n         */\n        if (force || !this.renderScheduled) {\n            this.renderScheduled = true;\n            this.forceUpdate();\n        }\n    };\n    AnimateSharedLayout.prototype.addChild = function (child) {\n        this.children.add(child);\n        this.addToStack(child);\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n    };\n    AnimateSharedLayout.prototype.removeChild = function (child) {\n        this.scheduleUpdate();\n        this.children.delete(child);\n        this.removeFromStack(child);\n    };\n    AnimateSharedLayout.prototype.addToStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\n    };\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\n    };\n    /**\n     * Return a stack of animate children based on the provided layoutId.\n     * Will create a stack if none currently exists with that layoutId.\n     */\n    AnimateSharedLayout.prototype.getStack = function (child) {\n        var id = child.getLayoutId();\n        if (id === undefined)\n            return;\n        // Create stack if it doesn't already exist\n        !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n        return this.stacks.get(id);\n    };\n    AnimateSharedLayout.prototype.render = function () {\n        return (React__namespace.createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\n    };\n    AnimateSharedLayout.contextType = MotionContext;\n    return AnimateSharedLayout;\n}(React__namespace.Component));\n\n/**\n * `MotionConfig` is used to set configuration options for all children `motion` components.\n *\n * ```jsx\n * import { motion, MotionConfig } from \"framer-motion\"\n *\n * export function App() {\n *   return (\n *     <MotionConfig transition={{ type: \"spring\" }}>\n *       <motion.div animate={{ x: 100 }} />\n *     </MotionConfig>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction MotionConfig(_a) {\n    var children = _a.children, config = tslib.__rest(_a, [\"children\"]);\n    /**\n     * Inherit props from any parent MotionConfig components\n     */\n    config = tslib.__assign(tslib.__assign({}, React.useContext(MotionConfigContext)), config);\n    /**\n     * Don't allow isStatic to change between renders as it affects how many hooks\n     * motion components fire.\n     */\n    config.isStatic = useConstant(function () { return config.isStatic; });\n    /**\n     * Creating a new config context object will re-render every `motion` component\n     * every time it renders. So we only want to create a new one sparingly.\n     */\n    var transitionDependency = typeof config.transition === \"object\"\n        ? config.transition.toString()\n        : \"\";\n    var context = React.useMemo(function () { return config; }, [\n        transitionDependency,\n        config.transformPagePoint,\n    ]);\n    return (React__namespace.createElement(MotionConfigContext.Provider, { value: context }, children));\n}\n\n/**\n * Used in conjunction with the `m` component to reduce bundle size.\n *\n * `m` is a version of the `motion` component that only loads functionality\n * critical for the initial render.\n *\n * `LazyMotion` can then be used to either synchronously or asynchronously\n * load animation and gesture support.\n *\n * ```jsx\n * // Synchronous loading\n * import { LazyMotion, m, domAnimations } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={domAnimations}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n *\n * // Asynchronous loading\n * import { LazyMotion, m } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={() => import('./path/to/domAnimations')}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction LazyMotion(_a) {\n    var children = _a.children, features = _a.features, _b = _a.strict, strict = _b === void 0 ? false : _b;\n    var _c = tslib.__read(React.useState(!isLazyBundle(features)), 2), setIsLoaded = _c[1];\n    var loadedRenderer = React.useRef(undefined);\n    /**\n     * If this is a synchronous load, load features immediately\n     */\n    if (!isLazyBundle(features)) {\n        var renderer = features.renderer, loadedFeatures = tslib.__rest(features, [\"renderer\"]);\n        loadedRenderer.current = renderer;\n        loadFeatures(loadedFeatures);\n    }\n    React.useEffect(function () {\n        if (isLazyBundle(features)) {\n            features().then(function (_a) {\n                var renderer = _a.renderer, loadedFeatures = tslib.__rest(_a, [\"renderer\"]);\n                loadFeatures(loadedFeatures);\n                loadedRenderer.current = renderer;\n                setIsLoaded(true);\n            });\n        }\n    }, []);\n    return (React__namespace.createElement(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict: strict } }, children));\n}\nfunction isLazyBundle(features) {\n    return typeof features === \"function\";\n}\n\n/**\n * @public\n */\nvar domAnimation = tslib.__assign(tslib.__assign({ renderer: createDomVisualElement }, animations), gestureAnimations);\n\n/**\n * @public\n */\nvar domMax = tslib.__assign(tslib.__assign(tslib.__assign({}, domAnimation), drag), layoutAnimations);\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * @library\n *\n * ```jsx\n * export function MyComponent() {\n *   const scale = useMotionValue(1)\n *\n *   return <Frame scale={scale} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    var value = useConstant(function () { return motionValue(initial); });\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\n    if (isStatic) {\n        var _a = tslib.__read(React.useState(initial), 2), setLatest_1 = _a[1];\n        React.useEffect(function () { return value.onChange(setLatest_1); }, []);\n    }\n    return value;\n}\n\nfunction useOnChange(value, callback) {\n    React.useEffect(function () {\n        if (isMotionValue(value))\n            return value.onChange(callback);\n    }, [callback]);\n}\nfunction useMultiOnChange(values, handler) {\n    React.useEffect(function () {\n        var subscriptions = values.map(function (value) { return value.onChange(handler); });\n        return function () { return subscriptions.forEach(function (unsubscribe) { return unsubscribe(); }); };\n    });\n}\n\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */\n    var value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\n     * in a single frame.\n     */\n    var updateValue = function () { return value.set(combineValues()); };\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */\n    updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */\n    useMultiOnChange(values, function () { return sync__default['default'].update(updateValue, false, true); });\n    return value;\n}\n\n/**\n * Combine multiple motion values into a new one using a string template literal.\n *\n * ```jsx\n * import {\n *   motion,\n *   useSpring,\n *   useMotionValue,\n *   useMotionTemplate\n * } from \"framer-motion\"\n *\n * function Component() {\n *   const shadowX = useSpring(0)\n *   const shadowY = useMotionValue(0)\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\n *\n *   return <motion.div style={{ filter: shadow }} />\n * }\n * ```\n *\n * @public\n */\nfunction useMotionTemplate(fragments) {\n    var values = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        values[_i - 1] = arguments[_i];\n    }\n    /**\n     * Create a function that will build a string from the latest motion values.\n     */\n    var numFragments = fragments.length;\n    function buildValue() {\n        var output = \"\";\n        for (var i = 0; i < numFragments; i++) {\n            output += fragments[i];\n            var value = values[i];\n            if (value)\n                output += values[i].get();\n        }\n        return output;\n    }\n    return useCombineMotionValues(values, buildValue);\n}\n\nvar isCustomValueType = function (v) {\n    return typeof v === \"object\" && v.mix;\n};\nvar getMixer = function (v) { return (isCustomValueType(v) ? v.mix : undefined); };\nfunction transform() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var useImmediate = !Array.isArray(args[0]);\n    var argOffset = useImmediate ? 0 : -1;\n    var inputValue = args[0 + argOffset];\n    var inputRange = args[1 + argOffset];\n    var outputRange = args[2 + argOffset];\n    var options = args[3 + argOffset];\n    var interpolator = popmotion.interpolate(inputRange, outputRange, tslib.__assign({ mixer: getMixer(outputRange[0]) }, options));\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n    var transformer = typeof inputRangeOrTransformer === \"function\"\n        ? inputRangeOrTransformer\n        : transform(inputRangeOrTransformer, outputRange, options);\n    return Array.isArray(input)\n        ? useListTransform(input, transformer)\n        : useListTransform([input], function (_a) {\n            var _b = tslib.__read(_a, 1), latest = _b[0];\n            return transformer(latest);\n        });\n}\nfunction useListTransform(values, transformer) {\n    var latest = useConstant(function () { return []; });\n    return useCombineMotionValues(values, function () {\n        latest.length = 0;\n        var numValues = values.length;\n        for (var i = 0; i < numValues; i++) {\n            latest[i] = values[i].get();\n        }\n        return transformer(latest);\n    });\n}\n\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\nfunction useSpring(source, config) {\n    if (config === void 0) { config = {}; }\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\n    var activeSpringAnimation = React.useRef(null);\n    var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n    React.useMemo(function () {\n        return value.attach(function (v, set) {\n            /**\n             * A more hollistic approach to this might be to use isStatic to fix VisualElement animations\n             * at that level, but this will work for now\n             */\n            if (isStatic)\n                return set(v);\n            if (activeSpringAnimation.current) {\n                activeSpringAnimation.current.stop();\n            }\n            activeSpringAnimation.current = popmotion.animate(tslib.__assign(tslib.__assign({ from: value.get(), to: v, velocity: value.getVelocity() }, config), { onUpdate: set }));\n            return value.get();\n        });\n    }, Object.values(config));\n    useOnChange(source, function (v) { return value.set(parseFloat(v)); });\n    return value;\n}\n\n/**\n * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.\n *\n * ```javascript\n * const x = useMotionValue(0)\n * const xVelocity = useVelocity(x)\n * const xAcceleration = useVelocity(xVelocity)\n * ```\n *\n * @public\n */\nfunction useVelocity(value) {\n    var velocity = useMotionValue(value.getVelocity());\n    React.useEffect(function () {\n        return value.velocityUpdateSubscribers.add(function (newVelocity) {\n            velocity.set(newVelocity);\n        });\n    }, [value]);\n    return velocity;\n}\n\nfunction createScrollMotionValues() {\n    return {\n        scrollX: motionValue(0),\n        scrollY: motionValue(0),\n        scrollXProgress: motionValue(0),\n        scrollYProgress: motionValue(0),\n    };\n}\nfunction setProgress(offset, maxOffset, value) {\n    value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\n}\nfunction createScrollUpdater(values, getOffsets) {\n    var update = function () {\n        var _a = getOffsets(), xOffset = _a.xOffset, yOffset = _a.yOffset, xMaxOffset = _a.xMaxOffset, yMaxOffset = _a.yMaxOffset;\n        // Set absolute positions\n        values.scrollX.set(xOffset);\n        values.scrollY.set(yOffset);\n        // Set 0-1 progress\n        setProgress(xOffset, xMaxOffset, values.scrollXProgress);\n        setProgress(yOffset, yMaxOffset, values.scrollYProgress);\n    };\n    update();\n    return update;\n}\n\nvar getElementScrollOffsets = function (element) { return function () {\n    return {\n        xOffset: element.scrollLeft,\n        yOffset: element.scrollTop,\n        xMaxOffset: element.scrollWidth - element.offsetWidth,\n        yMaxOffset: element.scrollHeight - element.offsetHeight,\n    };\n}; };\n/**\n * Returns MotionValues that update when the provided element scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * This element must be set to `overflow: scroll` on either or both axes to report scroll offset.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useElementScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const ref = React.useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <Frame ref={ref}>\n *       <Frame scaleX={scrollYProgress} />\n *     </Frame>\n *   )\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const ref = useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <div ref={ref}>\n *       <motion.div style={{ scaleX: scrollYProgress }} />\n *     </div>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction useElementScroll(ref) {\n    var values = useConstant(createScrollMotionValues);\n    useIsomorphicLayoutEffect(function () {\n        var element = ref.current;\n        heyListen.invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\n        if (!element)\n            return;\n        var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\n        var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, { passive: true });\n        var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\n        return function () {\n            scrollListener && scrollListener();\n            resizeListener && resizeListener();\n        };\n    }, []);\n    return values;\n}\n\nvar viewportScrollValues;\nfunction getViewportScrollOffsets() {\n    return {\n        xOffset: window.pageXOffset,\n        yOffset: window.pageYOffset,\n        xMaxOffset: document.body.clientWidth - window.innerWidth,\n        yMaxOffset: document.body.clientHeight - window.innerHeight,\n    };\n}\nvar hasListeners = false;\nfunction addEventListeners() {\n    hasListeners = true;\n    if (typeof window === \"undefined\")\n        return;\n    var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\n    addDomEvent(window, \"scroll\", updateScrollValues, { passive: true });\n    addDomEvent(window, \"resize\", updateScrollValues);\n}\n/**\n * Returns MotionValues that update when the viewport scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * **Warning:** Setting `body` or `html` to `height: 100%` or similar will break the `Progress`\n * values as this breaks the browser's capability to accurately measure the page length.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useViewportScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <Frame scaleX={scrollYProgress} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\n * }\n * ```\n *\n * @public\n */\nfunction useViewportScroll() {\n    /**\n     * Lazy-initialise the viewport scroll values\n     */\n    if (!viewportScrollValues) {\n        viewportScrollValues = createScrollMotionValues();\n    }\n    useIsomorphicLayoutEffect(function () {\n        !hasListeners && addEventListeners();\n    }, []);\n    return viewportScrollValues;\n}\n\n// Does this device prefer reduced motion? Returns `null` server-side.\nvar prefersReducedMotion;\nfunction initPrefersReducedMotion() {\n    prefersReducedMotion = motionValue(null);\n    if (typeof window === \"undefined\")\n        return;\n    if (window.matchMedia) {\n        var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n        var setReducedMotionPreferences = function () {\n            return prefersReducedMotion.set(motionMediaQuery_1.matches);\n        };\n        motionMediaQuery_1.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.set(false);\n    }\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\nfunction useReducedMotion() {\n    /**\n     * Lazy initialisation of prefersReducedMotion\n     */\n    !prefersReducedMotion && initPrefersReducedMotion();\n    var _a = tslib.__read(React.useState(prefersReducedMotion.get()), 2), shouldReduceMotion = _a[0], setShouldReduceMotion = _a[1];\n    useOnChange(prefersReducedMotion, setShouldReduceMotion);\n    return shouldReduceMotion;\n}\n\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    var hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     * TODO: Remove this as animations should only run in effects\n     */\n    var pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     */\n    var subscribers = new Set();\n    var controls = {\n        subscribe: function (visualElement) {\n            subscribers.add(visualElement);\n            return function () { return void subscribers.delete(visualElement); };\n        },\n        start: function (definition, transitionOverride) {\n            /**\n             * TODO: We only perform this hasMounted check because in Framer we used to\n             * encourage the ability to start an animation within the render phase. This\n             * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n             * we can ditch this.\n             */\n            if (hasMounted) {\n                var animations_1 = [];\n                subscribers.forEach(function (visualElement) {\n                    animations_1.push(animateVisualElement(visualElement, definition, {\n                        transitionOverride: transitionOverride,\n                    }));\n                });\n                return Promise.all(animations_1);\n            }\n            else {\n                return new Promise(function (resolve) {\n                    pendingAnimations.push({\n                        animation: [definition, transitionOverride],\n                        resolve: resolve,\n                    });\n                });\n            }\n        },\n        set: function (definition) {\n            heyListen.invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach(function (visualElement) {\n                setValues(visualElement, definition);\n            });\n        },\n        stop: function () {\n            subscribers.forEach(function (visualElement) {\n                stopAnimation(visualElement);\n            });\n        },\n        mount: function () {\n            hasMounted = true;\n            pendingAnimations.forEach(function (_a) {\n                var animation = _a.animation, resolve = _a.resolve;\n                controls.start.apply(controls, tslib.__spreadArray([], tslib.__read(animation))).then(resolve);\n            });\n            return function () {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * @library\n *\n * ```jsx\n * import * as React from 'react'\n * import { Frame, useAnimation } from 'framer'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <Frame animate={controls} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\nfunction useAnimation() {\n    var controls = useConstant(animationControls);\n    React.useEffect(controls.mount, []);\n    return controls;\n}\n\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import { Frame, useCycle } from \"framer\"\n *\n * export function MyComponent() {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <Frame\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @motion\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\nfunction useCycle() {\n    var items = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n    }\n    var index = React.useRef(0);\n    var _a = tslib.__read(React.useState(items[index.current]), 2), item = _a[0], setItem = _a[1];\n    return [\n        item,\n        function (next) {\n            index.current =\n                typeof next !== \"number\"\n                    ? popmotion.wrap(0, items.length, index.current + 1)\n                    : next;\n            setItem(items[index.current]);\n        },\n    ];\n}\n\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nvar DragControls = /** @class */ (function () {\n    function DragControls() {\n        this.componentControls = new Set();\n    }\n    /**\n     * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n     *\n     * @internal\n     */\n    DragControls.prototype.subscribe = function (controls) {\n        var _this = this;\n        this.componentControls.add(controls);\n        return function () { return _this.componentControls.delete(controls); };\n    };\n    /**\n     * Start a drag gesture on every `motion` component that has this set of drag controls\n     * passed into it via the `dragControls` prop.\n     *\n     * ```jsx\n     * dragControls.start(e, {\n     *   snapToCursor: true\n     * })\n     * ```\n     *\n     * @param event - PointerEvent\n     * @param options - Options\n     *\n     * @public\n     */\n    DragControls.prototype.start = function (event, options) {\n        this.componentControls.forEach(function (controls) {\n            controls.start(event.nativeEvent || event, options);\n        });\n    };\n    DragControls.prototype.updateConstraints = function (flush) {\n        if (flush === void 0) { flush = true; }\n        this.componentControls.forEach(function (controls) {\n            controls.updateConstraints();\n        });\n        flush && flushLayout();\n    };\n    return DragControls;\n}());\nvar createDragControls = function () { return new DragControls(); };\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nfunction useDragControls() {\n    return useConstant(createDragControls);\n}\n\nvar createObject = function () { return ({}); };\nvar stateVisualElement = visualElement({\n    build: function () { },\n    measureViewportBox: axisBox,\n    resetTransform: function () { },\n    restoreTransform: function () { },\n    removeValueFromRenderState: function () { },\n    render: function () { },\n    scrapeMotionValuesFromProps: createObject,\n    readValueFromInstance: function (_state, key, options) {\n        return options.initialState[key] || 0;\n    },\n    makeTargetAnimatable: function (element, _a) {\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = tslib.__rest(_a, [\"transition\", \"transitionEnd\"]);\n        var origin = getOrigin(target, transition || {}, element);\n        checkTargetForNewValues(element, target, origin);\n        return tslib.__assign({ transition: transition, transitionEnd: transitionEnd }, target);\n    },\n});\nvar useVisualState = makeUseVisualState({\n    scrapeMotionValuesFromProps: createObject,\n    createRenderState: createObject,\n});\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n * @internal\n */\nfunction useAnimatedState(initialState) {\n    var _a = tslib.__read(React.useState(initialState), 2), animationState = _a[0], setAnimationState = _a[1];\n    var visualState = useVisualState({}, false);\n    var element = useConstant(function () {\n        return stateVisualElement({ props: {}, visualState: visualState }, { initialState: initialState });\n    });\n    React.useEffect(function () {\n        element.mount({});\n        return element.unmount();\n    }, []);\n    React.useEffect(function () {\n        element.setProps({\n            onUpdate: function (v) { return setAnimationState(tslib.__assign({}, v)); },\n        });\n    });\n    var startAnimation = useConstant(function () { return function (animationDefinition) {\n        return animateVisualElement(element, animationDefinition);\n    }; });\n    return [animationState, startAnimation];\n}\n\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\nvar maxScale = 100000;\nvar invertScale = function (scale) {\n    return scale > 0.001 ? 1 / scale : maxScale;\n};\nvar hasWarned = false;\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * @motion\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @library\n *\n * ```jsx\n * function MyComponent() {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\n * }\n * ```\n *\n * @deprecated\n * @internal\n */\nfunction useInvertedScale(scale) {\n    var parentScaleX = useMotionValue(1);\n    var parentScaleY = useMotionValue(1);\n    var visualElement = useVisualElementContext();\n    heyListen.invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n    heyListen.warning(hasWarned, \"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.\");\n    hasWarned = true;\n    if (scale) {\n        parentScaleX = scale.scaleX || parentScaleX;\n        parentScaleY = scale.scaleY || parentScaleY;\n    }\n    else if (visualElement) {\n        parentScaleX = visualElement.getValue(\"scaleX\", 1);\n        parentScaleY = visualElement.getValue(\"scaleY\", 1);\n    }\n    var scaleX = useTransform(parentScaleX, invertScale);\n    var scaleY = useTransform(parentScaleY, invertScale);\n    return { scaleX: scaleX, scaleY: scaleY };\n}\n\nexports.AnimatePresence = AnimatePresence;\nexports.AnimateSharedLayout = AnimateSharedLayout;\nexports.DragControls = DragControls;\nexports.FlatTree = FlatTree;\nexports.FramerTreeLayoutContext = FramerTreeLayoutContext;\nexports.LayoutGroupContext = LayoutGroupContext;\nexports.LazyMotion = LazyMotion;\nexports.MotionConfig = MotionConfig;\nexports.MotionConfigContext = MotionConfigContext;\nexports.MotionValue = MotionValue;\nexports.PresenceContext = PresenceContext;\nexports.SharedLayoutContext = SharedLayoutContext;\nexports.addScaleCorrection = addScaleCorrection;\nexports.animate = animate;\nexports.animateVisualElement = animateVisualElement;\nexports.animationControls = animationControls;\nexports.batchLayout = batchLayout;\nexports.createBatcher = createBatcher;\nexports.createCrossfader = createCrossfader;\nexports.createDomMotionComponent = createDomMotionComponent;\nexports.createMotionComponent = createMotionComponent;\nexports.domAnimation = domAnimation;\nexports.domMax = domMax;\nexports.flushLayout = flushLayout;\nexports.isValidMotionProp = isValidMotionProp;\nexports.m = m;\nexports.motion = motion;\nexports.motionValue = motionValue;\nexports.resolveMotionValue = resolveMotionValue;\nexports.snapshotViewportBox = snapshotViewportBox;\nexports.transform = transform;\nexports.useAnimation = useAnimation;\nexports.useCycle = useCycle;\nexports.useDeprecatedAnimatedState = useAnimatedState;\nexports.useDeprecatedInvertedScale = useInvertedScale;\nexports.useDomEvent = useDomEvent;\nexports.useDragControls = useDragControls;\nexports.useElementScroll = useElementScroll;\nexports.useIsPresent = useIsPresent;\nexports.useMotionTemplate = useMotionTemplate;\nexports.useMotionValue = useMotionValue;\nexports.usePresence = usePresence;\nexports.useReducedMotion = useReducedMotion;\nexports.useSpring = useSpring;\nexports.useTransform = useTransform;\nexports.useVelocity = useVelocity;\nexports.useViewportScroll = useViewportScroll;\nexports.visualElement = visualElement;\n"],"mappings":"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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS42B,QAAT,GAAoB;EAChB,IAAIC,KAAK,GAAG,EAAZ;;EACA,KAAK,IAAIrV,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG/E,SAAS,CAAC9/B,MAAhC,EAAwC6kC,EAAE,EAA1C,EAA8C;IAC1CqV,KAAK,CAACrV,EAAD,CAAL,GAAY/E,SAAS,CAAC+E,EAAD,CAArB;EACH;;EACD,IAAIhhB,KAAK,GAAG5mB,KAAK,CAACyE,MAAN,CAAa,CAAb,CAAZ;;EACA,IAAId,EAAE,GAAG7D,KAAK,CAACwhB,MAAN,CAAathB,KAAK,CAACuwC,QAAN,CAAe0M,KAAK,CAACr2B,KAAK,CAACliB,OAAP,CAApB,CAAb,EAAmD,CAAnD,CAAT;EAAA,IAAgEgiB,IAAI,GAAG/iB,EAAE,CAAC,CAAD,CAAzE;EAAA,IAA8Eu5C,OAAO,GAAGv5C,EAAE,CAAC,CAAD,CAA1F;;EACA,OAAO,CACH+iB,IADG,EAEH,UAAUzG,IAAV,EAAgB;IACZ2G,KAAK,CAACliB,OAAN,GACI,OAAOub,IAAP,KAAgB,QAAhB,GACM9f,SAAS,CAACg9C,IAAV,CAAe,CAAf,EAAkBF,KAAK,CAACl6C,MAAxB,EAAgC6jB,KAAK,CAACliB,OAAN,GAAgB,CAAhD,CADN,GAEMub,IAHV;IAIAi9B,OAAO,CAACD,KAAK,CAACr2B,KAAK,CAACliB,OAAP,CAAN,CAAP;EACH,CARE,CAAP;AAUH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAI04C,YAAY;AAAG;AAA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"},"metadata":{},"sourceType":"script"}